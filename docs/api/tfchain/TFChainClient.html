<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>tfchain.TFChainClient API documentation</title>
<meta name="description" content="Tfchain Client" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tfchain.TFChainClient</code></h1>
</header>
<section id="section-intro">
<p>Tfchain Client</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Tfchain Client
&#34;&#34;&#34;

import sys

import tfchain
from tfchain.internal.jsutils import json_loads, epoch2HRDateTime

from tfchain.types import ConditionTypes, transactions
from tfchain.types.ConditionTypes import UnlockHash, UnlockHashType, ConditionMultiSignature
from tfchain.types.PrimitiveTypes import Hash, Currency
from tfchain.types.IO import CoinOutput, BlockstakeOutput
from tfchain.types.CryptoTypes import PublicKey
from tfchain.types.ThreeBot import BotName, NetworkAddress
from tfchain.types.ERC20 import ERC20Address
from tfchain.types.transactions.Base import TransactionBaseClass
from tfchain.types.transactions.Minting import TransactionV128
from tfchain.TFChainWallet import WalletBalance, MultiSigWalletBalance
from tfchain.TFChainExplorerClient import TFChainExplorerClient

class NetworkType:
    def __init__(self, value):
        if isinstance(value, NetworkType):
            value = value.value
        self._value = value

    @property
    def value(self):
        return self._value

    def __eq__(self, other):
        if isinstance(other, UnlockHashType):
            return self.value == other.value
        return self.value == other

    def __int__(self):
        return self.value

    @classmethod
    def from_str(cls, s):
        if not isinstance(s, str):
            raise TypeError(&#34;can only convert from a string&#34;)
        s = s.lower()
        if s in (&#34;standard&#34;, &#34;std&#34;):
            return NetworkType.STANDARD
        if s == &#34;testnet&#34;:
            return NetworkType.TESTNET
        if s == &#34;devnet&#34;:
            return NetworkType.DEVNET

    def minimum_miner_fee(self):
        if self == NetworkType.DEVNET:
            return Currency(&#39;1.0&#39;)
        return Currency(&#39;0.1&#39;)

    def default_explorer_addresses(self):
        if self == NetworkType.STANDARD:
            return [
                &#39;https://explorer.threefoldtoken.com&#39;,
                &#39;https://explorer2.threefoldtoken.com&#39;,
                &#39;https://explorer3.threefoldtoken.com&#39;,
                &#39;https://explorer4.threefoldtoken.com&#39;,
            ]
        if self == NetworkType.TESTNET:
            return [
                &#39;https://explorer.testnet.threefoldtoken.com&#39;,
                &#39;https://explorer2.testnet.threefoldtoken.com&#39;,
            ]
        # DEVNET
        return [
            &#39;http://localhost:23110&#39;
        ]

NetworkType.STANDARD = NetworkType(0)
NetworkType.TESTNET = NetworkType(1)
NetworkType.DEVNET = NetworkType(2)

class TFChainClient:
    &#34;&#34;&#34;
    Tfchain client object
    &#34;&#34;&#34;
    def __init__(self, explorer_client=None, network_type=None):
        self._network_type = network_type
        if self._network_type is not None:
            if isinstance(self._network_type, str):
                self._network_type = NetworkType.from_str(self._network_type)
            elif not isinstance(self._network_type, NetworkType):
                raise TypeError(&#34;network_type is expected to be None or of type str or NetworkType, not of type {}&#34;.format(type(self._network_type)))
        # create explorer_client if not given
        self._explorer_client = explorer_client
        if not self._explorer_client:
            if self._network_type is None:
                self._network_type = NetworkType.STANDARD
            explorer_addresses = self._network_type.default_explorer_addresses()
            self._explorer_client = TFChainExplorerClient(addresses=explorer_addresses)
        elif not isinstance(explorer_client, TFChainExplorerClient):
            raise TypeError(&#34;explorer client has to be of type TFChainExplorerClient not {}&#34;.format(type(explorer_client)))
        elif self._network_type is None:
            # fetch network type from the explorer client
            resp = self._explorer_client.get(&#34;/explorer/constants&#34;)
            resp = json_loads(resp)
            self._network_type = NetworkType.from_str(resp.get(&#34;chaininfo&#34;, {}).get(&#34;NetworkName&#34;, &#34;standard&#34;))

        # create subclients
        self._threebot = TFChainThreeBotClient(self)
        self._minter = TFChainMinterClient(self)
        self._erc20 = TFChainERC20Client(self)

    @property
    def network(self):
        return self._network_type

    @property
    def threebot(self):
        &#34;&#34;&#34;
        ThreeBot Client API.
        &#34;&#34;&#34;
        return self._threebot

    @property
    def minter(self):
        &#34;&#34;&#34;
        Minter Client API.
        &#34;&#34;&#34;
        return self._minter

    @property
    def erc20(self):
        &#34;&#34;&#34;
        ERC20 Client API.
        &#34;&#34;&#34;
        return self._erc20

    @property
    def explorer_addresses(self):
        &#34;&#34;&#34;
        Addresses of the explorers to use
        &#34;&#34;&#34;
        return self._explorer_client.addresses

    @property
    def minimum_miner_fee(self):
        return self._network_type.minimum_miner_fee()

    def blockchain_info_get(self):
        &#34;&#34;&#34;
        Get the current blockchain info, using the last known block, as reported by an explorer.
        &#34;&#34;&#34;
        resp = self.explorer_get(endpoint=&#34;/explorer&#34;)
        resp = json_loads(resp)
        blockid = Hash.from_json(obj=resp[&#39;blockid&#39;])
        last_block = self.block_get(blockid)
        return ExplorerBlockchainInfo(last_block=last_block)

    def block_get(self, value):
        &#34;&#34;&#34;
        Get a block from an available explorer Node.
        
        @param value: the identifier or height that points to the desired block
        &#34;&#34;&#34;
        endpoint = &#34;/explorer/?&#34;
        resp = {}
        try:
            # get the explorer block
            if isinstance(value, int):
                endpoint = &#34;/explorer/blocks/{}&#34;.format(int(value))
                resp = self.explorer_get(endpoint=endpoint)
                resp = json_loads(resp)
                resp = resp[&#39;block&#39;]
            else:
                blockid = self._normalize_id(value)
                endpoint = &#34;/explorer/hashes/&#34;+blockid
                resp = self.explorer_get(endpoint=endpoint)
                resp = json_loads(resp)
                if resp[&#39;hashtype&#39;] != &#39;blockid&#39;:
                    raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;blockid&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
                resp = resp[&#39;block&#39;]
                if resp[&#39;blockid&#39;] != blockid:
                    raise tfchain.errors.ExplorerInvalidResponse(&#34;expected block ID &#39;{}&#39; not &#39;{}&#39;&#34;.format(blockid, resp[&#39;blockid&#39;]), endpoint, resp)
            # parse the transactions
            transactions = []
            for etxn in resp[&#39;transactions&#39;]:
                # parse the explorer transaction
                transaction = self._transaction_from_explorer_transaction(etxn, endpoint=endpoint, resp=resp)
                # append the transaction to the list of transactions
                transactions.append(transaction)
            rawblock = resp[&#39;rawblock&#39;]
            # parse the parent id
            parentid = Hash.from_json(obj=rawblock[&#39;parentid&#39;])
            # parse the miner payouts
            miner_payouts = []
            minerpayoutids = resp.get(&#39;minerpayoutids&#39;, None) or []
            eminerpayouts = rawblock.get(&#39;minerpayouts&#39;, None) or []
            if len(eminerpayouts) != len(minerpayoutids):
                raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of miner payouts and payout ids are not matching: {} != {}&#34;.format(len(eminerpayouts), len(minerpayoutids)), endpoint, resp)
            for idx, mp in enumerate(eminerpayouts):
                id = Hash.from_json(minerpayoutids[idx])
                value = Currency.from_json(mp[&#39;value&#39;])
                unlockhash = UnlockHash.from_json(mp[&#39;unlockhash&#39;])
                miner_payouts.append(ExplorerMinerPayout(id=id, value=value, unlockhash=unlockhash))
            # get the timestamp and height
            height = int(resp[&#39;height&#39;])
            timestamp = int(rawblock[&#39;timestamp&#39;])
            # get the block&#39;s identifier
            blockid = Hash.from_json(resp[&#39;blockid&#39;])
            # return the block, as reported by the explorer
            return ExplorerBlock(
                id=blockid, parentid=parentid,
                height=height, timestamp=timestamp,
                transactions=transactions, miner_payouts=miner_payouts)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def transaction_get(self, txid):
        &#34;&#34;&#34;
        Get a transaction from an available explorer Node.

        @param txid: the identifier (bytes, bytearray, hash or string) that points to the desired transaction
        &#34;&#34;&#34;
        txid = self._normalize_id(txid)
        endpoint = &#34;/explorer/hashes/&#34;+txid
        resp = self.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            if resp[&#39;hashtype&#39;] != &#39;transactionid&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;transactionid&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            resp = resp[&#39;transaction&#39;]
            if resp[&#39;id&#39;] != txid:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected transaction ID &#39;{}&#39; not &#39;{}&#39;&#34;.format(txid, resp[&#39;id&#39;]), endpoint, resp)
            return self._transaction_from_explorer_transaction(resp, endpoint=endpoint, resp=resp)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit a transaction to an available explorer Node.

        @param transaction: the transaction to push to the client transaction pool
        &#34;&#34;&#34;
        if isinstance(transaction, TransactionBaseClass):
            transaction = transaction.json()
        endpoint = &#34;/transactionpool/transactions&#34;
        resp = self.explorer_post(endpoint=endpoint, data=transaction)
        resp = json_loads(resp)
        try:
            return str(Hash(value=resp[&#39;transactionid&#39;]))
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def unlockhash_get(self, target):
        &#34;&#34;&#34;
        Get all transactions linked to the given unlockhash (target),
        as well as other information such as the multisig addresses linked to the given unlockhash (target).

        target can be any of:
            - None: unlockhash of the Free-For-All wallet will be used
            - str (or unlockhash/bytes/bytearray): target is assumed to be the unlockhash of a personal wallet
            - list: target is assumed to be the addresses of a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): target is a sigcount-of-addresscount MultiSig wallet

        @param target: the target wallet to look up transactions for in the explorer, see above for more info
        &#34;&#34;&#34;
        unlockhash = str(ConditionTypes.from_recipient(target).unlockhash)
        endpoint = &#34;/explorer/hashes/&#34;+unlockhash
        resp = self.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            if resp[&#39;hashtype&#39;] != &#39;unlockhash&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;unlockhash&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            # parse the transactions
            transactions = []
            for etxn in resp[&#39;transactions&#39;]:
                # parse the explorer transaction
                transaction = self._transaction_from_explorer_transaction(etxn, endpoint=endpoint, resp=resp)
                # append the transaction to the list of transactions
                transactions.append(transaction)
            # collect all multisig addresses
            multisig_addresses = [UnlockHash.from_json(obj=uh) for uh in resp.get(&#39;multisigaddresses&#39;, None) or []]
            for addr in multisig_addresses:
                if addr.type != UnlockHashType.MULTI_SIG:
                    raise tfchain.errors.ExplorerInvalidResponse(&#34;invalid unlock hash type {} for MultiSignature Address (expected: 3)&#34;.format(addr.type), endpoint, resp)
            erc20_info = None
            if &#39;erc20info&#39; in resp:
                info = resp[&#39;erc20info&#39;]
                erc20_info = ERC20AddressInfo(
                    address_tft=UnlockHash.from_json(info[&#39;tftaddress&#39;]),
                    address_erc20=ERC20Address.from_json(info[&#39;erc20address&#39;]),
                    confirmations=int(info[&#39;confirmations&#39;]),
                )

            # sort the transactions by height
            transactions.sort(key=(lambda txn: sys.maxsize if txn.height &lt; 0 else txn.height), reverse=True)

            # return explorer data for the unlockhash
            return ExplorerUnlockhashResult(
                unlockhash=UnlockHash.from_json(unlockhash),
                transactions=transactions,
                multisig_addresses=multisig_addresses,
                erc20_info=erc20_info,
                client=self)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def coin_output_get(self, id):
        &#34;&#34;&#34;
        Get a coin output from an available explorer Node.

        Returns (output, creation_txn, spend_txn).

        @param id: the identifier (bytes, bytearray, hash or string) that points to the desired coin output
        &#34;&#34;&#34;
        return self._output_get(id, expected_hash_type=&#39;coinoutputid&#39;)

    def blockstake_output_get(self, id):
        &#34;&#34;&#34;
        Get a blockstake output from an available explorer Node.

        Returns (output, creation_txn, spend_txn).

        @param id: the identifier (bytes, bytearray, hash or string) that points to the desired blockstake output
        &#34;&#34;&#34;
        return self._output_get(id, expected_hash_type=&#39;blockstakeoutputid&#39;)

    def _output_get(self, id, expected_hash_type):
        &#34;&#34;&#34;
        Get an output from an available explorer Node.

        Returns (output, creation_txn, spend_txn).

        @param id: the identifier (bytes, bytearray, hash or string) that points to the desired output
        @param expected_hash_type: one of (&#39;coinoutputid&#39;, &#39;blockstakeoutputid&#39;)
        &#34;&#34;&#34;
        if expected_hash_type not in (&#39;coinoutputid&#39;, &#39;blockstakeoutputid&#39;):
            raise ValueError(&#34;expected hash type should be one of (&#39;coinoutputid&#39;, &#39;blockstakeoutputid&#39;), not {}&#34;.format(expected_hash_type))
        id = self._normalize_id(id)
        endpoint = &#34;/explorer/hashes/&#34;+id
        resp = self.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            hash_type = resp[&#39;hashtype&#39;]
            if hash_type != expected_hash_type:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;{}&#39;, not &#39;{}&#39;&#34;.format(expected_hash_type, hash_type), endpoint, resp)
            tresp = resp[&#39;transactions&#39;]
            lresp = len(tresp)
            if lresp not in (1, 2):
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected one or two transactions to be returned, not {}&#34;.format(lresp), endpoint, resp)
            # parse the transaction(s)
            creation_txn = tresp[0]
            spend_txn = None
            if lresp == 2:
                if tresp[1][&#39;height&#39;] &gt; creation_txn[&#39;height&#39;]:
                    spend_txn = tresp[1]
                else:
                    spend_txn = creation_txn
                    creation_txn = tresp[1]
            creation_txn = self._transaction_from_explorer_transaction(creation_txn, endpoint=endpoint, resp=resp)
            if spend_txn is not None:
                spend_txn = self._transaction_from_explorer_transaction(spend_txn, endpoint=endpoint, resp=resp)
            # collect the output
            output = None
            for out in (creation_txn.coin_outputs if hash_type == &#39;coinoutputid&#39; else creation_txn.blockstake_outputs):
                if str(out.id) == id:
                    output = out
                    break
            if output is None:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected output {} to be part of creation Tx, but it wasn&#39;t&#34;.format(id), endpoint, resp)
            # return the output and related transaction(s)
            return (output, creation_txn, spend_txn)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def _transaction_from_explorer_transaction(self, etxn, endpoint=&#34;/?&#34;, resp=None): # keyword parameters for error handling purposes only
        if resp is None:
            resp = {}
        # parse the transactions
        transaction = transactions.from_json(obj=etxn[&#39;rawtransaction&#39;], id=etxn[&#39;id&#39;])
        # add the parent (coin) outputs
        coininputoutputs = etxn.get(&#39;coininputoutputs&#39;, None) or []
        if len(transaction.coin_inputs) != len(coininputoutputs):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of coin inputs and parent outputs are not matching: {} != {}&#34;.format(len(transaction.coin_inputs), len(coininputoutputs)), endpoint, resp)
        for (idx, co) in enumerate(coininputoutputs):
            co = CoinOutput.from_json(obj=co)
            co.id = transaction.coin_inputs[idx].parentid
            transaction.coin_inputs[idx].parent_output = co
        # add the coin output ids
        coinoutputids = etxn.get(&#39;coinoutputids&#39;, None) or []
        if len(transaction.coin_outputs) != len(coinoutputids):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of coin outputs and output identifiers are not matching: {} != {}&#34;.format(len(transaction.coin_outputs), len(coinoutputids)), endpoint, resp)
        for (idx, id) in enumerate(coinoutputids):
            transaction.coin_outputs[idx].id = Hash.from_json(obj=id)
        # add the parent (blockstake) outputs
        blockstakeinputoutputs = etxn.get(&#39;blockstakeinputoutputs&#39;, None) or []
        if len(transaction.blockstake_inputs) != len(blockstakeinputoutputs):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of blockstake inputs and parent outputs are not matching: {} != {}&#34;.format(len(transaction.blockstake_inputs), len(blockstakeinputoutputs)), endpoint, resp)
        for (idx, bso) in enumerate(blockstakeinputoutputs):
            bso = BlockstakeOutput.from_json(obj=bso)
            bso.id = transaction.blockstake_inputs[idx].parentid
            transaction.blockstake_inputs[idx].parent_output = bso
        # add the blockstake output ids
        blockstakeoutputids = etxn.get(&#39;blockstakeoutputids&#39;, None) or []
        if len(transaction.blockstake_outputs) != len(blockstakeoutputids):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of blokstake outputs and output identifiers are not matching: {} != {}&#34;.format(len(transaction.blockstake_inputs), len(blockstakeoutputids)), endpoint, resp)
        for (idx, id) in enumerate(blockstakeoutputids):
            transaction.blockstake_outputs[idx].id = Hash.from_json(obj=id)
        # set the unconfirmed state
        transaction.unconfirmed = etxn.get(&#39;unconfirmed&#39;, False)
        # set the height of the transaction only if confirmed
        if not transaction.unconfirmed:
            transaction.height = int(etxn.get(&#39;height&#39;))
        # return the transaction
        return transaction

    def explorer_get(self, endpoint):
        &#34;&#34;&#34;
        Utility method that gets the data on the given endpoint,
        but in a method so it can be overriden, internally, for Testing purposes.
        &#34;&#34;&#34;
        return self._explorer_client.get(endpoint)

    def explorer_post(self, endpoint, data):
        &#34;&#34;&#34;
        Utility method that sets the data on the given endpoint,
        but in a method so it can be overriden, internally, for Testing purposes.
        &#34;&#34;&#34;
        return self._explorer_client.post(endpoint, data)

    def _normalize_id(self, id):
        return str(Hash(value=id))


class ExplorerBlockchainInfo():
    def __init__(self, last_block):
        self._last_block = last_block

    @property
    def last_block(self):
        &#34;&#34;&#34;
        Last known block.
        &#34;&#34;&#34;
        return self._last_block

    @property
    def blockid(self):
        &#34;&#34;&#34;
        ID of last known block.
        &#34;&#34;&#34;
        return str(self.last_block.id)
    
    @property
    def height(self):
        &#34;&#34;&#34;
        Current height of the blockchain.
        &#34;&#34;&#34;
        return self.last_block.height
    
    @property
    def timestamp(self):
        &#34;&#34;&#34;
        The timestamp of the last registered block on the chain.
        &#34;&#34;&#34;
        return self.last_block.timestamp

    def __repr__(self):
        return &#34;Block {} at height {}, published on {}, is the last known block.&#34;.format(
            self.blockid, self.height, epoch2HRDateTime(self.timestamp))


class ExplorerUnlockhashResult():
    def __init__(self, unlockhash, transactions, multisig_addresses, erc20_info, client=None):
        &#34;&#34;&#34;
        All the info found for a given unlock hash, as reported by an explorer.
        &#34;&#34;&#34;
        self._unlockhash = unlockhash
        self._transactions = transactions
        self._multisig_addresses = multisig_addresses
        # client is optionally used to get additional info in a lazy manner should it be needed
        if client is not None and not isinstance(client, TFChainClient):
            raise TypeError(&#34;client cannot be set to a value of type {}&#34;.format(type(client)))
        self._client = client
        self._erc20_info = erc20_info
    
    @property
    def unlockhash(self):
        &#34;&#34;&#34;
        Unlock hash looked up.
        &#34;&#34;&#34;
        return self._unlockhash
    
    @property
    def transactions(self):
        &#34;&#34;&#34;
        Transactions linked to the looked up unlockhash.
        &#34;&#34;&#34;
        return self._transactions

    @property
    def multisig_addresses(self):
        &#34;&#34;&#34;
        Addresses of multisignature wallets co-owned by the looked up unlockhash.
        &#34;&#34;&#34;
        return self._multisig_addresses

    @property
    def erc20_info(self):
        return self._erc20_info

    def __repr__(self):
        return &#34;Found {} transaction(s) and {} multisig address(es) for {}&#34;.format(
            len(self._transactions), len(self._multisig_addresses), str(self._unlockhash))

    def balance(self, info=None):
        &#34;&#34;&#34;
        Compute a balance report for the defined unlockhash,
        based on the transactions of this report.
        &#34;&#34;&#34;
        if self._unlockhash.type == UnlockHashType.MULTI_SIG:
            balance = self._multisig_balance(info)
        else:
            balance = WalletBalance()
            # collect the balance
            address = str(self.unlockhash)
            for txn in self.transactions:
                for ci in txn.coin_inputs:
                    if str(ci.parent_output.condition.unlockhash) == address:
                        balance.output_add(ci.parent_output, confirmed=(not txn.unconfirmed), spent=True)
                for co in txn.coin_outputs:
                    if str(co.condition.unlockhash) == address:
                        balance.output_add(co, confirmed=(not txn.unconfirmed), spent=False)
        # if a client is set, attach the current chain info to it
        info = self._get_info(info)
        if info is not None:
            balance.chain_height = info.height
            balance.chain_time = info.timestamp
            balance.chain_blockid = info.blockid
        return balance
    
    def _multisig_balance(self, info):
        balance = None
        # collect the balance
        address = str(self.unlockhash)
        for txn in self.transactions:
            for ci in txn.coin_inputs:
                if str(ci.parent_output.condition.unlockhash) == address:
                    oc = ci.parent_output.condition.unwrap()
                    if not isinstance(oc, ConditionMultiSignature):
                        raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
                    if balance is None:
                        balance = MultiSigWalletBalance(owners=oc.unlockhashes, signature_count=oc.required_signatures)
                    balance.output_add(ci.parent_output, confirmed=(not txn.unconfirmed), spent=True)
            for co in txn.coin_outputs:
                if str(co.condition.unlockhash) == address:
                    oc = co.condition.unwrap()
                    if not isinstance(oc, ConditionMultiSignature):
                        raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
                    if balance is None:
                        balance = MultiSigWalletBalance(owners=oc.unlockhashes, signature_count=oc.required_signatures)
                    balance.output_add(co, confirmed=(not txn.unconfirmed), spent=False)
            if isinstance(txn, TransactionV128):
                oc = txn.mint_condition
                balance = MultiSigWalletBalance(owners=oc.unlockhashes, signature_count=oc.required_signatures)
        if balance is None:
            return WalletBalance() # return empty balance
        return balance

    def _get_info(self, info):
        if info is not None or self._client is None:
            return info
        return self._client.blockchain_info_get()

class ERC20AddressInfo():
    &#34;&#34;&#34;
    Contains the information for an ERC20 address (registration).
    &#34;&#34;&#34;
    def __init__(self, address_tft, address_erc20, confirmations):
        self._address_tft = address_tft
        self._address_erc20 = address_erc20
        self._confirmations = confirmations

    @property
    def address_tft(self):
        return self._address_tft
    @property
    def address_erc20(self):
        return self._address_erc20
    @property
    def confirmations(self):
        return self._confirmations

class ExplorerBlock():
    def __init__(self, id, parentid, height, timestamp, transactions, miner_payouts):
        &#34;&#34;&#34;
        A Block, registered on a TF blockchain, as reported by an explorer.
        &#34;&#34;&#34;
        self._id = id
        self._parentid = parentid
        self._height = height
        self._timestamp = timestamp
        self._transactions = transactions
        self._miner_payouts = miner_payouts
    
    @property
    def id(self):
        &#34;&#34;&#34;
        Identifier of this block.
        &#34;&#34;&#34;
        return str(self._id)

    @property
    def parentid(self):
        &#34;&#34;&#34;
        Identifier the parent of this block.
        &#34;&#34;&#34;
        return str(self._parentid)

    @property
    def height(self):
        &#34;&#34;&#34;
        Height at which this block is registered.
        &#34;&#34;&#34;
        return self._height

    @property
    def timestamp(self):
        &#34;&#34;&#34;
        Timestamp on which this block is registered.
        &#34;&#34;&#34;
        return self._timestamp

    @property
    def transactions(self):
        &#34;&#34;&#34;
        Transactions that are included in this block.
        &#34;&#34;&#34;
        return self._transactions

    @property
    def miner_payouts(self):
        &#34;&#34;&#34;
        Miner payouts that are included in this block.
        &#34;&#34;&#34;
        return self._miner_payouts
    
    def __str__(self):
        return str(self.id)
    __repr__ = __str__


class ExplorerMinerPayout():
    def __init__(self, id, value, unlockhash):
        &#34;&#34;&#34;
        A single miner payout, as ereported by an explorer.
        &#34;&#34;&#34;
        self._id = id
        self._value = value
        self._unlockhash = unlockhash

    @property
    def id(self):
        &#34;&#34;&#34;
        Identifier of this miner payout.
        &#34;&#34;&#34;
        return str(self._id)

    @property
    def value(self):
        &#34;&#34;&#34;
        Value of this miner payout.
        &#34;&#34;&#34;
        return self._value

    @property
    def unlockhash(self):
        &#34;&#34;&#34;
        Unlock hash that received this miner payout&#39;s value.
        &#34;&#34;&#34;
        return str(self._unlockhash)
    
    def __str__(self):
        return str(self.id)
    __repr__ = __str__


class TFChainMinterClient():
    &#34;&#34;&#34;
    TFChainMinterClient contains all Coin Minting logic.
    &#34;&#34;&#34;

    def __init__(self, client):
        if not isinstance(client, TFChainClient):
            raise TypeError(&#34;client is expected to be a TFChainClient&#34;)
        self._client = client

    def condition_get(self, height=None):
        &#34;&#34;&#34;
        Get the latest (coin) mint condition or the (coin) mint condition at the specified block height.

        @param height: if defined the block height at which to look up the (coin) mint condition (if none latest block will be used)
        &#34;&#34;&#34;
        # define the endpoint
        endpoint = &#34;/explorer/mintcondition&#34;
        if height is not None:
            if not isinstance(height, (int, str)):
                raise TypeError(&#34;invalid block height given&#34;)
            height = int(height)
            endpoint += &#34;/%d&#34;%(height)

        # get the mint condition
        resp = self._client.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)

        try:
            # return the decoded mint condition
            return ConditionTypes.from_json(obj=resp[&#39;mintcondition&#39;])
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc


class TFChainThreeBotClient():
    &#34;&#34;&#34;
    TFChainThreeBotClient contains all ThreeBot Logic
    &#34;&#34;&#34;

    def __init__(self, client):
        if not isinstance(client, TFChainClient):
            raise TypeError(&#34;client is expected to be a TFChainClient&#34;)
        self._client = client

    def record_get(self, identifier):
        &#34;&#34;&#34;
        Get a 3Bot record registered on a TFchain network
        @param identifier: unique 3Bot id, public key or (bot) name to search a 3Bot record for
        &#34;&#34;&#34;
        endpoint = &#34;/explorer/3bot&#34;
        if isinstance(identifier, int):
            identifier = str(identifier)
        elif isinstance(identifier, BotName):
            endpoint = &#34;/explorer/whois/3bot&#34;
            identifier = str(identifier)
        elif isinstance(identifier, PublicKey):
            identifier = str(identifier)
        elif isinstance(identifier, str):
            if BotName.REGEXP.match(identifier) is not None:
                endpoint = &#34;/explorer/whois/3bot&#34;
            else:
                try:
                    PublicKey.from_json(identifier)
                except ValueError as exc:
                    raise ValueError(&#34;a 3Bot identifier in string format has to be either a valid BotName or PublicKey, &#39;{}&#39; is neither&#34;.format(identifier)) from exc
        else:
            raise TypeError(&#34;identifier of type {} is invalid&#34;.format(type(identifier)))
        # identifier is a str at this point
        # and endpoint is configured

        # fetch the data
        endpoint += &#34;/{}&#34;.format(identifier)
        try:
            resp = self._client.explorer_get(endpoint=endpoint)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.ThreeBotNotFound(identifier) from exc
        resp = json_loads(resp)
        try:
            # return the fetched record as a named tuple, for easy semi-typed access
            record = resp[&#39;record&#39;]
            return ThreeBotRecord(
                identifier=int(record[&#39;id&#39;]),
                names=[BotName.from_json(name) for name in record.get(&#39;names&#39;, []) or []],
                addresses=[NetworkAddress.from_json(address) for address in record.get(&#39;addresses&#39;, []) or []],
                public_key=PublicKey.from_json(record[&#39;publickey&#39;]),
                expiration=int(record[&#39;expiration&#39;]),
            )
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc


class TFChainERC20Client():
    &#34;&#34;&#34;
    TFChainERC20Client contains all ERC20 Logic
    &#34;&#34;&#34;

    def __init__(self, client):
        if not isinstance(client, TFChainClient):
            raise TypeError(&#34;client is expected to be a TFChainClient&#34;)
        self._client = client

    def address_get(self, unlockhash):
        &#34;&#34;&#34;
        Get the ERC20 (withdraw) address for the given unlock hash,
        ExplorerNoContent error is raised when no address could be found for the given unlock hash.

        Only type 01 addresses can be looked up for this method (personal wallet addresses),
        as there can be no MultiSignature (wallet) address registered as an ERC20 withdraw address.

        @param unlockhash: the str or wallet address to be looked up
        &#34;&#34;&#34;
        if isinstance(unlockhash, str):
            unlockhash = UnlockHash.from_json(unlockhash)
        elif not isinstance(unlockhash, UnlockHash):
            raise TypeError(&#34;{} is not a valid type and cannot be used as unlock hash&#34;.format(type(unlockhash)))
        if unlockhash.type != UnlockHashType.PUBLIC_KEY:
            raise TypeError(&#34;only person wallet addresses cannot be registered as withdrawel addresses: {} is an invalid unlock hash type&#34;.format(unlockhash.type))
    
        endpoint = &#34;/explorer/hashes/&#34;+str(unlockhash)
        resp = self._client.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            if resp[&#39;hashtype&#39;] != &#39;unlockhash&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;unlockhash&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            # parse the ERC20 Info
            if not &#39;erc20info&#39; in resp:
                raise tfchain.errors.ExplorerNoContent(&#34;{} could be found but is not registered as an ERC20 withdraw address&#34;.format(str(unlockhash)), endpoint=endpoint)
            info = resp[&#39;erc20info&#39;]
            return ERC20AddressInfo(
                address_tft=UnlockHash.from_json(info[&#39;tftaddress&#39;]),
                address_erc20=ERC20Address.from_json(info[&#39;erc20address&#39;]),
                confirmations=int(info[&#39;confirmations&#39;]),
            )
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

class ThreeBotRecord():
    &#34;&#34;&#34;
    ThreeBotRecord is a named tuple,
    used to represent a ThreeBot Record as fetched from an explorer,
    as the result of a local function.
    &#34;&#34;&#34;
    def __init__(self, identifier, names, addresses, public_key, expiration):
        self._identifier = identifier
        self._names = names
        self._addresses = addresses
        self._public_key = public_key
        self._expiration = expiration

    @property
    def identifier(self):
        return self._identifier
    @property
    def names(self):
        return self._names
    @property
    def addresses(self):
        return self._addresses
    @property
    def public_key(self):
        return self._public_key
    @property
    def expiration(self):
        return self._expiration</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tfchain.TFChainClient.ERC20AddressInfo"><code class="flex name class">
<span>class <span class="ident">ERC20AddressInfo</span></span>
<span>(</span><span>address_tft, address_erc20, confirmations)</span>
</code></dt>
<dd>
<section class="desc"><p>Contains the information for an ERC20 address (registration).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ERC20AddressInfo():
    &#34;&#34;&#34;
    Contains the information for an ERC20 address (registration).
    &#34;&#34;&#34;
    def __init__(self, address_tft, address_erc20, confirmations):
        self._address_tft = address_tft
        self._address_erc20 = address_erc20
        self._confirmations = confirmations

    @property
    def address_tft(self):
        return self._address_tft
    @property
    def address_erc20(self):
        return self._address_erc20
    @property
    def confirmations(self):
        return self._confirmations</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.ERC20AddressInfo.address_erc20"><code class="name">var <span class="ident">address_erc20</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def address_erc20(self):
    return self._address_erc20</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ERC20AddressInfo.address_tft"><code class="name">var <span class="ident">address_tft</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def address_tft(self):
    return self._address_tft</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ERC20AddressInfo.confirmations"><code class="name">var <span class="ident">confirmations</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def confirmations(self):
    return self._confirmations</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlock"><code class="flex name class">
<span>class <span class="ident">ExplorerBlock</span></span>
<span>(</span><span>id, parentid, height, timestamp, transactions, miner_payouts)</span>
</code></dt>
<dd>
<section class="desc"><p>A Block, registered on a TF blockchain, as reported by an explorer.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ExplorerBlock():
    def __init__(self, id, parentid, height, timestamp, transactions, miner_payouts):
        &#34;&#34;&#34;
        A Block, registered on a TF blockchain, as reported by an explorer.
        &#34;&#34;&#34;
        self._id = id
        self._parentid = parentid
        self._height = height
        self._timestamp = timestamp
        self._transactions = transactions
        self._miner_payouts = miner_payouts
    
    @property
    def id(self):
        &#34;&#34;&#34;
        Identifier of this block.
        &#34;&#34;&#34;
        return str(self._id)

    @property
    def parentid(self):
        &#34;&#34;&#34;
        Identifier the parent of this block.
        &#34;&#34;&#34;
        return str(self._parentid)

    @property
    def height(self):
        &#34;&#34;&#34;
        Height at which this block is registered.
        &#34;&#34;&#34;
        return self._height

    @property
    def timestamp(self):
        &#34;&#34;&#34;
        Timestamp on which this block is registered.
        &#34;&#34;&#34;
        return self._timestamp

    @property
    def transactions(self):
        &#34;&#34;&#34;
        Transactions that are included in this block.
        &#34;&#34;&#34;
        return self._transactions

    @property
    def miner_payouts(self):
        &#34;&#34;&#34;
        Miner payouts that are included in this block.
        &#34;&#34;&#34;
        return self._miner_payouts
    
    def __str__(self):
        return str(self.id)
    __repr__ = __str__</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.ExplorerBlock.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<section class="desc"><p>Height at which this block is registered.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def height(self):
    &#34;&#34;&#34;
    Height at which this block is registered.
    &#34;&#34;&#34;
    return self._height</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlock.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"><p>Identifier of this block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;
    Identifier of this block.
    &#34;&#34;&#34;
    return str(self._id)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlock.miner_payouts"><code class="name">var <span class="ident">miner_payouts</span></code></dt>
<dd>
<section class="desc"><p>Miner payouts that are included in this block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def miner_payouts(self):
    &#34;&#34;&#34;
    Miner payouts that are included in this block.
    &#34;&#34;&#34;
    return self._miner_payouts</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlock.parentid"><code class="name">var <span class="ident">parentid</span></code></dt>
<dd>
<section class="desc"><p>Identifier the parent of this block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def parentid(self):
    &#34;&#34;&#34;
    Identifier the parent of this block.
    &#34;&#34;&#34;
    return str(self._parentid)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlock.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<section class="desc"><p>Timestamp on which this block is registered.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def timestamp(self):
    &#34;&#34;&#34;
    Timestamp on which this block is registered.
    &#34;&#34;&#34;
    return self._timestamp</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlock.transactions"><code class="name">var <span class="ident">transactions</span></code></dt>
<dd>
<section class="desc"><p>Transactions that are included in this block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transactions(self):
    &#34;&#34;&#34;
    Transactions that are included in this block.
    &#34;&#34;&#34;
    return self._transactions</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlockchainInfo"><code class="flex name class">
<span>class <span class="ident">ExplorerBlockchainInfo</span></span>
<span>(</span><span>last_block)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ExplorerBlockchainInfo():
    def __init__(self, last_block):
        self._last_block = last_block

    @property
    def last_block(self):
        &#34;&#34;&#34;
        Last known block.
        &#34;&#34;&#34;
        return self._last_block

    @property
    def blockid(self):
        &#34;&#34;&#34;
        ID of last known block.
        &#34;&#34;&#34;
        return str(self.last_block.id)
    
    @property
    def height(self):
        &#34;&#34;&#34;
        Current height of the blockchain.
        &#34;&#34;&#34;
        return self.last_block.height
    
    @property
    def timestamp(self):
        &#34;&#34;&#34;
        The timestamp of the last registered block on the chain.
        &#34;&#34;&#34;
        return self.last_block.timestamp

    def __repr__(self):
        return &#34;Block {} at height {}, published on {}, is the last known block.&#34;.format(
            self.blockid, self.height, epoch2HRDateTime(self.timestamp))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.ExplorerBlockchainInfo.blockid"><code class="name">var <span class="ident">blockid</span></code></dt>
<dd>
<section class="desc"><p>ID of last known block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def blockid(self):
    &#34;&#34;&#34;
    ID of last known block.
    &#34;&#34;&#34;
    return str(self.last_block.id)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlockchainInfo.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<section class="desc"><p>Current height of the blockchain.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def height(self):
    &#34;&#34;&#34;
    Current height of the blockchain.
    &#34;&#34;&#34;
    return self.last_block.height</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlockchainInfo.last_block"><code class="name">var <span class="ident">last_block</span></code></dt>
<dd>
<section class="desc"><p>Last known block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def last_block(self):
    &#34;&#34;&#34;
    Last known block.
    &#34;&#34;&#34;
    return self._last_block</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerBlockchainInfo.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<section class="desc"><p>The timestamp of the last registered block on the chain.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def timestamp(self):
    &#34;&#34;&#34;
    The timestamp of the last registered block on the chain.
    &#34;&#34;&#34;
    return self.last_block.timestamp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.ExplorerMinerPayout"><code class="flex name class">
<span>class <span class="ident">ExplorerMinerPayout</span></span>
<span>(</span><span>id, value, unlockhash)</span>
</code></dt>
<dd>
<section class="desc"><p>A single miner payout, as ereported by an explorer.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ExplorerMinerPayout():
    def __init__(self, id, value, unlockhash):
        &#34;&#34;&#34;
        A single miner payout, as ereported by an explorer.
        &#34;&#34;&#34;
        self._id = id
        self._value = value
        self._unlockhash = unlockhash

    @property
    def id(self):
        &#34;&#34;&#34;
        Identifier of this miner payout.
        &#34;&#34;&#34;
        return str(self._id)

    @property
    def value(self):
        &#34;&#34;&#34;
        Value of this miner payout.
        &#34;&#34;&#34;
        return self._value

    @property
    def unlockhash(self):
        &#34;&#34;&#34;
        Unlock hash that received this miner payout&#39;s value.
        &#34;&#34;&#34;
        return str(self._unlockhash)
    
    def __str__(self):
        return str(self.id)
    __repr__ = __str__</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.ExplorerMinerPayout.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"><p>Identifier of this miner payout.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;
    Identifier of this miner payout.
    &#34;&#34;&#34;
    return str(self._id)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerMinerPayout.unlockhash"><code class="name">var <span class="ident">unlockhash</span></code></dt>
<dd>
<section class="desc"><p>Unlock hash that received this miner payout's value.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def unlockhash(self):
    &#34;&#34;&#34;
    Unlock hash that received this miner payout&#39;s value.
    &#34;&#34;&#34;
    return str(self._unlockhash)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerMinerPayout.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Value of this miner payout.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def value(self):
    &#34;&#34;&#34;
    Value of this miner payout.
    &#34;&#34;&#34;
    return self._value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.ExplorerUnlockhashResult"><code class="flex name class">
<span>class <span class="ident">ExplorerUnlockhashResult</span></span>
<span>(</span><span>unlockhash, transactions, multisig_addresses, erc20_info, client=None)</span>
</code></dt>
<dd>
<section class="desc"><p>All the info found for a given unlock hash, as reported by an explorer.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ExplorerUnlockhashResult():
    def __init__(self, unlockhash, transactions, multisig_addresses, erc20_info, client=None):
        &#34;&#34;&#34;
        All the info found for a given unlock hash, as reported by an explorer.
        &#34;&#34;&#34;
        self._unlockhash = unlockhash
        self._transactions = transactions
        self._multisig_addresses = multisig_addresses
        # client is optionally used to get additional info in a lazy manner should it be needed
        if client is not None and not isinstance(client, TFChainClient):
            raise TypeError(&#34;client cannot be set to a value of type {}&#34;.format(type(client)))
        self._client = client
        self._erc20_info = erc20_info
    
    @property
    def unlockhash(self):
        &#34;&#34;&#34;
        Unlock hash looked up.
        &#34;&#34;&#34;
        return self._unlockhash
    
    @property
    def transactions(self):
        &#34;&#34;&#34;
        Transactions linked to the looked up unlockhash.
        &#34;&#34;&#34;
        return self._transactions

    @property
    def multisig_addresses(self):
        &#34;&#34;&#34;
        Addresses of multisignature wallets co-owned by the looked up unlockhash.
        &#34;&#34;&#34;
        return self._multisig_addresses

    @property
    def erc20_info(self):
        return self._erc20_info

    def __repr__(self):
        return &#34;Found {} transaction(s) and {} multisig address(es) for {}&#34;.format(
            len(self._transactions), len(self._multisig_addresses), str(self._unlockhash))

    def balance(self, info=None):
        &#34;&#34;&#34;
        Compute a balance report for the defined unlockhash,
        based on the transactions of this report.
        &#34;&#34;&#34;
        if self._unlockhash.type == UnlockHashType.MULTI_SIG:
            balance = self._multisig_balance(info)
        else:
            balance = WalletBalance()
            # collect the balance
            address = str(self.unlockhash)
            for txn in self.transactions:
                for ci in txn.coin_inputs:
                    if str(ci.parent_output.condition.unlockhash) == address:
                        balance.output_add(ci.parent_output, confirmed=(not txn.unconfirmed), spent=True)
                for co in txn.coin_outputs:
                    if str(co.condition.unlockhash) == address:
                        balance.output_add(co, confirmed=(not txn.unconfirmed), spent=False)
        # if a client is set, attach the current chain info to it
        info = self._get_info(info)
        if info is not None:
            balance.chain_height = info.height
            balance.chain_time = info.timestamp
            balance.chain_blockid = info.blockid
        return balance
    
    def _multisig_balance(self, info):
        balance = None
        # collect the balance
        address = str(self.unlockhash)
        for txn in self.transactions:
            for ci in txn.coin_inputs:
                if str(ci.parent_output.condition.unlockhash) == address:
                    oc = ci.parent_output.condition.unwrap()
                    if not isinstance(oc, ConditionMultiSignature):
                        raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
                    if balance is None:
                        balance = MultiSigWalletBalance(owners=oc.unlockhashes, signature_count=oc.required_signatures)
                    balance.output_add(ci.parent_output, confirmed=(not txn.unconfirmed), spent=True)
            for co in txn.coin_outputs:
                if str(co.condition.unlockhash) == address:
                    oc = co.condition.unwrap()
                    if not isinstance(oc, ConditionMultiSignature):
                        raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
                    if balance is None:
                        balance = MultiSigWalletBalance(owners=oc.unlockhashes, signature_count=oc.required_signatures)
                    balance.output_add(co, confirmed=(not txn.unconfirmed), spent=False)
            if isinstance(txn, TransactionV128):
                oc = txn.mint_condition
                balance = MultiSigWalletBalance(owners=oc.unlockhashes, signature_count=oc.required_signatures)
        if balance is None:
            return WalletBalance() # return empty balance
        return balance

    def _get_info(self, info):
        if info is not None or self._client is None:
            return info
        return self._client.blockchain_info_get()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.ExplorerUnlockhashResult.erc20_info"><code class="name">var <span class="ident">erc20_info</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def erc20_info(self):
    return self._erc20_info</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerUnlockhashResult.multisig_addresses"><code class="name">var <span class="ident">multisig_addresses</span></code></dt>
<dd>
<section class="desc"><p>Addresses of multisignature wallets co-owned by the looked up unlockhash.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def multisig_addresses(self):
    &#34;&#34;&#34;
    Addresses of multisignature wallets co-owned by the looked up unlockhash.
    &#34;&#34;&#34;
    return self._multisig_addresses</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerUnlockhashResult.transactions"><code class="name">var <span class="ident">transactions</span></code></dt>
<dd>
<section class="desc"><p>Transactions linked to the looked up unlockhash.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transactions(self):
    &#34;&#34;&#34;
    Transactions linked to the looked up unlockhash.
    &#34;&#34;&#34;
    return self._transactions</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ExplorerUnlockhashResult.unlockhash"><code class="name">var <span class="ident">unlockhash</span></code></dt>
<dd>
<section class="desc"><p>Unlock hash looked up.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def unlockhash(self):
    &#34;&#34;&#34;
    Unlock hash looked up.
    &#34;&#34;&#34;
    return self._unlockhash</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainClient.ExplorerUnlockhashResult.balance"><code class="name flex">
<span>def <span class="ident">balance</span></span>(<span>self, info=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute a balance report for the defined unlockhash,
based on the transactions of this report.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def balance(self, info=None):
    &#34;&#34;&#34;
    Compute a balance report for the defined unlockhash,
    based on the transactions of this report.
    &#34;&#34;&#34;
    if self._unlockhash.type == UnlockHashType.MULTI_SIG:
        balance = self._multisig_balance(info)
    else:
        balance = WalletBalance()
        # collect the balance
        address = str(self.unlockhash)
        for txn in self.transactions:
            for ci in txn.coin_inputs:
                if str(ci.parent_output.condition.unlockhash) == address:
                    balance.output_add(ci.parent_output, confirmed=(not txn.unconfirmed), spent=True)
            for co in txn.coin_outputs:
                if str(co.condition.unlockhash) == address:
                    balance.output_add(co, confirmed=(not txn.unconfirmed), spent=False)
    # if a client is set, attach the current chain info to it
    info = self._get_info(info)
    if info is not None:
        balance.chain_height = info.height
        balance.chain_time = info.timestamp
        balance.chain_blockid = info.blockid
    return balance</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.NetworkType"><code class="flex name class">
<span>class <span class="ident">NetworkType</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NetworkType:
    def __init__(self, value):
        if isinstance(value, NetworkType):
            value = value.value
        self._value = value

    @property
    def value(self):
        return self._value

    def __eq__(self, other):
        if isinstance(other, UnlockHashType):
            return self.value == other.value
        return self.value == other

    def __int__(self):
        return self.value

    @classmethod
    def from_str(cls, s):
        if not isinstance(s, str):
            raise TypeError(&#34;can only convert from a string&#34;)
        s = s.lower()
        if s in (&#34;standard&#34;, &#34;std&#34;):
            return NetworkType.STANDARD
        if s == &#34;testnet&#34;:
            return NetworkType.TESTNET
        if s == &#34;devnet&#34;:
            return NetworkType.DEVNET

    def minimum_miner_fee(self):
        if self == NetworkType.DEVNET:
            return Currency(&#39;1.0&#39;)
        return Currency(&#39;0.1&#39;)

    def default_explorer_addresses(self):
        if self == NetworkType.STANDARD:
            return [
                &#39;https://explorer.threefoldtoken.com&#39;,
                &#39;https://explorer2.threefoldtoken.com&#39;,
                &#39;https://explorer3.threefoldtoken.com&#39;,
                &#39;https://explorer4.threefoldtoken.com&#39;,
            ]
        if self == NetworkType.TESTNET:
            return [
                &#39;https://explorer.testnet.threefoldtoken.com&#39;,
                &#39;https://explorer2.testnet.threefoldtoken.com&#39;,
            ]
        # DEVNET
        return [
            &#39;http://localhost:23110&#39;
        ]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tfchain.TFChainClient.NetworkType.DEVNET"><code class="name">var <span class="ident">DEVNET</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="tfchain.TFChainClient.NetworkType.STANDARD"><code class="name">var <span class="ident">STANDARD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="tfchain.TFChainClient.NetworkType.TESTNET"><code class="name">var <span class="ident">TESTNET</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tfchain.TFChainClient.NetworkType.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def from_str(cls, s):
    if not isinstance(s, str):
        raise TypeError(&#34;can only convert from a string&#34;)
    s = s.lower()
    if s in (&#34;standard&#34;, &#34;std&#34;):
        return NetworkType.STANDARD
    if s == &#34;testnet&#34;:
        return NetworkType.TESTNET
    if s == &#34;devnet&#34;:
        return NetworkType.DEVNET</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.NetworkType.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def value(self):
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainClient.NetworkType.default_explorer_addresses"><code class="name flex">
<span>def <span class="ident">default_explorer_addresses</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def default_explorer_addresses(self):
    if self == NetworkType.STANDARD:
        return [
            &#39;https://explorer.threefoldtoken.com&#39;,
            &#39;https://explorer2.threefoldtoken.com&#39;,
            &#39;https://explorer3.threefoldtoken.com&#39;,
            &#39;https://explorer4.threefoldtoken.com&#39;,
        ]
    if self == NetworkType.TESTNET:
        return [
            &#39;https://explorer.testnet.threefoldtoken.com&#39;,
            &#39;https://explorer2.testnet.threefoldtoken.com&#39;,
        ]
    # DEVNET
    return [
        &#39;http://localhost:23110&#39;
    ]</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.NetworkType.minimum_miner_fee"><code class="name flex">
<span>def <span class="ident">minimum_miner_fee</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def minimum_miner_fee(self):
    if self == NetworkType.DEVNET:
        return Currency(&#39;1.0&#39;)
    return Currency(&#39;0.1&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient"><code class="flex name class">
<span>class <span class="ident">TFChainClient</span></span>
<span>(</span><span>explorer_client=None, network_type=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Tfchain client object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainClient:
    &#34;&#34;&#34;
    Tfchain client object
    &#34;&#34;&#34;
    def __init__(self, explorer_client=None, network_type=None):
        self._network_type = network_type
        if self._network_type is not None:
            if isinstance(self._network_type, str):
                self._network_type = NetworkType.from_str(self._network_type)
            elif not isinstance(self._network_type, NetworkType):
                raise TypeError(&#34;network_type is expected to be None or of type str or NetworkType, not of type {}&#34;.format(type(self._network_type)))
        # create explorer_client if not given
        self._explorer_client = explorer_client
        if not self._explorer_client:
            if self._network_type is None:
                self._network_type = NetworkType.STANDARD
            explorer_addresses = self._network_type.default_explorer_addresses()
            self._explorer_client = TFChainExplorerClient(addresses=explorer_addresses)
        elif not isinstance(explorer_client, TFChainExplorerClient):
            raise TypeError(&#34;explorer client has to be of type TFChainExplorerClient not {}&#34;.format(type(explorer_client)))
        elif self._network_type is None:
            # fetch network type from the explorer client
            resp = self._explorer_client.get(&#34;/explorer/constants&#34;)
            resp = json_loads(resp)
            self._network_type = NetworkType.from_str(resp.get(&#34;chaininfo&#34;, {}).get(&#34;NetworkName&#34;, &#34;standard&#34;))

        # create subclients
        self._threebot = TFChainThreeBotClient(self)
        self._minter = TFChainMinterClient(self)
        self._erc20 = TFChainERC20Client(self)

    @property
    def network(self):
        return self._network_type

    @property
    def threebot(self):
        &#34;&#34;&#34;
        ThreeBot Client API.
        &#34;&#34;&#34;
        return self._threebot

    @property
    def minter(self):
        &#34;&#34;&#34;
        Minter Client API.
        &#34;&#34;&#34;
        return self._minter

    @property
    def erc20(self):
        &#34;&#34;&#34;
        ERC20 Client API.
        &#34;&#34;&#34;
        return self._erc20

    @property
    def explorer_addresses(self):
        &#34;&#34;&#34;
        Addresses of the explorers to use
        &#34;&#34;&#34;
        return self._explorer_client.addresses

    @property
    def minimum_miner_fee(self):
        return self._network_type.minimum_miner_fee()

    def blockchain_info_get(self):
        &#34;&#34;&#34;
        Get the current blockchain info, using the last known block, as reported by an explorer.
        &#34;&#34;&#34;
        resp = self.explorer_get(endpoint=&#34;/explorer&#34;)
        resp = json_loads(resp)
        blockid = Hash.from_json(obj=resp[&#39;blockid&#39;])
        last_block = self.block_get(blockid)
        return ExplorerBlockchainInfo(last_block=last_block)

    def block_get(self, value):
        &#34;&#34;&#34;
        Get a block from an available explorer Node.
        
        @param value: the identifier or height that points to the desired block
        &#34;&#34;&#34;
        endpoint = &#34;/explorer/?&#34;
        resp = {}
        try:
            # get the explorer block
            if isinstance(value, int):
                endpoint = &#34;/explorer/blocks/{}&#34;.format(int(value))
                resp = self.explorer_get(endpoint=endpoint)
                resp = json_loads(resp)
                resp = resp[&#39;block&#39;]
            else:
                blockid = self._normalize_id(value)
                endpoint = &#34;/explorer/hashes/&#34;+blockid
                resp = self.explorer_get(endpoint=endpoint)
                resp = json_loads(resp)
                if resp[&#39;hashtype&#39;] != &#39;blockid&#39;:
                    raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;blockid&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
                resp = resp[&#39;block&#39;]
                if resp[&#39;blockid&#39;] != blockid:
                    raise tfchain.errors.ExplorerInvalidResponse(&#34;expected block ID &#39;{}&#39; not &#39;{}&#39;&#34;.format(blockid, resp[&#39;blockid&#39;]), endpoint, resp)
            # parse the transactions
            transactions = []
            for etxn in resp[&#39;transactions&#39;]:
                # parse the explorer transaction
                transaction = self._transaction_from_explorer_transaction(etxn, endpoint=endpoint, resp=resp)
                # append the transaction to the list of transactions
                transactions.append(transaction)
            rawblock = resp[&#39;rawblock&#39;]
            # parse the parent id
            parentid = Hash.from_json(obj=rawblock[&#39;parentid&#39;])
            # parse the miner payouts
            miner_payouts = []
            minerpayoutids = resp.get(&#39;minerpayoutids&#39;, None) or []
            eminerpayouts = rawblock.get(&#39;minerpayouts&#39;, None) or []
            if len(eminerpayouts) != len(minerpayoutids):
                raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of miner payouts and payout ids are not matching: {} != {}&#34;.format(len(eminerpayouts), len(minerpayoutids)), endpoint, resp)
            for idx, mp in enumerate(eminerpayouts):
                id = Hash.from_json(minerpayoutids[idx])
                value = Currency.from_json(mp[&#39;value&#39;])
                unlockhash = UnlockHash.from_json(mp[&#39;unlockhash&#39;])
                miner_payouts.append(ExplorerMinerPayout(id=id, value=value, unlockhash=unlockhash))
            # get the timestamp and height
            height = int(resp[&#39;height&#39;])
            timestamp = int(rawblock[&#39;timestamp&#39;])
            # get the block&#39;s identifier
            blockid = Hash.from_json(resp[&#39;blockid&#39;])
            # return the block, as reported by the explorer
            return ExplorerBlock(
                id=blockid, parentid=parentid,
                height=height, timestamp=timestamp,
                transactions=transactions, miner_payouts=miner_payouts)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def transaction_get(self, txid):
        &#34;&#34;&#34;
        Get a transaction from an available explorer Node.

        @param txid: the identifier (bytes, bytearray, hash or string) that points to the desired transaction
        &#34;&#34;&#34;
        txid = self._normalize_id(txid)
        endpoint = &#34;/explorer/hashes/&#34;+txid
        resp = self.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            if resp[&#39;hashtype&#39;] != &#39;transactionid&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;transactionid&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            resp = resp[&#39;transaction&#39;]
            if resp[&#39;id&#39;] != txid:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected transaction ID &#39;{}&#39; not &#39;{}&#39;&#34;.format(txid, resp[&#39;id&#39;]), endpoint, resp)
            return self._transaction_from_explorer_transaction(resp, endpoint=endpoint, resp=resp)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit a transaction to an available explorer Node.

        @param transaction: the transaction to push to the client transaction pool
        &#34;&#34;&#34;
        if isinstance(transaction, TransactionBaseClass):
            transaction = transaction.json()
        endpoint = &#34;/transactionpool/transactions&#34;
        resp = self.explorer_post(endpoint=endpoint, data=transaction)
        resp = json_loads(resp)
        try:
            return str(Hash(value=resp[&#39;transactionid&#39;]))
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def unlockhash_get(self, target):
        &#34;&#34;&#34;
        Get all transactions linked to the given unlockhash (target),
        as well as other information such as the multisig addresses linked to the given unlockhash (target).

        target can be any of:
            - None: unlockhash of the Free-For-All wallet will be used
            - str (or unlockhash/bytes/bytearray): target is assumed to be the unlockhash of a personal wallet
            - list: target is assumed to be the addresses of a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): target is a sigcount-of-addresscount MultiSig wallet

        @param target: the target wallet to look up transactions for in the explorer, see above for more info
        &#34;&#34;&#34;
        unlockhash = str(ConditionTypes.from_recipient(target).unlockhash)
        endpoint = &#34;/explorer/hashes/&#34;+unlockhash
        resp = self.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            if resp[&#39;hashtype&#39;] != &#39;unlockhash&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;unlockhash&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            # parse the transactions
            transactions = []
            for etxn in resp[&#39;transactions&#39;]:
                # parse the explorer transaction
                transaction = self._transaction_from_explorer_transaction(etxn, endpoint=endpoint, resp=resp)
                # append the transaction to the list of transactions
                transactions.append(transaction)
            # collect all multisig addresses
            multisig_addresses = [UnlockHash.from_json(obj=uh) for uh in resp.get(&#39;multisigaddresses&#39;, None) or []]
            for addr in multisig_addresses:
                if addr.type != UnlockHashType.MULTI_SIG:
                    raise tfchain.errors.ExplorerInvalidResponse(&#34;invalid unlock hash type {} for MultiSignature Address (expected: 3)&#34;.format(addr.type), endpoint, resp)
            erc20_info = None
            if &#39;erc20info&#39; in resp:
                info = resp[&#39;erc20info&#39;]
                erc20_info = ERC20AddressInfo(
                    address_tft=UnlockHash.from_json(info[&#39;tftaddress&#39;]),
                    address_erc20=ERC20Address.from_json(info[&#39;erc20address&#39;]),
                    confirmations=int(info[&#39;confirmations&#39;]),
                )

            # sort the transactions by height
            transactions.sort(key=(lambda txn: sys.maxsize if txn.height &lt; 0 else txn.height), reverse=True)

            # return explorer data for the unlockhash
            return ExplorerUnlockhashResult(
                unlockhash=UnlockHash.from_json(unlockhash),
                transactions=transactions,
                multisig_addresses=multisig_addresses,
                erc20_info=erc20_info,
                client=self)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def coin_output_get(self, id):
        &#34;&#34;&#34;
        Get a coin output from an available explorer Node.

        Returns (output, creation_txn, spend_txn).

        @param id: the identifier (bytes, bytearray, hash or string) that points to the desired coin output
        &#34;&#34;&#34;
        return self._output_get(id, expected_hash_type=&#39;coinoutputid&#39;)

    def blockstake_output_get(self, id):
        &#34;&#34;&#34;
        Get a blockstake output from an available explorer Node.

        Returns (output, creation_txn, spend_txn).

        @param id: the identifier (bytes, bytearray, hash or string) that points to the desired blockstake output
        &#34;&#34;&#34;
        return self._output_get(id, expected_hash_type=&#39;blockstakeoutputid&#39;)

    def _output_get(self, id, expected_hash_type):
        &#34;&#34;&#34;
        Get an output from an available explorer Node.

        Returns (output, creation_txn, spend_txn).

        @param id: the identifier (bytes, bytearray, hash or string) that points to the desired output
        @param expected_hash_type: one of (&#39;coinoutputid&#39;, &#39;blockstakeoutputid&#39;)
        &#34;&#34;&#34;
        if expected_hash_type not in (&#39;coinoutputid&#39;, &#39;blockstakeoutputid&#39;):
            raise ValueError(&#34;expected hash type should be one of (&#39;coinoutputid&#39;, &#39;blockstakeoutputid&#39;), not {}&#34;.format(expected_hash_type))
        id = self._normalize_id(id)
        endpoint = &#34;/explorer/hashes/&#34;+id
        resp = self.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            hash_type = resp[&#39;hashtype&#39;]
            if hash_type != expected_hash_type:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;{}&#39;, not &#39;{}&#39;&#34;.format(expected_hash_type, hash_type), endpoint, resp)
            tresp = resp[&#39;transactions&#39;]
            lresp = len(tresp)
            if lresp not in (1, 2):
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected one or two transactions to be returned, not {}&#34;.format(lresp), endpoint, resp)
            # parse the transaction(s)
            creation_txn = tresp[0]
            spend_txn = None
            if lresp == 2:
                if tresp[1][&#39;height&#39;] &gt; creation_txn[&#39;height&#39;]:
                    spend_txn = tresp[1]
                else:
                    spend_txn = creation_txn
                    creation_txn = tresp[1]
            creation_txn = self._transaction_from_explorer_transaction(creation_txn, endpoint=endpoint, resp=resp)
            if spend_txn is not None:
                spend_txn = self._transaction_from_explorer_transaction(spend_txn, endpoint=endpoint, resp=resp)
            # collect the output
            output = None
            for out in (creation_txn.coin_outputs if hash_type == &#39;coinoutputid&#39; else creation_txn.blockstake_outputs):
                if str(out.id) == id:
                    output = out
                    break
            if output is None:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected output {} to be part of creation Tx, but it wasn&#39;t&#34;.format(id), endpoint, resp)
            # return the output and related transaction(s)
            return (output, creation_txn, spend_txn)
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc

    def _transaction_from_explorer_transaction(self, etxn, endpoint=&#34;/?&#34;, resp=None): # keyword parameters for error handling purposes only
        if resp is None:
            resp = {}
        # parse the transactions
        transaction = transactions.from_json(obj=etxn[&#39;rawtransaction&#39;], id=etxn[&#39;id&#39;])
        # add the parent (coin) outputs
        coininputoutputs = etxn.get(&#39;coininputoutputs&#39;, None) or []
        if len(transaction.coin_inputs) != len(coininputoutputs):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of coin inputs and parent outputs are not matching: {} != {}&#34;.format(len(transaction.coin_inputs), len(coininputoutputs)), endpoint, resp)
        for (idx, co) in enumerate(coininputoutputs):
            co = CoinOutput.from_json(obj=co)
            co.id = transaction.coin_inputs[idx].parentid
            transaction.coin_inputs[idx].parent_output = co
        # add the coin output ids
        coinoutputids = etxn.get(&#39;coinoutputids&#39;, None) or []
        if len(transaction.coin_outputs) != len(coinoutputids):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of coin outputs and output identifiers are not matching: {} != {}&#34;.format(len(transaction.coin_outputs), len(coinoutputids)), endpoint, resp)
        for (idx, id) in enumerate(coinoutputids):
            transaction.coin_outputs[idx].id = Hash.from_json(obj=id)
        # add the parent (blockstake) outputs
        blockstakeinputoutputs = etxn.get(&#39;blockstakeinputoutputs&#39;, None) or []
        if len(transaction.blockstake_inputs) != len(blockstakeinputoutputs):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of blockstake inputs and parent outputs are not matching: {} != {}&#34;.format(len(transaction.blockstake_inputs), len(blockstakeinputoutputs)), endpoint, resp)
        for (idx, bso) in enumerate(blockstakeinputoutputs):
            bso = BlockstakeOutput.from_json(obj=bso)
            bso.id = transaction.blockstake_inputs[idx].parentid
            transaction.blockstake_inputs[idx].parent_output = bso
        # add the blockstake output ids
        blockstakeoutputids = etxn.get(&#39;blockstakeoutputids&#39;, None) or []
        if len(transaction.blockstake_outputs) != len(blockstakeoutputids):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of blokstake outputs and output identifiers are not matching: {} != {}&#34;.format(len(transaction.blockstake_inputs), len(blockstakeoutputids)), endpoint, resp)
        for (idx, id) in enumerate(blockstakeoutputids):
            transaction.blockstake_outputs[idx].id = Hash.from_json(obj=id)
        # set the unconfirmed state
        transaction.unconfirmed = etxn.get(&#39;unconfirmed&#39;, False)
        # set the height of the transaction only if confirmed
        if not transaction.unconfirmed:
            transaction.height = int(etxn.get(&#39;height&#39;))
        # return the transaction
        return transaction

    def explorer_get(self, endpoint):
        &#34;&#34;&#34;
        Utility method that gets the data on the given endpoint,
        but in a method so it can be overriden, internally, for Testing purposes.
        &#34;&#34;&#34;
        return self._explorer_client.get(endpoint)

    def explorer_post(self, endpoint, data):
        &#34;&#34;&#34;
        Utility method that sets the data on the given endpoint,
        but in a method so it can be overriden, internally, for Testing purposes.
        &#34;&#34;&#34;
        return self._explorer_client.post(endpoint, data)

    def _normalize_id(self, id):
        return str(Hash(value=id))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.TFChainClient.erc20"><code class="name">var <span class="ident">erc20</span></code></dt>
<dd>
<section class="desc"><p>ERC20 Client API.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def erc20(self):
    &#34;&#34;&#34;
    ERC20 Client API.
    &#34;&#34;&#34;
    return self._erc20</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.explorer_addresses"><code class="name">var <span class="ident">explorer_addresses</span></code></dt>
<dd>
<section class="desc"><p>Addresses of the explorers to use</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def explorer_addresses(self):
    &#34;&#34;&#34;
    Addresses of the explorers to use
    &#34;&#34;&#34;
    return self._explorer_client.addresses</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.minimum_miner_fee"><code class="name">var <span class="ident">minimum_miner_fee</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def minimum_miner_fee(self):
    return self._network_type.minimum_miner_fee()</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.minter"><code class="name">var <span class="ident">minter</span></code></dt>
<dd>
<section class="desc"><p>Minter Client API.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def minter(self):
    &#34;&#34;&#34;
    Minter Client API.
    &#34;&#34;&#34;
    return self._minter</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.network"><code class="name">var <span class="ident">network</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def network(self):
    return self._network_type</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.threebot"><code class="name">var <span class="ident">threebot</span></code></dt>
<dd>
<section class="desc"><p>ThreeBot Client API.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def threebot(self):
    &#34;&#34;&#34;
    ThreeBot Client API.
    &#34;&#34;&#34;
    return self._threebot</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainClient.TFChainClient.block_get"><code class="name flex">
<span>def <span class="ident">block_get</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a block from an available explorer Node.</p>
<p>@param value: the identifier or height that points to the desired block</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def block_get(self, value):
    &#34;&#34;&#34;
    Get a block from an available explorer Node.
    
    @param value: the identifier or height that points to the desired block
    &#34;&#34;&#34;
    endpoint = &#34;/explorer/?&#34;
    resp = {}
    try:
        # get the explorer block
        if isinstance(value, int):
            endpoint = &#34;/explorer/blocks/{}&#34;.format(int(value))
            resp = self.explorer_get(endpoint=endpoint)
            resp = json_loads(resp)
            resp = resp[&#39;block&#39;]
        else:
            blockid = self._normalize_id(value)
            endpoint = &#34;/explorer/hashes/&#34;+blockid
            resp = self.explorer_get(endpoint=endpoint)
            resp = json_loads(resp)
            if resp[&#39;hashtype&#39;] != &#39;blockid&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;blockid&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            resp = resp[&#39;block&#39;]
            if resp[&#39;blockid&#39;] != blockid:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected block ID &#39;{}&#39; not &#39;{}&#39;&#34;.format(blockid, resp[&#39;blockid&#39;]), endpoint, resp)
        # parse the transactions
        transactions = []
        for etxn in resp[&#39;transactions&#39;]:
            # parse the explorer transaction
            transaction = self._transaction_from_explorer_transaction(etxn, endpoint=endpoint, resp=resp)
            # append the transaction to the list of transactions
            transactions.append(transaction)
        rawblock = resp[&#39;rawblock&#39;]
        # parse the parent id
        parentid = Hash.from_json(obj=rawblock[&#39;parentid&#39;])
        # parse the miner payouts
        miner_payouts = []
        minerpayoutids = resp.get(&#39;minerpayoutids&#39;, None) or []
        eminerpayouts = rawblock.get(&#39;minerpayouts&#39;, None) or []
        if len(eminerpayouts) != len(minerpayoutids):
            raise tfchain.errors.ExplorerInvalidResponse(&#34;amount of miner payouts and payout ids are not matching: {} != {}&#34;.format(len(eminerpayouts), len(minerpayoutids)), endpoint, resp)
        for idx, mp in enumerate(eminerpayouts):
            id = Hash.from_json(minerpayoutids[idx])
            value = Currency.from_json(mp[&#39;value&#39;])
            unlockhash = UnlockHash.from_json(mp[&#39;unlockhash&#39;])
            miner_payouts.append(ExplorerMinerPayout(id=id, value=value, unlockhash=unlockhash))
        # get the timestamp and height
        height = int(resp[&#39;height&#39;])
        timestamp = int(rawblock[&#39;timestamp&#39;])
        # get the block&#39;s identifier
        blockid = Hash.from_json(resp[&#39;blockid&#39;])
        # return the block, as reported by the explorer
        return ExplorerBlock(
            id=blockid, parentid=parentid,
            height=height, timestamp=timestamp,
            transactions=transactions, miner_payouts=miner_payouts)
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.blockchain_info_get"><code class="name flex">
<span>def <span class="ident">blockchain_info_get</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the current blockchain info, using the last known block, as reported by an explorer.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def blockchain_info_get(self):
    &#34;&#34;&#34;
    Get the current blockchain info, using the last known block, as reported by an explorer.
    &#34;&#34;&#34;
    resp = self.explorer_get(endpoint=&#34;/explorer&#34;)
    resp = json_loads(resp)
    blockid = Hash.from_json(obj=resp[&#39;blockid&#39;])
    last_block = self.block_get(blockid)
    return ExplorerBlockchainInfo(last_block=last_block)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.blockstake_output_get"><code class="name flex">
<span>def <span class="ident">blockstake_output_get</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a blockstake output from an available explorer Node.</p>
<p>Returns (output, creation_txn, spend_txn).</p>
<p>@param id: the identifier (bytes, bytearray, hash or string) that points to the desired blockstake output</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def blockstake_output_get(self, id):
    &#34;&#34;&#34;
    Get a blockstake output from an available explorer Node.

    Returns (output, creation_txn, spend_txn).

    @param id: the identifier (bytes, bytearray, hash or string) that points to the desired blockstake output
    &#34;&#34;&#34;
    return self._output_get(id, expected_hash_type=&#39;blockstakeoutputid&#39;)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.coin_output_get"><code class="name flex">
<span>def <span class="ident">coin_output_get</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a coin output from an available explorer Node.</p>
<p>Returns (output, creation_txn, spend_txn).</p>
<p>@param id: the identifier (bytes, bytearray, hash or string) that points to the desired coin output</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def coin_output_get(self, id):
    &#34;&#34;&#34;
    Get a coin output from an available explorer Node.

    Returns (output, creation_txn, spend_txn).

    @param id: the identifier (bytes, bytearray, hash or string) that points to the desired coin output
    &#34;&#34;&#34;
    return self._output_get(id, expected_hash_type=&#39;coinoutputid&#39;)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.explorer_get"><code class="name flex">
<span>def <span class="ident">explorer_get</span></span>(<span>self, endpoint)</span>
</code></dt>
<dd>
<section class="desc"><p>Utility method that gets the data on the given endpoint,
but in a method so it can be overriden, internally, for Testing purposes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def explorer_get(self, endpoint):
    &#34;&#34;&#34;
    Utility method that gets the data on the given endpoint,
    but in a method so it can be overriden, internally, for Testing purposes.
    &#34;&#34;&#34;
    return self._explorer_client.get(endpoint)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.explorer_post"><code class="name flex">
<span>def <span class="ident">explorer_post</span></span>(<span>self, endpoint, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Utility method that sets the data on the given endpoint,
but in a method so it can be overriden, internally, for Testing purposes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def explorer_post(self, endpoint, data):
    &#34;&#34;&#34;
    Utility method that sets the data on the given endpoint,
    but in a method so it can be overriden, internally, for Testing purposes.
    &#34;&#34;&#34;
    return self._explorer_client.post(endpoint, data)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.transaction_get"><code class="name flex">
<span>def <span class="ident">transaction_get</span></span>(<span>self, txid)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a transaction from an available explorer Node.</p>
<p>@param txid: the identifier (bytes, bytearray, hash or string) that points to the desired transaction</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def transaction_get(self, txid):
    &#34;&#34;&#34;
    Get a transaction from an available explorer Node.

    @param txid: the identifier (bytes, bytearray, hash or string) that points to the desired transaction
    &#34;&#34;&#34;
    txid = self._normalize_id(txid)
    endpoint = &#34;/explorer/hashes/&#34;+txid
    resp = self.explorer_get(endpoint=endpoint)
    resp = json_loads(resp)
    try:
        if resp[&#39;hashtype&#39;] != &#39;transactionid&#39;:
            raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;transactionid&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
        resp = resp[&#39;transaction&#39;]
        if resp[&#39;id&#39;] != txid:
            raise tfchain.errors.ExplorerInvalidResponse(&#34;expected transaction ID &#39;{}&#39; not &#39;{}&#39;&#34;.format(txid, resp[&#39;id&#39;]), endpoint, resp)
        return self._transaction_from_explorer_transaction(resp, endpoint=endpoint, resp=resp)
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.transaction_put"><code class="name flex">
<span>def <span class="ident">transaction_put</span></span>(<span>self, transaction)</span>
</code></dt>
<dd>
<section class="desc"><p>Submit a transaction to an available explorer Node.</p>
<p>@param transaction: the transaction to push to the client transaction pool</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def transaction_put(self, transaction):
    &#34;&#34;&#34;
    Submit a transaction to an available explorer Node.

    @param transaction: the transaction to push to the client transaction pool
    &#34;&#34;&#34;
    if isinstance(transaction, TransactionBaseClass):
        transaction = transaction.json()
    endpoint = &#34;/transactionpool/transactions&#34;
    resp = self.explorer_post(endpoint=endpoint, data=transaction)
    resp = json_loads(resp)
    try:
        return str(Hash(value=resp[&#39;transactionid&#39;]))
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.TFChainClient.unlockhash_get"><code class="name flex">
<span>def <span class="ident">unlockhash_get</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all transactions linked to the given unlockhash (target),
as well as other information such as the multisig addresses linked to the given unlockhash (target).</p>
<p>target can be any of:
- None: unlockhash of the Free-For-All wallet will be used
- str (or unlockhash/bytes/bytearray): target is assumed to be the unlockhash of a personal wallet
- list: target is assumed to be the addresses of a MultiSig wallet where all owners (specified as a list of addresses) have to sign
- tuple (addresses, sigcount): target is a sigcount-of-addresscount MultiSig wallet</p>
<p>@param target: the target wallet to look up transactions for in the explorer, see above for more info</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def unlockhash_get(self, target):
    &#34;&#34;&#34;
    Get all transactions linked to the given unlockhash (target),
    as well as other information such as the multisig addresses linked to the given unlockhash (target).

    target can be any of:
        - None: unlockhash of the Free-For-All wallet will be used
        - str (or unlockhash/bytes/bytearray): target is assumed to be the unlockhash of a personal wallet
        - list: target is assumed to be the addresses of a MultiSig wallet where all owners (specified as a list of addresses) have to sign
        - tuple (addresses, sigcount): target is a sigcount-of-addresscount MultiSig wallet

    @param target: the target wallet to look up transactions for in the explorer, see above for more info
    &#34;&#34;&#34;
    unlockhash = str(ConditionTypes.from_recipient(target).unlockhash)
    endpoint = &#34;/explorer/hashes/&#34;+unlockhash
    resp = self.explorer_get(endpoint=endpoint)
    resp = json_loads(resp)
    try:
        if resp[&#39;hashtype&#39;] != &#39;unlockhash&#39;:
            raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;unlockhash&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
        # parse the transactions
        transactions = []
        for etxn in resp[&#39;transactions&#39;]:
            # parse the explorer transaction
            transaction = self._transaction_from_explorer_transaction(etxn, endpoint=endpoint, resp=resp)
            # append the transaction to the list of transactions
            transactions.append(transaction)
        # collect all multisig addresses
        multisig_addresses = [UnlockHash.from_json(obj=uh) for uh in resp.get(&#39;multisigaddresses&#39;, None) or []]
        for addr in multisig_addresses:
            if addr.type != UnlockHashType.MULTI_SIG:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;invalid unlock hash type {} for MultiSignature Address (expected: 3)&#34;.format(addr.type), endpoint, resp)
        erc20_info = None
        if &#39;erc20info&#39; in resp:
            info = resp[&#39;erc20info&#39;]
            erc20_info = ERC20AddressInfo(
                address_tft=UnlockHash.from_json(info[&#39;tftaddress&#39;]),
                address_erc20=ERC20Address.from_json(info[&#39;erc20address&#39;]),
                confirmations=int(info[&#39;confirmations&#39;]),
            )

        # sort the transactions by height
        transactions.sort(key=(lambda txn: sys.maxsize if txn.height &lt; 0 else txn.height), reverse=True)

        # return explorer data for the unlockhash
        return ExplorerUnlockhashResult(
            unlockhash=UnlockHash.from_json(unlockhash),
            transactions=transactions,
            multisig_addresses=multisig_addresses,
            erc20_info=erc20_info,
            client=self)
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.TFChainERC20Client"><code class="flex name class">
<span>class <span class="ident">TFChainERC20Client</span></span>
<span>(</span><span>client)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainERC20Client contains all ERC20 Logic</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainERC20Client():
    &#34;&#34;&#34;
    TFChainERC20Client contains all ERC20 Logic
    &#34;&#34;&#34;

    def __init__(self, client):
        if not isinstance(client, TFChainClient):
            raise TypeError(&#34;client is expected to be a TFChainClient&#34;)
        self._client = client

    def address_get(self, unlockhash):
        &#34;&#34;&#34;
        Get the ERC20 (withdraw) address for the given unlock hash,
        ExplorerNoContent error is raised when no address could be found for the given unlock hash.

        Only type 01 addresses can be looked up for this method (personal wallet addresses),
        as there can be no MultiSignature (wallet) address registered as an ERC20 withdraw address.

        @param unlockhash: the str or wallet address to be looked up
        &#34;&#34;&#34;
        if isinstance(unlockhash, str):
            unlockhash = UnlockHash.from_json(unlockhash)
        elif not isinstance(unlockhash, UnlockHash):
            raise TypeError(&#34;{} is not a valid type and cannot be used as unlock hash&#34;.format(type(unlockhash)))
        if unlockhash.type != UnlockHashType.PUBLIC_KEY:
            raise TypeError(&#34;only person wallet addresses cannot be registered as withdrawel addresses: {} is an invalid unlock hash type&#34;.format(unlockhash.type))
    
        endpoint = &#34;/explorer/hashes/&#34;+str(unlockhash)
        resp = self._client.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)
        try:
            if resp[&#39;hashtype&#39;] != &#39;unlockhash&#39;:
                raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;unlockhash&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
            # parse the ERC20 Info
            if not &#39;erc20info&#39; in resp:
                raise tfchain.errors.ExplorerNoContent(&#34;{} could be found but is not registered as an ERC20 withdraw address&#34;.format(str(unlockhash)), endpoint=endpoint)
            info = resp[&#39;erc20info&#39;]
            return ERC20AddressInfo(
                address_tft=UnlockHash.from_json(info[&#39;tftaddress&#39;]),
                address_erc20=ERC20Address.from_json(info[&#39;erc20address&#39;]),
                confirmations=int(info[&#39;confirmations&#39;]),
            )
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainClient.TFChainERC20Client.address_get"><code class="name flex">
<span>def <span class="ident">address_get</span></span>(<span>self, unlockhash)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the ERC20 (withdraw) address for the given unlock hash,
ExplorerNoContent error is raised when no address could be found for the given unlock hash.</p>
<p>Only type 01 addresses can be looked up for this method (personal wallet addresses),
as there can be no MultiSignature (wallet) address registered as an ERC20 withdraw address.</p>
<p>@param unlockhash: the str or wallet address to be looked up</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def address_get(self, unlockhash):
    &#34;&#34;&#34;
    Get the ERC20 (withdraw) address for the given unlock hash,
    ExplorerNoContent error is raised when no address could be found for the given unlock hash.

    Only type 01 addresses can be looked up for this method (personal wallet addresses),
    as there can be no MultiSignature (wallet) address registered as an ERC20 withdraw address.

    @param unlockhash: the str or wallet address to be looked up
    &#34;&#34;&#34;
    if isinstance(unlockhash, str):
        unlockhash = UnlockHash.from_json(unlockhash)
    elif not isinstance(unlockhash, UnlockHash):
        raise TypeError(&#34;{} is not a valid type and cannot be used as unlock hash&#34;.format(type(unlockhash)))
    if unlockhash.type != UnlockHashType.PUBLIC_KEY:
        raise TypeError(&#34;only person wallet addresses cannot be registered as withdrawel addresses: {} is an invalid unlock hash type&#34;.format(unlockhash.type))

    endpoint = &#34;/explorer/hashes/&#34;+str(unlockhash)
    resp = self._client.explorer_get(endpoint=endpoint)
    resp = json_loads(resp)
    try:
        if resp[&#39;hashtype&#39;] != &#39;unlockhash&#39;:
            raise tfchain.errors.ExplorerInvalidResponse(&#34;expected hash type &#39;unlockhash&#39; not &#39;{}&#39;&#34;.format(resp[&#39;hashtype&#39;]), endpoint, resp)
        # parse the ERC20 Info
        if not &#39;erc20info&#39; in resp:
            raise tfchain.errors.ExplorerNoContent(&#34;{} could be found but is not registered as an ERC20 withdraw address&#34;.format(str(unlockhash)), endpoint=endpoint)
        info = resp[&#39;erc20info&#39;]
        return ERC20AddressInfo(
            address_tft=UnlockHash.from_json(info[&#39;tftaddress&#39;]),
            address_erc20=ERC20Address.from_json(info[&#39;erc20address&#39;]),
            confirmations=int(info[&#39;confirmations&#39;]),
        )
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.TFChainMinterClient"><code class="flex name class">
<span>class <span class="ident">TFChainMinterClient</span></span>
<span>(</span><span>client)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainMinterClient contains all Coin Minting logic.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainMinterClient():
    &#34;&#34;&#34;
    TFChainMinterClient contains all Coin Minting logic.
    &#34;&#34;&#34;

    def __init__(self, client):
        if not isinstance(client, TFChainClient):
            raise TypeError(&#34;client is expected to be a TFChainClient&#34;)
        self._client = client

    def condition_get(self, height=None):
        &#34;&#34;&#34;
        Get the latest (coin) mint condition or the (coin) mint condition at the specified block height.

        @param height: if defined the block height at which to look up the (coin) mint condition (if none latest block will be used)
        &#34;&#34;&#34;
        # define the endpoint
        endpoint = &#34;/explorer/mintcondition&#34;
        if height is not None:
            if not isinstance(height, (int, str)):
                raise TypeError(&#34;invalid block height given&#34;)
            height = int(height)
            endpoint += &#34;/%d&#34;%(height)

        # get the mint condition
        resp = self._client.explorer_get(endpoint=endpoint)
        resp = json_loads(resp)

        try:
            # return the decoded mint condition
            return ConditionTypes.from_json(obj=resp[&#39;mintcondition&#39;])
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainClient.TFChainMinterClient.condition_get"><code class="name flex">
<span>def <span class="ident">condition_get</span></span>(<span>self, height=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the latest (coin) mint condition or the (coin) mint condition at the specified block height.</p>
<p>@param height: if defined the block height at which to look up the (coin) mint condition (if none latest block will be used)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def condition_get(self, height=None):
    &#34;&#34;&#34;
    Get the latest (coin) mint condition or the (coin) mint condition at the specified block height.

    @param height: if defined the block height at which to look up the (coin) mint condition (if none latest block will be used)
    &#34;&#34;&#34;
    # define the endpoint
    endpoint = &#34;/explorer/mintcondition&#34;
    if height is not None:
        if not isinstance(height, (int, str)):
            raise TypeError(&#34;invalid block height given&#34;)
        height = int(height)
        endpoint += &#34;/%d&#34;%(height)

    # get the mint condition
    resp = self._client.explorer_get(endpoint=endpoint)
    resp = json_loads(resp)

    try:
        # return the decoded mint condition
        return ConditionTypes.from_json(obj=resp[&#39;mintcondition&#39;])
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.TFChainThreeBotClient"><code class="flex name class">
<span>class <span class="ident">TFChainThreeBotClient</span></span>
<span>(</span><span>client)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainThreeBotClient contains all ThreeBot Logic</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainThreeBotClient():
    &#34;&#34;&#34;
    TFChainThreeBotClient contains all ThreeBot Logic
    &#34;&#34;&#34;

    def __init__(self, client):
        if not isinstance(client, TFChainClient):
            raise TypeError(&#34;client is expected to be a TFChainClient&#34;)
        self._client = client

    def record_get(self, identifier):
        &#34;&#34;&#34;
        Get a 3Bot record registered on a TFchain network
        @param identifier: unique 3Bot id, public key or (bot) name to search a 3Bot record for
        &#34;&#34;&#34;
        endpoint = &#34;/explorer/3bot&#34;
        if isinstance(identifier, int):
            identifier = str(identifier)
        elif isinstance(identifier, BotName):
            endpoint = &#34;/explorer/whois/3bot&#34;
            identifier = str(identifier)
        elif isinstance(identifier, PublicKey):
            identifier = str(identifier)
        elif isinstance(identifier, str):
            if BotName.REGEXP.match(identifier) is not None:
                endpoint = &#34;/explorer/whois/3bot&#34;
            else:
                try:
                    PublicKey.from_json(identifier)
                except ValueError as exc:
                    raise ValueError(&#34;a 3Bot identifier in string format has to be either a valid BotName or PublicKey, &#39;{}&#39; is neither&#34;.format(identifier)) from exc
        else:
            raise TypeError(&#34;identifier of type {} is invalid&#34;.format(type(identifier)))
        # identifier is a str at this point
        # and endpoint is configured

        # fetch the data
        endpoint += &#34;/{}&#34;.format(identifier)
        try:
            resp = self._client.explorer_get(endpoint=endpoint)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.ThreeBotNotFound(identifier) from exc
        resp = json_loads(resp)
        try:
            # return the fetched record as a named tuple, for easy semi-typed access
            record = resp[&#39;record&#39;]
            return ThreeBotRecord(
                identifier=int(record[&#39;id&#39;]),
                names=[BotName.from_json(name) for name in record.get(&#39;names&#39;, []) or []],
                addresses=[NetworkAddress.from_json(address) for address in record.get(&#39;addresses&#39;, []) or []],
                public_key=PublicKey.from_json(record[&#39;publickey&#39;]),
                expiration=int(record[&#39;expiration&#39;]),
            )
        except KeyError as exc:
            # return a KeyError as an invalid Explorer Response
            raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainClient.TFChainThreeBotClient.record_get"><code class="name flex">
<span>def <span class="ident">record_get</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a 3Bot record registered on a TFchain network
@param identifier: unique 3Bot id, public key or (bot) name to search a 3Bot record for</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def record_get(self, identifier):
    &#34;&#34;&#34;
    Get a 3Bot record registered on a TFchain network
    @param identifier: unique 3Bot id, public key or (bot) name to search a 3Bot record for
    &#34;&#34;&#34;
    endpoint = &#34;/explorer/3bot&#34;
    if isinstance(identifier, int):
        identifier = str(identifier)
    elif isinstance(identifier, BotName):
        endpoint = &#34;/explorer/whois/3bot&#34;
        identifier = str(identifier)
    elif isinstance(identifier, PublicKey):
        identifier = str(identifier)
    elif isinstance(identifier, str):
        if BotName.REGEXP.match(identifier) is not None:
            endpoint = &#34;/explorer/whois/3bot&#34;
        else:
            try:
                PublicKey.from_json(identifier)
            except ValueError as exc:
                raise ValueError(&#34;a 3Bot identifier in string format has to be either a valid BotName or PublicKey, &#39;{}&#39; is neither&#34;.format(identifier)) from exc
    else:
        raise TypeError(&#34;identifier of type {} is invalid&#34;.format(type(identifier)))
    # identifier is a str at this point
    # and endpoint is configured

    # fetch the data
    endpoint += &#34;/{}&#34;.format(identifier)
    try:
        resp = self._client.explorer_get(endpoint=endpoint)
    except tfchain.errors.ExplorerNoContent as exc:
        raise tfchain.errors.ThreeBotNotFound(identifier) from exc
    resp = json_loads(resp)
    try:
        # return the fetched record as a named tuple, for easy semi-typed access
        record = resp[&#39;record&#39;]
        return ThreeBotRecord(
            identifier=int(record[&#39;id&#39;]),
            names=[BotName.from_json(name) for name in record.get(&#39;names&#39;, []) or []],
            addresses=[NetworkAddress.from_json(address) for address in record.get(&#39;addresses&#39;, []) or []],
            public_key=PublicKey.from_json(record[&#39;publickey&#39;]),
            expiration=int(record[&#39;expiration&#39;]),
        )
    except KeyError as exc:
        # return a KeyError as an invalid Explorer Response
        raise tfchain.errors.ExplorerInvalidResponse(str(exc), endpoint, resp) from exc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainClient.ThreeBotRecord"><code class="flex name class">
<span>class <span class="ident">ThreeBotRecord</span></span>
<span>(</span><span>identifier, names, addresses, public_key, expiration)</span>
</code></dt>
<dd>
<section class="desc"><p>ThreeBotRecord is a named tuple,
used to represent a ThreeBot Record as fetched from an explorer,
as the result of a local function.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ThreeBotRecord():
    &#34;&#34;&#34;
    ThreeBotRecord is a named tuple,
    used to represent a ThreeBot Record as fetched from an explorer,
    as the result of a local function.
    &#34;&#34;&#34;
    def __init__(self, identifier, names, addresses, public_key, expiration):
        self._identifier = identifier
        self._names = names
        self._addresses = addresses
        self._public_key = public_key
        self._expiration = expiration

    @property
    def identifier(self):
        return self._identifier
    @property
    def names(self):
        return self._names
    @property
    def addresses(self):
        return self._addresses
    @property
    def public_key(self):
        return self._public_key
    @property
    def expiration(self):
        return self._expiration</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainClient.ThreeBotRecord.addresses"><code class="name">var <span class="ident">addresses</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def addresses(self):
    return self._addresses</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ThreeBotRecord.expiration"><code class="name">var <span class="ident">expiration</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def expiration(self):
    return self._expiration</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ThreeBotRecord.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def identifier(self):
    return self._identifier</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ThreeBotRecord.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def names(self):
    return self._names</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainClient.ThreeBotRecord.public_key"><code class="name">var <span class="ident">public_key</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def public_key(self):
    return self._public_key</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tfchain" href="index.html">tfchain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tfchain.TFChainClient.ERC20AddressInfo" href="#tfchain.TFChainClient.ERC20AddressInfo">ERC20AddressInfo</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.ERC20AddressInfo.address_erc20" href="#tfchain.TFChainClient.ERC20AddressInfo.address_erc20">address_erc20</a></code></li>
<li><code><a title="tfchain.TFChainClient.ERC20AddressInfo.address_tft" href="#tfchain.TFChainClient.ERC20AddressInfo.address_tft">address_tft</a></code></li>
<li><code><a title="tfchain.TFChainClient.ERC20AddressInfo.confirmations" href="#tfchain.TFChainClient.ERC20AddressInfo.confirmations">confirmations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.ExplorerBlock" href="#tfchain.TFChainClient.ExplorerBlock">ExplorerBlock</a></code></h4>
<ul class="two-column">
<li><code><a title="tfchain.TFChainClient.ExplorerBlock.height" href="#tfchain.TFChainClient.ExplorerBlock.height">height</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlock.id" href="#tfchain.TFChainClient.ExplorerBlock.id">id</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlock.miner_payouts" href="#tfchain.TFChainClient.ExplorerBlock.miner_payouts">miner_payouts</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlock.parentid" href="#tfchain.TFChainClient.ExplorerBlock.parentid">parentid</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlock.timestamp" href="#tfchain.TFChainClient.ExplorerBlock.timestamp">timestamp</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlock.transactions" href="#tfchain.TFChainClient.ExplorerBlock.transactions">transactions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.ExplorerBlockchainInfo" href="#tfchain.TFChainClient.ExplorerBlockchainInfo">ExplorerBlockchainInfo</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.ExplorerBlockchainInfo.blockid" href="#tfchain.TFChainClient.ExplorerBlockchainInfo.blockid">blockid</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlockchainInfo.height" href="#tfchain.TFChainClient.ExplorerBlockchainInfo.height">height</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlockchainInfo.last_block" href="#tfchain.TFChainClient.ExplorerBlockchainInfo.last_block">last_block</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerBlockchainInfo.timestamp" href="#tfchain.TFChainClient.ExplorerBlockchainInfo.timestamp">timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.ExplorerMinerPayout" href="#tfchain.TFChainClient.ExplorerMinerPayout">ExplorerMinerPayout</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.ExplorerMinerPayout.id" href="#tfchain.TFChainClient.ExplorerMinerPayout.id">id</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerMinerPayout.unlockhash" href="#tfchain.TFChainClient.ExplorerMinerPayout.unlockhash">unlockhash</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerMinerPayout.value" href="#tfchain.TFChainClient.ExplorerMinerPayout.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.ExplorerUnlockhashResult" href="#tfchain.TFChainClient.ExplorerUnlockhashResult">ExplorerUnlockhashResult</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.ExplorerUnlockhashResult.balance" href="#tfchain.TFChainClient.ExplorerUnlockhashResult.balance">balance</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerUnlockhashResult.erc20_info" href="#tfchain.TFChainClient.ExplorerUnlockhashResult.erc20_info">erc20_info</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerUnlockhashResult.multisig_addresses" href="#tfchain.TFChainClient.ExplorerUnlockhashResult.multisig_addresses">multisig_addresses</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerUnlockhashResult.transactions" href="#tfchain.TFChainClient.ExplorerUnlockhashResult.transactions">transactions</a></code></li>
<li><code><a title="tfchain.TFChainClient.ExplorerUnlockhashResult.unlockhash" href="#tfchain.TFChainClient.ExplorerUnlockhashResult.unlockhash">unlockhash</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.NetworkType" href="#tfchain.TFChainClient.NetworkType">NetworkType</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.NetworkType.DEVNET" href="#tfchain.TFChainClient.NetworkType.DEVNET">DEVNET</a></code></li>
<li><code><a title="tfchain.TFChainClient.NetworkType.STANDARD" href="#tfchain.TFChainClient.NetworkType.STANDARD">STANDARD</a></code></li>
<li><code><a title="tfchain.TFChainClient.NetworkType.TESTNET" href="#tfchain.TFChainClient.NetworkType.TESTNET">TESTNET</a></code></li>
<li><code><a title="tfchain.TFChainClient.NetworkType.default_explorer_addresses" href="#tfchain.TFChainClient.NetworkType.default_explorer_addresses">default_explorer_addresses</a></code></li>
<li><code><a title="tfchain.TFChainClient.NetworkType.from_str" href="#tfchain.TFChainClient.NetworkType.from_str">from_str</a></code></li>
<li><code><a title="tfchain.TFChainClient.NetworkType.minimum_miner_fee" href="#tfchain.TFChainClient.NetworkType.minimum_miner_fee">minimum_miner_fee</a></code></li>
<li><code><a title="tfchain.TFChainClient.NetworkType.value" href="#tfchain.TFChainClient.NetworkType.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.TFChainClient" href="#tfchain.TFChainClient.TFChainClient">TFChainClient</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.TFChainClient.block_get" href="#tfchain.TFChainClient.TFChainClient.block_get">block_get</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.blockchain_info_get" href="#tfchain.TFChainClient.TFChainClient.blockchain_info_get">blockchain_info_get</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.blockstake_output_get" href="#tfchain.TFChainClient.TFChainClient.blockstake_output_get">blockstake_output_get</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.coin_output_get" href="#tfchain.TFChainClient.TFChainClient.coin_output_get">coin_output_get</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.erc20" href="#tfchain.TFChainClient.TFChainClient.erc20">erc20</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.explorer_addresses" href="#tfchain.TFChainClient.TFChainClient.explorer_addresses">explorer_addresses</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.explorer_get" href="#tfchain.TFChainClient.TFChainClient.explorer_get">explorer_get</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.explorer_post" href="#tfchain.TFChainClient.TFChainClient.explorer_post">explorer_post</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.minimum_miner_fee" href="#tfchain.TFChainClient.TFChainClient.minimum_miner_fee">minimum_miner_fee</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.minter" href="#tfchain.TFChainClient.TFChainClient.minter">minter</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.network" href="#tfchain.TFChainClient.TFChainClient.network">network</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.threebot" href="#tfchain.TFChainClient.TFChainClient.threebot">threebot</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.transaction_get" href="#tfchain.TFChainClient.TFChainClient.transaction_get">transaction_get</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.transaction_put" href="#tfchain.TFChainClient.TFChainClient.transaction_put">transaction_put</a></code></li>
<li><code><a title="tfchain.TFChainClient.TFChainClient.unlockhash_get" href="#tfchain.TFChainClient.TFChainClient.unlockhash_get">unlockhash_get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.TFChainERC20Client" href="#tfchain.TFChainClient.TFChainERC20Client">TFChainERC20Client</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.TFChainERC20Client.address_get" href="#tfchain.TFChainClient.TFChainERC20Client.address_get">address_get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.TFChainMinterClient" href="#tfchain.TFChainClient.TFChainMinterClient">TFChainMinterClient</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.TFChainMinterClient.condition_get" href="#tfchain.TFChainClient.TFChainMinterClient.condition_get">condition_get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.TFChainThreeBotClient" href="#tfchain.TFChainClient.TFChainThreeBotClient">TFChainThreeBotClient</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.TFChainThreeBotClient.record_get" href="#tfchain.TFChainClient.TFChainThreeBotClient.record_get">record_get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainClient.ThreeBotRecord" href="#tfchain.TFChainClient.ThreeBotRecord">ThreeBotRecord</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainClient.ThreeBotRecord.addresses" href="#tfchain.TFChainClient.ThreeBotRecord.addresses">addresses</a></code></li>
<li><code><a title="tfchain.TFChainClient.ThreeBotRecord.expiration" href="#tfchain.TFChainClient.ThreeBotRecord.expiration">expiration</a></code></li>
<li><code><a title="tfchain.TFChainClient.ThreeBotRecord.identifier" href="#tfchain.TFChainClient.ThreeBotRecord.identifier">identifier</a></code></li>
<li><code><a title="tfchain.TFChainClient.ThreeBotRecord.names" href="#tfchain.TFChainClient.ThreeBotRecord.names">names</a></code></li>
<li><code><a title="tfchain.TFChainClient.ThreeBotRecord.public_key" href="#tfchain.TFChainClient.ThreeBotRecord.public_key">public_key</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>