<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>tfchain.TFChainWallet API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tfchain.TFChainWallet</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from functools import reduce

import sys
import hashlib
from ed25519 import SigningKey

import mnemonic

import tfchain
from tfchain.internal.jsutils import blake2, duration, epoch2HRDateTime
from tfchain.encoders import encoder_rivine_get, encoder_sia_get
from tfchain.types import transactions as tftransactions
from tfchain.types import ConditionTypes, FulfillmentTypes
from tfchain.types.PrimitiveTypes import Currency, Hash, BinaryData
from tfchain.types.CryptoTypes import PublicKey, UnlockHash, UnlockHashType, PublicKeySpecifier
from tfchain.types.IO import CoinOutput, CoinInput
from tfchain.types.ConditionTypes import ConditionNil, ConditionUnlockHash, ConditionLockTime
from tfchain.types.AtomicSwap import AtomicSwapContract
from tfchain.types.ERC20 import ERC20Address
from tfchain.types.transactions.Base import TransactionBaseClass
from tfchain.types.transactions.Minting import TransactionV128, TransactionV129

_DEFAULT_KEY_SCAN_COUNT = 3

_MAX_RIVINE_TRANSACTION_INPUTS = 99

class TFChainWallet:
    &#34;&#34;&#34;
    Tfchain Wallet object
    &#34;&#34;&#34;

    def __init__(self, seed=None, key_count=1, key_start_index=0, key_scan_count=-1, client=None):
        # create TFChainClient used as the portal to the outside world
        self._client = client
        if self._client is None:
            self._client = tfchain.TFChainClient.TFChainClient()
        elif not isinstance(self._client, tfchain.TFChainClient.TFChainClient):
            raise TypeError(&#34;client has to be None or of type TFChainClient, not be of type {}&#34;.format(type(self._client)))

        # stores all key pairs of this wallet in memory
        self._key_pairs = {}
        # the primary address is kept as a seperate property,
        # as we hint the user into using this primary address as much as possible,
        # to keep things simple
        self._primary_address = &#39;&#39;

        # when during scanning we find a used key,
        # it might happen that one or more keys prior the used keys are not used,
        # in this case we do want to increase the key_count,
        # but will keep the unused keys in a seperate bucket, so we
        # can use them first
        self._unused_key_pairs = []

        # add seed
        self._mnemonic_api = mnemonic.Mnemonic(&#34;english&#34;)
        self._seed = seed
        if self._seed is None:
            self._seed = self._mnemonic_api.to_entropy(self._mnemonic_api.generate(strength=256))
        elif isinstance(self._seed, str):
            self._seed = self._mnemonic_api.to_entropy(self._seed)
        elif not isinstance (self._seed, (bytearray, bytes)):
            raise TypeError(&#34;seed has to be a mnemonic or raw (bytes) seed, not be of type {}&#34;.format(type(self._seed)))

        # add key count and key_start_index
        self._key_count = max(1, key_count)
        self._key_next_index = max(0, key_start_index)

        # define key scan count
        self._key_scan_count = max(-1, key_scan_count)
        if self._key_scan_count == -1:
            self._key_scan_count = _DEFAULT_KEY_SCAN_COUNT

        # generate keys
        keys_to_generate = self._key_count
        self._key_count = 0
        # generate the primary address
        self._primary_address = str(self._key_pair_new().unlockhash)
        # generate the other addresses
        for _ in range(keys_to_generate-1):
            self._key_pair_new()

        # add sub-apis
        self._minter = TFChainMinter(wallet=self)
        self._atomicswap = TFChainAtomicSwap(wallet=self)
        self._threebot = TFChainThreeBot(wallet=self)
        self._erc20 = TFChainERC20(wallet=self)

        # scan already for keys once
        self._key_scan()

    @property
    def seed(self):
        return self._seed

    @property
    def mnemonic(self):
        return self._mnemonic_api.to_mnemonic(self.seed)

    @property
    def key_count(self):
        return self._key_count

    @property
    def key_scan_count(self):
        return self._key_scan_count

    @property
    def minter(self):
        &#34;&#34;&#34;
        Minter used to update the (Coin) Minter Definition
        as well as to mint new coins, only useable if this wallet
        has (co-)ownership over the current (coin) minter definition.
        &#34;&#34;&#34;
        return self._minter

    @property
    def atomicswap(self):
        &#34;&#34;&#34;
        Atomic Swap API used to create atomic swap contracts as initiator or participator,
        as well as to redeem and refund existing unredeemed atomic swap contrats.
        &#34;&#34;&#34;
        return self._atomicswap

    @property
    def threebot(self):
        &#34;&#34;&#34;
        ThreeBot API used to register new 3Bots and
        manage existing 3Bot records.
        &#34;&#34;&#34;
        return self._threebot

    @property
    def erc20(self):
        &#34;&#34;&#34;
        ERC20 API used to send coins to ERC20 Addresses,
        and register TFT addresses that can than be used as ERC20 Withdraw addresses.
        &#34;&#34;&#34;
        return self._erc20

    @property
    def client(self):
        &#34;&#34;&#34;
        Returns the TFChain Client that is used by this wallet,
        and through which this wallet communicates with Explorer nodes.
        &#34;&#34;&#34;
        return self._client

    @property
    def network_type(self):
        &#34;&#34;&#34;
        The network type, defined by the parent TFChain client,
        that this wallet is operating on.

        Changing the network type has to be done from the parent TFChain client.
        &#34;&#34;&#34;
        return self.client.network

    @property
    def addresses(self):
        &#34;&#34;&#34;
        The addresses owned and used by this wallet.
        &#34;&#34;&#34;
        # key scan first
        _ = self._key_scan()
        # than list all addresses
        return list(self._key_pairs.keys())

    @property
    def address(self):
        &#34;&#34;&#34;
        The primary address, the address generated with index 0.
        &#34;&#34;&#34;
        return self._primary_address

    @property
    def addresses_multisig(self):
        &#34;&#34;&#34;
        The multi signature wallet addresses co-owned and linked to this wallet,
        as reported by the internal balance reporter.
        &#34;&#34;&#34;
        balance = self.balance
        return balance.addresses_multisig

    @property
    def balance(self):
        &#34;&#34;&#34;
        The balance &#34;sheet&#34; of the wallet.
        &#34;&#34;&#34;
        # key scan first
        _ = self._key_scan()

        # first get chain info
        info = self.client.blockchain_info_get()

        addresses = self.addresses
        balance = WalletsBalance()
        # collect info for all personal addresses
        multisig_addresses = []
        for address in addresses:
            try:
                # collect the inputs/outputs linked to this address for all found transactions
                result = self._unlockhash_get(address)
                uh_balance = result.balance(info=info)
                balance = balance.balance_add(uh_balance)
                # collect all multisig addresses
                for address in result.multisig_addresses:
                    multisig_addresses.append(str(address))
            except tfchain.errors.ExplorerNoContent:
                 # ignore this exception as it simply means
                 # the address has no activity yet on the chain
                pass

        # collect info for all multisig addresses
        for address in multisig_addresses:
            try:
                # collect the inputs/outputs linked to this address for all found transactions
                result = self._unlockhash_get(address)
                uh_balance = result.balance(info=info)
                balance = balance.balance_add(uh_balance)
            except tfchain.errors.ExplorerNoContent:
                 # ignore this exception as it simply means
                 # the address has no activity yet on the chain
                pass
        # ensure info is defined for wallet, even if no content
        balance.chain_blockid = info.blockid
        balance.chain_time = info.timestamp
        balance.chain_height = info.height
        # return the balance
        return balance

    @property
    def transactions(self):
        &#34;&#34;&#34;
        Get all transactions linked to a personal wallet address.
        &#34;&#34;&#34;
        # key scan first
        self._key_scan()

        # for each address get all transactions
        transactions = set()
        for address in self.addresses:
            result = self._unlockhash_get(address)
            transactions.update(result.transactions)

        # sort all transactions
        transactions = sorted(transactions, key=(lambda txn: sys.maxsize if txn.height &lt; 0 else txn.height), reverse=True)

        # return all transactions
        return transactions

    def _key_scan(self):
        # try some extra key scanning, to see if other keys have been used
        # if we already have unsused keys, no scanning is done however
        if len(self._unused_key_pairs) != 0 or self.key_scan_count == 0:
            return False

        # use the defined count
        count = self.key_scan_count
        # key track of start key count, so we can easily check at the end,
        # if we indeed scanned for any new keys
        key_count_start = self.key_count
        # generate the key pairs, without integrating them already
        # loop, and do this until now more are found:
        while True:
            pairs = []
            used_pairs = []
            for offset in range(count):
                pairs.append(self._key_pair_new(integrate=False, offset=offset))
            for pair in pairs:
                address = str(pair.unlockhash)
                try:
                    self._unlockhash_get(address)
                    # register this pair as a known index
                    used_pairs.append(True)
                except tfchain.errors.ExplorerNoContent:
                    # ignore this exception as it simply means
                    # the address has no activity yet on the chain
                    used_pairs.append(False)
                    pass
            # check if any address was found
            if not reduce(lambda a, b: a or b, used_pairs):
                break

            last_index = 0
            for idx, pair in enumerate(pairs):
                if used_pairs[idx]:
                    last_index = idx
                    self._key_pair_add(pair, add_count=False)
                else:
                    self._unused_key_pairs.append(pair)
            # remove the unused pairs that came after the last known index
            self._unused_key_pairs = self._unused_key_pairs[:-count+last_index]
            # update the new key count
            self._key_count += last_index + 1

            # if the last pair is not used, we can stop scanning
            if not used_pairs[-1]:
                break
            # otherwise continue

        # return if we scanned new keys
        return self.key_count &gt; key_count_start

    def coins_send(self, recipient, amount, source=None, refund=None, lock=None, data=None):
        &#34;&#34;&#34;
        Send the specified amount of coins to the given recipient,
        optionally locked. Arbitrary data can be attached as well if desired.

        If the given recipient is a valid ERC20 address, than this will send
        the specified amount to that ERC20 address and no lock or data is allowed to be defined.

        The recipient is one of:
            - None: recipient is the Free-For-All wallet
            - str (or unlockhash): recipient is a personal wallet
            - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
            - an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        The lock can be a str, or int:
            - when it is an int it represents either a block height or an epoch timestamp (in seconds)
            - when a str it can be a Jumpscale Datetime (e.g. &#39;12:00:10&#39;, &#39;31/10/2012 12:30&#39;, ...) or a Jumpscale Duration (e.g. &#39;+ 2h&#39;, &#39;+7d12h&#39;, ...)

        Returns a TransactionSendResult.

        @param recipient: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        if ERC20Address.is_valid_value(recipient):
            if lock is not None:
                raise ValueError(&#34;a lock cannot be applied when sending coins to an ERC20 Address&#34;)
            if data is not None:
                raise ValueError(&#34;data cannot be added to the transaction when sending coins to an ERC20 Address&#34;)
            # all good, try to send to the ERC20 address
            return self.erc20.coins_send(address=recipient, amount=amount, source=source, refund=refund)

        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)

        # define recipient
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)

        # fund amount
        balance = self.balance
        miner_fee = self.client.minimum_miner_fee
        inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

        # define the refund condition
        if refund is None: # automatically choose a refund condition if none is given
            if suggested_refund is None:
                refund = ConditionTypes.unlockhash_new(unlockhash=self.address)
            else:
                refund = suggested_refund
        else:
            # use the given refund condition (defined as a recipient)
            refund = ConditionTypes.from_recipient(refund)

        # create transaction
        txn = tftransactions.new()
        # add main coin output
        txn.coin_output_add(value=amount, condition=recipient)
        # add refund coin output if needed
        if remainder &gt; 0:
            txn.coin_output_add(value=remainder, condition=refund)
        # add the miner fee
        txn.miner_fee_add(miner_fee)

        # add the coin inputs
        txn.coin_inputs = inputs

        # if there is data to be added, add it as well
        if data:
            txn.data = data

        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)
            # and return the created/submitted transaction for optional user consumption

        return TransactionSendResult(txn, submit)

    def coin_transaction_builder_new(self):
        &#34;&#34;&#34;
        Create a transaction builder that can be used to
        add multiple outputs, in a chained manner, and send them all at once.

        ERC20 coin outputs are not supported in the Coin Transaction Builder.
        &#34;&#34;&#34;
        return CoinTransactionBuilder(self)

    def transaction_sign(self, txn, submit=True):
        &#34;&#34;&#34;
        Sign in all places of the transaction where it is still possible,
        and on which the wallet has authority to do so.

        Returns a TransactionSignResult.

        @param txn: transaction to sign, a JSON-encoded txn or already loaded in-memory as a valid Transaction type
        &#34;&#34;&#34;
        # validate and/or normalize txn parameter
        if isinstance(txn, (str, dict)):
            txn = tftransactions.from_json(txn)
        elif not isinstance(txn, TransactionBaseClass):
            raise TypeError(&#34;txn value has invalid type {} and cannot be signed&#34;.format(type(txn)))

        balance = self.balance

        # check all parentids from the specified coin inputs,
        # and set the coin outputs for the ones this wallet knows about
        # and that are still unspent
        if len(txn.coin_inputs) &gt; 0:
            # collect all known outputs
            known_outputs = {}
            for co in balance.outputs_available:
                known_outputs[co.id] = co
            for co in balance.outputs_unconfirmed_available:
                known_outputs[co.id] = co
            for wallet in balance.wallets.values():
                for co in wallet.outputs_available:
                    known_outputs[co.id] = co
                for co in wallet.outputs_unconfirmed_available:
                    known_outputs[co.id] = co
            # mark the coin inputs that are known as available outputs by this wallet
            for ci in txn.coin_inputs:
                if ci.parentid in known_outputs:
                    ci.parent_output = known_outputs[ci.parentid]

        # check for specific transaction types, as to
        # be able to add whatever content we know we can add
        if isinstance(txn, (TransactionV128, TransactionV129)):
            # set the parent mint condition
            txn.parent_mint_condition = self.client.minter.condition_get()
            # define the current fulfillment if it is not defined
            if not txn.mint_fulfillment_defined():
                txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            # possible if the wallet does not own any of the still required signatures,
            # or for example because the wallet does not know about the parent outputs of
            # the inputs still to be signed
            return TransactionSignResult(txn, False, False)

        # fulfill the signature requests that we can fulfill
        signature_count = 0
        for request in sig_requests:
            try:
                key_pair = self.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
                signature_count += 1
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # check if fulfilled, and if so, we&#39;ll submit unless the callee does not want that
        is_fulfilled = txn.is_fulfilled()
        submit = (submit and is_fulfilled)
        if submit:
            txn.id = self._transaction_put(transaction=txn)
            addresses = self.addresses + balance.addresses_multisig
            # update balance
            for ci in txn.coin_inputs:
                if str(ci.parent_output.condition.unlockhash) in addresses:
                    balance.output_add(ci.parent_output, confirmed=False, spent=True)
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)

        # return up-to-date Txn, as well as if we signed and submitted
        return TransactionSignResult(txn, (signature_count&gt;0), submit)

    def address_new(self):
        &#34;&#34;&#34;
        Generate a new wallet address,
        using the wallet&#39;s seed and the current key index as input.

        An address, also known as unlock hash,
        is a blake2 hash of the public key that is linked to a private key.
        The public key is used for verification of signatures,
        that were created with the matching private key.
        &#34;&#34;&#34;
        return str(self._key_pair_new().unlockhash)

    def public_key_new(self):
        &#34;&#34;&#34;
        Generate a new wallet public key,
        using the wallet&#39;s seed and the current key index as input.
        &#34;&#34;&#34;
        return self._key_pair_new().public_key

    def key_pair_get(self, unlockhash):
        &#34;&#34;&#34;
        Get the private/public key pair for the given unlock hash.
        If the unlock has is not owned by this wallet a KeyError exception is raised.
        &#34;&#34;&#34;
        if not isinstance(unlockhash, (str, UnlockHash)):
            raise TypeError(&#34;unlockhash cannot be of type {}&#34;.format(type(unlockhash)))
        unlockhash = str(unlockhash)
        if unlockhash[:2] == &#39;00&#39;:
            key = self._key_pairs.get(self.address)
        else:
            key = self._key_pairs.get(unlockhash)
        if key is None:
            raise KeyError(&#34;wallet does not own unlock hash {}&#34;.format(unlockhash))
        return key

    def _unlockhash_get(self, address):
        return self.client.unlockhash_get(address)

    def _transaction_put(self, transaction):
        return self.client.transaction_put(transaction)

    def _key_pair_new(self, integrate=True, offset=0):
        &#34;&#34;&#34;
        Create a new key pair,
        and integrate it by default as well into the wallet&#39;s key pair dictionary.
        &#34;&#34;&#34;
        # if we have unused key pairs in-memory, use them first,
        # only used when integrating is True,
        # as we do not wish to use this feature when scanning
        if integrate and len(self._unused_key_pairs) &gt; 0:
            key_pair = self._unused_key_pairs.pop(0)
            self._key_pair_add(key_pair, add_count=False)
            return key_pair

        # otherwise create a new one
        e = encoder_sia_get()
        e.add_array(self.seed)
        e.add(self.key_count+offset)
        seed_hash = blake2(e.data)
        private_key = SigningKey(seed_hash)
        public_key = private_key.get_verifying_key()

        key_pair = SpendableKey(
            public_key = PublicKey(specifier=PublicKeySpecifier.ED25519, hash=public_key.to_bytes()),
            private_key = private_key)

        # if we wish to integrate (mostly when we&#39;re not scanning),
        # we also add it to our wallets known key pairs
        if integrate:
            self._key_pair_add(key_pair, add_count=True, offset=offset)

        return key_pair

    def _key_pair_add(self, key_pair, add_count=True, offset=0):
        &#34;&#34;&#34;
        A private utility function that is used by default
        by the _key_pair_new wallet method to integrate a newly created key pair
        into this wallet&#39;s key pair dictionary.

        This method is seperate as we also scan for other keys during the fetching
        of the balance of a wallet. When we do, we want to create new key pairs,
        but only integrate them, if indeed we found the key (or a key after it) was used.
        &#34;&#34;&#34;
        addr = str(key_pair.unlockhash)
        if addr in self._key_pairs:
            raise KeyError(&#34;wallet already contains a key pair for unlock hash {}&#34;.format(addr))
        self._key_pairs[addr] = key_pair
        if add_count:
            self._key_count += 1+offset

from tfchain.types.ConditionTypes import ConditionMultiSignature
from tfchain.types.FulfillmentTypes import FulfillmentMultiSignature, PublicKeySignaturePair

class TFChainMinter():
    &#34;&#34;&#34;
    TFChainMinter contains all Coin Minting logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def definition_set(self, minter, data=None):
        &#34;&#34;&#34;
        Redefine the current minter definition.
        Arbitrary data can be attached as well if desired.

        The minter is one of:
            - str (or unlockhash): minter is a personal wallet
            - list: minter is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): minter is a sigcount-of-addresscount MultiSig wallet

        Returns a TransactionSendResult.

        @param minter: see explanation above
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        # create empty Mint Definition Txn, with a newly generated Nonce set already
        txn = tftransactions.mint_definition_new()

        # add the minimum miner fee
        txn.miner_fee_add(self._minium_miner_fee)

        # set the new mint condition
        txn.mint_condition = ConditionTypes.from_recipient(minter)
        # minter definition must be of unlock type 1 or 3
        ut = txn.mint_condition.unlockhash.type
        if ut not in (UnlockHashType.PUBLIC_KEY, UnlockHashType.MULTI_SIG):
            raise ValueError(&#34;{} is an invalid unlock hash type and cannot be used for a minter definition&#34;.format(ut))

        # optionally set the data
        if data is not None:
            txn.data = data

        # get and set the current mint condition
        txn.parent_mint_condition = self._current_mint_condition_get()
        # create a raw fulfillment based on the current mint condition
        txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        submit = txn.is_fulfilled()
        if submit:
            txn.id = self._transaction_put(transaction=txn)

        # return the txn, as well as the submit status as a boolean
        return TransactionSendResult(txn, submit)

    def coins_new(self, recipient, amount, lock=None, data=None):
        &#34;&#34;&#34;
        Create new (amount of) coins and give them to the defined recipient.
        Arbitrary data can be attached as well if desired.

        The recipient is one of:
            - None: recipient is the Free-For-All wallet
            - str (or unlockhash/bytes/bytearray): recipient is a personal wallet
            - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        The lock can be a str, or int:
            - when it is an int it represents either a block height or an epoch timestamp (in seconds)
            - when a str it can be a Jumpscale Datetime (e.g. &#39;12:00:10&#39;, &#39;31/10/2012 12:30&#39;, ...) or a Jumpscale Duration (e.g. &#39;+ 2h&#39;, &#39;+7d12h&#39;, ...)

        Returns a TransactionSendResult.

        @param recipient: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        # create empty Mint Definition Txn, with a newly generated Nonce set already
        txn = tftransactions.mint_coin_creation_new()

        # add the minimum miner fee
        txn.miner_fee_add(self._minium_miner_fee)

        balance = self._wallet.balance

        # parse the output
        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)

        # define recipient
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)
        # and add it is the output
        txn.coin_output_add(value=amount, condition=recipient)

        # optionally set the data
        if data is not None:
            txn.data = data

        # get and set the current mint condition
        txn.parent_mint_condition = self._current_mint_condition_get()
        # create a raw fulfillment based on the current mint condition
        txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        submit = txn.is_fulfilled()
        if submit:
            txn.id = self._transaction_put(transaction=txn)
            # update balance of wallet
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)

        # return the txn, as well as the submit status as a boolean
        return TransactionSendResult(txn, submit)

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _current_mint_condition_get(self):
        &#34;&#34;&#34;
        Get the current mind condition from the parent TFChain client.
        &#34;&#34;&#34;
        return self._wallet.client.minter.condition_get()

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)


from tfchain.types.ConditionTypes import ConditionAtomicSwap, OutputLock, AtomicSwapSecret, AtomicSwapSecretHash
from tfchain.types.FulfillmentTypes import FulfillmentAtomicSwap

class TFChainAtomicSwap():
    &#34;&#34;&#34;
    TFChainAtomicSwap contains all Atomic Swap logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def initiate(self, participator, amount, refund_time=&#39;+48h&#39;, source=None, refund=None, data=None, submit=True):
        &#34;&#34;&#34;
        Initiate an atomic swap contract, targeted at the specified address,
        with the given amount. By default a 48 hours duration (starting from last block time)
        is used as time until contract can be refunded, but this can be changed.

        The participator is one of:
            - None: participator is the Free-For-All wallet
            - str (or unlockhash): participator is a personal wallet
            - list: participator is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): participator is a sigcount-of-addresscount MultiSig wallet

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        Returns the AtomicSwapInitiationResult.

        @param participator: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param duration: the duration until the atomic swap contract becomes refundable
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        @param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)
        &#34;&#34;&#34;
        # create a random secret
        secret = AtomicSwapSecret.random()
        secret_hash = AtomicSwapSecretHash.from_secret(secret)

        # create the contract
        result = self._create_contract(
            recipient=participator, amount=amount, refund_time=refund_time,
            source=source, refund=refund, data=data, secret_hash=secret_hash,
            submit=submit)

        # return the contract, transaction, submission status as well as secret
        return AtomicSwapInitiationResult(
            AtomicSwapContract(coinoutput=result.transaction.coin_outputs[0], unspent=True,
                current_timestamp=self._chain_time),
            secret, result.transaction, result.submitted)

    def participate(self, initiator, amount, secret_hash, refund_time=&#39;+24h&#39;, source=None, refund=None, data=None, submit=True):
        &#34;&#34;&#34;
        Initiate an atomic swap contract, targeted at the specified address,
        with the given amount. By default a 24 hours duration (starting from last block time)
        is used as time until contract can be refunded, but this can be changed.

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        Returns the AtomicSwapParticipationResult.

        @param initiator: str (or unlockhash) of a personal wallet
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param secret_hash: the secret hash to be use, the same secret hash as used for the initiation contract
        @param duration: the duration until the atomic swap contract becomes refundable
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (can only be a personal wallet address)
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        @param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)
        &#34;&#34;&#34;
        # normalize secret hash
        secret_hash = AtomicSwapSecretHash(value=secret_hash)

        # create the contract and return the contract, transaction and submission status
        result = self._create_contract(
            recipient=initiator, amount=amount, refund_time=refund_time, source=source,
            refund=refund, data=data, secret_hash=secret_hash, submit=submit)
        return AtomicSwapParticipationResult(
            AtomicSwapContract(coinoutput=result.transaction.coin_outputs[0], unspent=True, current_timestamp=self._chain_time),
            result.transaction, result.submitted)

    def verify(self, outputid, amount=None, secret_hash=None, min_refund_time=None, sender=False, receiver=False, contract=None):
        &#34;&#34;&#34;
        Verify the status and content of the Atomic Swap Contract linked to the given outputid.
        An exception is returned if the contract does not exist, has already been spent
        or is not valid according to this validation

        Returns the verified contract.

        @param outputid: str or Hash that identifies the coin output to whuich this contract is linked
        @param amount: validate amount if defined, int or str that defines the amount of TFT to set, see explanation above
        @param secret_hash: validate secret hash if defined, str or BinaryData
        @param min_refund_time: validate contract&#39;s refund time if defined, 0 if expected to be refundable, else the minimun time expected until it becomes refundable
        @param sender: if True it is expected that this wallet is registered as the sender of this contract
        @param receiver: if True it is expected that this wallet is registered as the receiver of this contract
        @param contract: if contract fetched in a previous call already, one can verify it also by directly passing it to this method
        &#34;&#34;&#34;
        if contract is None:
            co = None
            spend_txn = None
            # try to fetch the contract
            try:
                # try to fetch the coin output that is expected to contain the secret
                co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
            except tfchain.errors.ExplorerNoContent as exc:
                raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
            # check if the contract hasn&#39;t been spent already
            if spend_txn is not None:
                # if a spend transaction exists,
                # it means the contract was already spend, and can therefore no longer be redeemed
                raise tfchain.errors.AtomicSwapContractSpent(contract=AtomicSwapContract(
                    coinoutput=co, unspent=False, current_timestamp=self._chain_time), transaction=spend_txn)

            # create the unspent contract
            contract = AtomicSwapContract(coinoutput=co, unspent=True, current_timestamp=self._chain_time)
        elif not isinstance(contract, AtomicSwapContract):
            raise TypeError(&#34;contract was expected to be an AtomicSwapContract, not to be of type {}&#34;.format(type(contract)))
        else:
            # verify the outputid is the same
            if contract.outputid != outputid:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;output identifier is expected to be {}, not {}&#34;.format(str(outputid), str(contract.outputid)),
                    contract=contract)

        # if amount is given verify it
        if amount is not None:
            amount = Currency(value=amount)
            if amount != contract.amount:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;amount is expected to be {}, not {}&#34;.format(amount.str(with_unit=True), contract.amount.str(with_unit=True)),
                    contract=contract)

        # if secret hash is given verify it
        if secret_hash is not None:
            # normalize secret hash
            secret_hash = AtomicSwapSecretHash(value=secret_hash)
            if secret_hash != contract.secret_hash:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;secret_hash is expected to be {}, not {}&#34;.format(str(secret_hash), str(contract.secret_hash)),
                    contract=contract)

        # if min_refund_time is given verify it
        if min_refund_time is not None:
            chain_time = self._chain_time
            if isinstance(min_refund_time, str):
                min_refund_time = OutputLock(value=min_refund_time, current_timestamp=chain_time).value
            elif not isinstance(min_refund_time, int):
                raise TypeError(&#34;expected minimum refund time to be an integer or string, not to be of type {}&#34;.format(type(min_refund_time)))
            min_duration = max(0, min_refund_time-chain_time)
            chain_time = self._chain_time
            if chain_time &gt;= contract.refund_timestamp:
                contract_duration = 0
            else:
                contract_duration = contract.refund_timestamp - chain_time
            if min_duration &lt;= 0:
                if contract_duration != 0:
                    raise tfchain.errors.AtomicSwapContractInvalid(
                        message=&#34;contract cannot be refunded yet while it was expected to be possible already&#34;,
                        contract=contract)
            elif contract_duration &lt; min_duration:
                if contract_duration == 0:
                    raise tfchain.errors.AtomicSwapContractInvalid(
                        message=&#34;contract was expected to be non-refundable for at least {} more, but it can be refunded already since {}&#34;.format(
                            duration.toString(min_duration), epoch2HRDateTime(contract.refund_timestamp)),
                        contract=contract)
                elif contract_duration &lt; min_duration:
                    raise tfchain.errors.AtomicSwapContractInvalid(
                        message=&#34;contract was expected to be available for redemption for at least {}, but it is only available for {}&#34;.format(
                            duration.toString(min_duration), duration.toString(contract_duration)),
                        contract=contract)

        # if expected to be authorized to be the sender, verify this
        if sender and contract.sender not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;wallet not registered as sender of this contract&#34;, contract=contract)

        # if expected to be authorized to be the receiver, verify this
        if receiver and contract.receiver not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;wallet not registered as receiver of this contract&#34;, contract=contract)

        # return the contract for further optional consumption,
        # according to our validations it is valid
        return contract

    def redeem(self, outputid, secret, data=None):
        &#34;&#34;&#34;
        Redeem an unspent Atomic Swap contract.

        Returns the sent transaction.

        @param outputid: the identifier of the coin output that contains the atomic swap contract
        @param secret: secret, matching the contract&#39;s secret hash, used to redeem the contract
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        co = None
        spend_txn = None
        # try to fetch the contract
        try:
            # try to fetch the coin output that is expected to contain the secret
            co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
        # generate the contract
        contract = AtomicSwapContract(coinoutput=co, unspent=False, current_timestamp=self._chain_time) # either it is spent already or we&#39;ll spend it
        # check if the contract hasn&#39;t been spent already
        if spend_txn is not None:
            # if a spend transaction exists,
            # it means the contract was already spend, and can therefore no longer be redeemed
            raise tfchain.errors.AtomicSwapContractSpent(contract=contract, transaction=spend_txn)
        # verify the defined secret
        if not contract.verify_secret(secret):
            raise tfchain.errors.AtomicSwapInvalidSecret(contract=contract)

        # ensure this wallet is authorized to be the receiver
        if contract.receiver not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapForbidden(message=&#34;unauthorized to redeem: wallet does not contain receiver address {}&#34;.format(contract.receiver), contract=contract)

        # create the fulfillment
        fulfillment = FulfillmentTypes.atomic_swap_new(secret=secret)

        # create, sign and submit the transaction
        return self._claim_contract(contract=contract, as_sender=False, fulfillment=fulfillment, data=data)

    def refund(self, outputid, data=None):
        &#34;&#34;&#34;
        Refund an unspent Atomic Swap contract.

        Returns the sent transaction.

        @param outputid: the identifier of the coin output that contains the atomic swap contract
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        co = None
        spend_txn = None
        # try to fetch the contract
        try:
            # try to fetch the coin output that is expected to contain the secret
            co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
        # generate the contract
        contract = AtomicSwapContract(coinoutput=co, unspent=False, current_timestamp=self._chain_time) # either it is spent already or we&#39;ll spend it
        # check if the contract hasn&#39;t been spent already
        if spend_txn is not None:
            # if a spend transaction exists,
            # it means the contract was already spend, and can therefore no longer be redeemed
            raise tfchain.errors.AtomicSwapContractSpent(contract=contract, transaction=spend_txn)
        # verify the contract can be refunded already
        time = self._chain_time
        if time &lt; contract.refund_timestamp:
            raise tfchain.errors.AtomicSwapForbidden(
                message=&#34;unauthorized to refund: contract can only be refunded since {}&#34;.format(epoch2HRDateTime(contract.refund_timestamp)),
                contract=contract)

        # ensure this wallet is authorized to be the sender (refunder)
        if contract.sender not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapForbidden(message=&#34;unauthorized to refund: wallet does not contain sender address {}&#34;.format(contract.sender), contract=contract)

        # create the fulfillment
        fulfillment = FulfillmentTypes.atomic_swap_new()

        # create, sign and submit the transaction
        return self._claim_contract(contract=contract, as_sender=True, fulfillment=fulfillment, data=data)


    def _create_contract(self, recipient, amount, refund_time, source, refund, data, secret_hash, submit):
        &#34;&#34;&#34;
        Create a new atomic swap contract,
        the logic for both the initiate as well as participate phase.
        &#34;&#34;&#34;
        # define the amount
        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be swapped&#34;)

        # define the miner fee
        miner_fee = self._minium_miner_fee

        # ensure the amount is bigger than the miner fee,
        # otherwise the contract cannot be redeemed/refunded
        if amount &lt;= miner_fee:
            raise tfchain.errors.AtomicSwapInsufficientAmountError(amount=amount, minimum_miner_fee=miner_fee)

        # define the coin inputs
        balance = self._wallet.balance
        inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

        # define the refund
        if refund is not None:
            refund = ConditionTypes.from_recipient(refund)
        elif suggested_refund is not None:
            refund = ConditionTypes.from_recipient(suggested_refund)
        else:
            refund = ConditionTypes.from_recipient(self._wallet.address)

        # define the sender
        if isinstance(refund, ConditionUnlockHash):
            sender = refund.unlockhash
        else:
            sender = self._wallet.address

        # create and populate the transaction
        txn = tftransactions.new()
        txn.coin_inputs = inputs
        txn.miner_fee_add(self._minium_miner_fee)
        txn.data = data

        # define refund time already, so we can use the chain time as the current time
        if isinstance(refund_time, str):
            chain_time = self._chain_time
            refund_time = OutputLock(value=refund_time, current_timestamp=chain_time).value
        elif not isinstance(refund_time, int):
            raise TypeError(&#34;expected refund time to be an integer or string, not to be of type {}&#34;.format(type(refund_time)))

        # define the atomic swap contract and add it as a coin output
        asc = ConditionTypes.atomic_swap_new(
            sender=sender, receiver=recipient, hashed_secret=secret_hash, lock_time=refund_time)
        txn.coin_output_add(condition=asc, value=amount)

        # optionally add a refund coin output
        if remainder &gt; 0:
            txn.coin_output_add(condition=refund, value=remainder)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # assign all coin output ID&#39;s for atomic swap contracts,
        # as we always care about the contract&#39;s output ID and
        # the refund coin output has to be our coin output
        for idx, co in enumerate(txn.coin_outputs):
            co.id = txn.coin_outputid_new(idx)

        # submit if possible
        submit = submit and txn.is_fulfilled()
        if submit:
            txn.id = self._transaction_put(transaction=txn)
            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    balance.output_add(co, confirmed=False, spent=False)

        # return the txn, as well as the submit status as a boolean
        return TransactionSendResult(txn, submit)

    def _claim_contract(self, contract, as_sender, fulfillment, data):
        &#34;&#34;&#34;
        claim an unspent atomic swap contract
        &#34;&#34;&#34;
        # create the contract and fill in the easy content
        txn = tftransactions.new()
        miner_fee = self._minium_miner_fee
        txn.miner_fee_add(miner_fee)
        txn.data = data
        # define the coin input
        txn.coin_input_add(parentid=contract.outputid, fulfillment=fulfillment, parent_output=contract.coin_output)
        # and the coin output
        txn.coin_output_add(
            condition=ConditionTypes.unlockhash_new(contract.sender if as_sender else contract.receiver),
            value=contract.amount-miner_fee)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # submit if possible
        submit = txn.is_fulfilled()
        if not submit:
            raise Exception(&#34;BUG: transaction should be fulfilled at ths point, please fix or report as an isuse&#34;)

        # assign transactionid
        txn.id = self._transaction_put(transaction=txn)
        # update balance
        balance = self._wallet.balance
        addresses = self._wallet.addresses
        for idx, co in enumerate(txn.coin_outputs):
            if str(co.condition.unlockhash) in addresses:
                co.id = txn.coin_outputid_new(idx)
                balance.output_add(co, confirmed=False, spent=False)

        # return the txn
        return txn

    @property
    def _chain_time(self):
        &#34;&#34;&#34;
        Returns the time according to the chain&#39;s network.
        &#34;&#34;&#34;
        info = self._wallet.client.blockchain_info_get()
        return info.timestamp

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _output_get(self, outputid):
        &#34;&#34;&#34;
        Get the transactions linked to the given outputID.

        @param: id of te
        &#34;&#34;&#34;
        return self._wallet.client.output_get(outputid)

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)


class TFChainThreeBot():
    &#34;&#34;&#34;
    TFChainThreeBot contains all ThreeBot logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def record_new(self, months=1, names=None, addresses=None, key_index=None, source=None, refund=None):
        &#34;&#34;&#34;
        Create a new 3Bot by creating a new record on the BlockChain,
        by default 1 month rent is already paid for the 3Bot, but up to 24 months can immediately be pre-paid
        against a discount if desired.

        At least one name or one address is required, and up to 5 names and 10 addresses can
        exists for a single 3Bot.

        If no key_index is given a new key pair is generated for the wallet,
        otherwise the key pair on the given index of the wallet is used.

        Returns a TransactionSendResult.

        @param months: amount of months to be prepaid, at least 1 month is required, maximum 24 months is allowed
        @param names: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
        @param addresses: Network Addresses used to reach the 3Bot (minimum 0, maximum 10)
        @param key_index: if None is given a new key pair is generated, otherwise the key pair on the defined index is used.
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        # create the txn and fill the easiest properties already
        txn = tftransactions.threebot_registration_new()
        txn.number_of_months = months
        if names is None and addresses is None:
            raise ValueError(&#34;at least one name or one address is to be given, none is defined&#34;)
        txn.names = names
        txn.addresses = addresses

        # get the fees, and fund the transaction
        balance = self._fund_txn(txn, source, refund)

        # if the key_index is not defined, generate a new public key,
        # otherwise use the key_index given
        if key_index is None:
            txn.public_key = self._wallet.public_key_new()
        else:
            if not isinstance(key_index, int):
                raise TypeError(&#34;key index is to be of type int, not type {}&#34;.format(type(key_index)))
            addresses = self._wallet.addresses
            if key_index &lt; 0 or key_index &gt;= len(addresses):
                raise ValueError(&#34;key index {} is OOB, index cannot be negative, and can be maximum {}&#34;.format(key_index, len(addresses)-1))
            txn.public_key = self._wallet.key_pair_get(unlockhash=addresses[key_index]).public_key

        # sign, submit, update Balance and return result
        return self._sign_and_submit_txn(txn, balance)

    def record_update(self, identifier, months=0, names_to_add=None, names_to_remove=None, addresses_to_add=None, addresses_to_remove=None, source=None, refund=None):
        &#34;&#34;&#34;
        Update the record of an existing 3Bot, for which this Wallet is authorized to make such changes.
        Names and addresses can be added and removed. Removal of data is always for free, adding data costs money.
        Extra months can also be paid (up to 24 months in total), as to extend the expiration time further in the future.

        One of months, names_to_add, names_to_remove, addresses_to_add, addresses_to_remove has to be a value other than 0/None.

        Returns a TransactionSendResult.

        @param months: amount of months to be paid and added to the current months, if the 3Bot was inactive, the starting time will be now
        @param names_to_add: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
        @param names_to_remove: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
        @param addresses_to_add: Network Addresses to add and used to reach the 3Bot (minimum 0, maximum 10)
        @param addresses_to_remove: Network Addresses to remove and used to reach the 3Bot (minimum 0, maximum 10)
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        if months &lt; 1 and not reduce((lambda r, v: r or (v is not None)), [names_to_add, names_to_remove, addresses_to_add, addresses_to_remove], False):
            raise ValueError(&#34;extra months is to be given or one name/address is to be added/removed, none is defined&#34;)

        # create the txn and fill the easiest properties already
        txn = tftransactions.threebot_record_update_new()
        txn.botid = identifier
        txn.number_of_months = months
        txn.names_to_add = names_to_add
        txn.names_to_remove = names_to_remove
        txn.addresses_to_add = addresses_to_add
        txn.addresses_to_remove = addresses_to_remove

        # get the 3Bot Public Key
        record = self._wallet.client.threebot.record_get(identifier)
        # set the parent public key
        txn.parent_public_key = record.public_key

        # ensure the 3Bot is either active, or will be come active
        if record.expiration &lt;= self._chain_time and months == 0:
            raise tfchain.errors.ThreeBotInactive(identifier, record.expiration)

        # get the fees, and fund the transaction
        balance = self._fund_txn(txn, source, refund)

        # sign, submit, update Balance and return result
        return self._sign_and_submit_txn(txn, balance)

    def name_transfer(self, sender, receiver, names, source=None, refund=None):
        &#34;&#34;&#34;
        Transfer one or multiple 3Bot names from the sender 3Bot to the receiver 3Bot.
        Both the Sender and Receiver 3Bots have to be active at the time of transfer.

        Returns a TransactionSendResult.

        @param sender: identifier of the existing and active 3Bot sender bot
        @param receiver: identifier of the existing and active 3Bot receiver bot
        @param names: 3Bot Names to transfer (minumum 0, maximum 5)
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        # create the txn and fill the easiest properties already
        txn = tftransactions.threebot_name_transfer_new()
        txn.sender_botid = sender
        txn.receiver_botid = receiver
        txn.names = names
        if len(txn.names) == 0:
            raise ValueError(&#34;at least one (3Bot) name has to be transfered, but none were defined&#34;)

        # keep track of chain time
        chain_time = self._chain_time

        # get and assign the 3Bot&#39;s public key for the sender
        record = self._wallet.client.threebot.record_get(sender)
        txn.sender_parent_public_key = record.public_key
        # ensure sender bot is active
        if record.expiration &lt;= chain_time:
            raise tfchain.errors.ThreeBotInactive(sender, record.expiration)

        # get and assign the 3Bot&#39;s public key for the receiver
        record = self._wallet.client.threebot.record_get(receiver)
        txn.receiver_parent_public_key = record.public_key
        # ensure receiver bot is active
        if record.expiration &lt;= chain_time:
            raise tfchain.errors.ThreeBotInactive(receiver, record.expiration)

        # get the fees, and fund the transaction
        balance = self._fund_txn(txn, source, refund)

        # sign and update Balance and return result,
        # only if the 3Bot owns both public keys, the Txn will be already,
        # submitted as well
        return self._sign_and_submit_txn(txn, balance)


    def _fund_txn(self, txn, source, refund):
        &#34;&#34;&#34;
        common fund/refund/inputs/fees logic for all 3Bot Transactions
        &#34;&#34;&#34;
        # get the fees, and fund the transaction
        miner_fee = self._minium_miner_fee
        bot_fee = txn.required_bot_fees
        balance = self._wallet.balance
        inputs, remainder, suggested_refund = balance.fund(miner_fee+bot_fee, source=source)

        # add the coin inputs
        txn.coin_inputs = inputs

        # add refund coin output if needed
        if remainder &gt; 0:
            # define the refund condition
            if refund is None: # automatically choose a refund condition if none is given
                if suggested_refund is None:
                    refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
                else:
                    refund = suggested_refund
            else:
                # use the given refund condition (defined as a recipient)
                refund = ConditionTypes.from_recipient(refund)
            txn.refund_coin_output_set(value=remainder, condition=refund)
        # add the miner fee
        txn.transaction_fee = miner_fee

        # return balance object
        return balance

    def _sign_and_submit_txn(self, txn, balance):
        &#34;&#34;&#34;
        common sign and submit logic for all 3Bot Transactions
        &#34;&#34;&#34;
        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)
        # and return the created/submitted transaction for optional user consumption
        return TransactionSendResult(txn, submit)

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)

    @property
    def _chain_time(self):
        &#34;&#34;&#34;
        Returns the time according to the chain&#39;s network.
        &#34;&#34;&#34;
        info = self._wallet.client.blockchain_info_get()
        return info.timestamp


class TFChainERC20():
    &#34;&#34;&#34;
    TFChainERC20 contains all ERC20 (wallet) logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def coins_send(self, address, amount, source=None, refund=None):
        &#34;&#34;&#34;
        Send the specified amount of coins to the given ERC20 address.

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        Returns a TransactionSendResult.

        @param address: str or ERC20Address value to which the money is to be send
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)

        # create transaction
        txn = tftransactions.erc20_convert_new()
        # define the amount and recipient
        txn.address = ERC20Address(value=address)
        txn.value = amount

        # fund the transaction
        balance = self._fund_txn(txn, source, refund, txn.value)

        # sign, submit and return the transaction
        return self._sign_and_submit_txn(txn, balance)

    def address_register(self, value=None, source=None, refund=None):
        &#34;&#34;&#34;
        Register an existing TFT address of this wallet as an ERC20 Withdraw Address,
        either by specifying the address itself or by specifying the index of the address.
        If no value is defined a new key pair will be defined.

        Returns a TransactionSendResult.

        @param value: index of the TFT address or address itself, the address has to be owned by this wallet
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        if value is None:
            public_key = self._wallet.public_key_new()
        elif isinstance(value, (str, UnlockHash)):
            try:
                public_key = self._wallet.key_pair_get(unlockhash=value).public_key
            except KeyError as exc:
                if isinstance(value, str):
                    value = UnlockHash.from_json(value)
                raise tfchain.errors.ERC20RegistrationForbidden(address=value) from exc
        elif isinstance(value, int) and not isinstance(value, bool):
            addresses = self._wallet.addresses
            if value &lt; 0 or value &gt;= len(addresses):
                raise ValueError(&#34;address index {} is not a valid index for this wallet, has to be in the inclusive range of [0, {}]&#34;.format(
                    value, len(addresses)-1))
            public_key = self._wallet.key_pair_get(unlockhash=addresses[value]).public_key
        else:
            raise ValueError(&#34;value has to be a str, UnlockHash or int, cannot identify an address using value {} (type: {})&#34;.format(value, type(value)))

        # create transaction
        txn = tftransactions.erc20_address_registration_new()
        # define the public key
        txn.public_key = public_key

        # fund the transaction
        balance = self._fund_txn(txn, source, refund, txn.registration_fee)

        # sign, submit and return the transaction
        return self._sign_and_submit_txn(txn, balance)

    def address_get(self, value=None):
        &#34;&#34;&#34;
        Get the registration info of an existing TFT address of this wallet as an ERC20 Withdraw Address,
        either by specifying the address itself or by specifying the index of the address.
        If no value is defined the first wallet address will be used.

        Returns an ERC20AddressInfo named tuple.

        @param value: index of the TFT address or address itself, the address has to be owned by this wallet
        &#34;&#34;&#34;
        if value is None:
            public_key = self._wallet.key_pair_get(unlockhash=self._wallet.address).public_key
        elif isinstance(value, (str, UnlockHash)):
            try:
                public_key = self._wallet.key_pair_get(unlockhash=value).public_key
            except KeyError as exc:
                if isinstance(value, str):
                    value = UnlockHash.from_json(value)
                raise tfchain.errors.AddressNotInWallet(address=value) from exc
        elif isinstance(value, int) and not isinstance(value, bool):
            addresses = self._wallet.addresses
            if value &lt; 0 or value &gt;= len(addresses):
                raise ValueError(&#34;address index {} is not a valid index for this wallet, has to be in the inclusive range of [0, {}]&#34;.format(
                    value, len(addresses)-1))
            public_key = self._wallet.key_pair_get(unlockhash=addresses[value]).public_key
        else:
            raise ValueError(&#34;value has to be a str, UnlockHash or int, cannot identify an address using value {} (type: {})&#34;.format(value, type(value)))

        # look up the wallet address and return it
        return self._wallet.client.erc20.address_get(unlockhash=public_key.unlockhash)

    def addresses_get(self):
        &#34;&#34;&#34;
        Get the information for all registered ERC20 withdraw addresses.
        Can return a empty list if no addresses of this wallet were registered as an ERC20 withdraw address.

        Returns a list of ERC20AddressInfo named tuples.
        &#34;&#34;&#34;
        results = []
        # scan for some new keys first, to ensure we get all addresses
        self._wallet._key_scan()
        # get the ERC20 info for all addresses that are registered as ERC20 withdraw addresses, if any
        for address in self._wallet.addresses:
            try:
                info = self._wallet.client.erc20.address_get(address)
                results.append(info)
            except tfchain.errors.ExplorerNoContent:
                pass
        # return all found info, if anything
        return results

    def _fund_txn(self, txn, source, refund, amount):
        &#34;&#34;&#34;
        common fund/refund/inputs/fees logic for all ERC20 Transactions
        &#34;&#34;&#34;
        # get the fees, and fund the transaction
        miner_fee = self._minium_miner_fee
        balance = self._wallet.balance
        inputs, remainder, suggested_refund = balance.fund(miner_fee+amount, source=source)

        # add the coin inputs
        txn.coin_inputs = inputs

        # add refund coin output if needed
        if remainder &gt; 0:
            # define the refund condition
            if refund is None: # automatically choose a refund condition if none is given
                if suggested_refund is None:
                    refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
                else:
                    refund = suggested_refund
            else:
                # use the given refund condition (defined as a recipient)
                refund = ConditionTypes.from_recipient(refund)
            txn.refund_coin_output_set(value=remainder, condition=refund)

        # add the miner fee
        txn.transaction_fee = miner_fee

        # return balance object
        return balance

    def _sign_and_submit_txn(self, txn, balance):
        &#34;&#34;&#34;
        common sign and submit logic for all ERC20 Transactions
        &#34;&#34;&#34;
        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)

        # and return the created/submitted transaction for optional user consumption
        return TransactionSendResult(txn, submit)

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)

class TransactionSendResult():
    &#34;&#34;&#34;
    TransactionSendResult is a named tuple,
    used as the result for a generic transaction send call.
    &#34;&#34;&#34;
    def __init__(self, transaction, submitted):
        self._transaction = transaction
        self._submitted = submitted

    @property
    def transaction(self):
        return self._transaction
    @property
    def submitted(self):
        return self._submitted

class TransactionSignResult():
    &#34;&#34;&#34;
    TransactionSignResult is a named tuple,
    used as the result for a transaction sign call.
    &#34;&#34;&#34;
    def __init__(self, transaction, signed, submitted):
        self._transaction = transaction
        self._signed = signed
        self._submitted = submitted

    @property
    def transaction(self):
        return self._transaction
    @property
    def signed(self):
        return self._signed
    @property
    def submitted(self):
        return self._submitted

class AtomicSwapInitiationResult():
    &#34;&#34;&#34;
    AtomicSwapInitiationResult is a named tuple,
    used as the result for an atomic swap initiation call.
    &#34;&#34;&#34;
    def __init__(self, contract, secret, transaction, submitted):
        self._contract = contract
        self._secret = secret
        self._transaction = transaction
        self._submitted = submitted

    @property
    def contract(self):
        return self._contract
    @property
    def secret(self):
        return self._secret
    @property
    def transaction(self):
        return self._transaction
    @property
    def submitted(self):
        return self._submitted

class AtomicSwapParticipationResult():
    &#34;&#34;&#34;
    AtomicSwapParticipationResult is a named tuple,
    used as the result for an atomic swap participation call.
    &#34;&#34;&#34;
    def __init__(self, contract, transaction, submitted):
        self._contract = contract
        self._transaction = transaction
        self._submitted = submitted

    @property
    def contract(self):
        return self._contract
    @property
    def transaction(self):
        return self._transaction
    @property
    def submitted(self):
        return self._submitted

class SpendableKey():
    &#34;&#34;&#34;
    SpendableKey defines a PublicPrivate key pair as useable
    by a TFChain wallet.
    &#34;&#34;&#34;

    def __init__(self, public_key, private_key):
        if not isinstance(public_key, PublicKey):
            raise TypeError(&#34;public key cannot be of type {} (expected: PublicKey)&#34;.format(type(public_key)))
        self._public_key = public_key
        if not isinstance(private_key, SigningKey):
            raise TypeError(&#34;private key cannot be of type {} (expected: SigningKey)&#34;.format(type(private_key)))
        self._private_key = private_key

    @property
    def public_key(self):
        return self._public_key

    @property
    def private_key(self):
        return self._private_key

    @property
    def unlockhash(self):
        return self._public_key.unlockhash

    def sign(self, hash):
        &#34;&#34;&#34;
        Sign the given hash and return the signature.

        @param hash: hash to be signed
        &#34;&#34;&#34;
        if not isinstance(hash, Hash):
            hash = Hash(value=hash)
        hash = bytes(hash.value)
        return self._private_key.sign(hash)


class WalletBalance(object):
    def __init__(self):
        # personal wallet outputs
        self._outputs = {}
        self._outputs_spent = {}
        self._outputs_unconfirmed = {}
        self._outputs_unconfirmed_spent = {}
        # balance chain context
        self._chain_time = 0
        self._chain_height = 0
        self._chain_blockid = Hash()
        # all wallet addresses tracked in this wallet
        self._addresses = set()

    @property
    def addresses(self):
        &#34;&#34;&#34;
        All (personal wallet) addresses for which an output is tracked in this Balance.
        &#34;&#34;&#34;
        return list(self._addresses)

    @property
    def chain_blockid(self):
        &#34;&#34;&#34;
        Blockchain block ID, as defined by the last known block.
        &#34;&#34;&#34;
        return self._chain_blockid
    @chain_blockid.setter
    def chain_blockid(self, value):
        &#34;&#34;&#34;
        Set the blockchain block ID, such that applications that which to cache this
        balance object could ensure that the last block is still the same as the
        last known block known by this balance instance.
        &#34;&#34;&#34;
        if not value:
            self._chain_blockid = Hash()
            return
        if isinstance(value, Hash):
            self._chain_blockid.value = value.value
        else:
            self._chain_blockid.value = value

    @property
    def chain_time(self):
        &#34;&#34;&#34;
        Blockchain time, as defined by the last known block.
        &#34;&#34;&#34;
        return self._chain_time
    @chain_time.setter
    def chain_time(self, value):
        &#34;&#34;&#34;
        Set the blockchain time, such that the balance object can report
        locked/unlocked outputs correctly for outputs that are locked by time.
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise TypeError(&#34;WalletBalance&#39;s chain time cannot be of type {} (expected: int)&#34;.format(type(value)))
        self._chain_time = int(value)

    @property
    def chain_height(self):
        &#34;&#34;&#34;
        Blockchain height, as defined by the last known block.
        &#34;&#34;&#34;
        return self._chain_height
    @chain_height.setter
    def chain_height(self, value):
        &#34;&#34;&#34;
        Set the blockchain height, such that the balance object can report
        locked/unlocked outputs correctly for outputs that are locked by height.
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise TypeError(&#34;WalletBalance&#39;s chain height cannot be of type {} (expected: int)&#34;.format(type(value)))
        self._chain_height = int(value)

    @property
    def active(self):
        &#34;&#34;&#34;
        Returns if this balance is active,
        meaning it has available outputs to spend (confirmed or not).
        &#34;&#34;&#34;
        return len(self._outputs) &gt; 0 or len(self._outputs_unconfirmed) &gt; 0

    @property
    def outputs_spent(self):
        &#34;&#34;&#34;
        Spent (coin) outputs.
        &#34;&#34;&#34;
        return self._outputs_spent
    @property
    def outputs_unconfirmed(self):
        &#34;&#34;&#34;
        Unconfirmed (coin) outputs, available for spending or locked.
        &#34;&#34;&#34;
        return self._outputs_unconfirmed
    @property
    def outputs_unconfirmed_available(self):
        &#34;&#34;&#34;
        Unconfirmed (coin) outputs, available for spending.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return [co for co in self._outputs_unconfirmed.values()
                if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]
        else:
            return list(self._outputs_unconfirmed.values())
    @property
    def outputs_unconfirmed_spent(self):
        &#34;&#34;&#34;
        Unconfirmed (coin) outputs that have already been spent.
        &#34;&#34;&#34;
        return self._outputs_unconfirmed_spent

    @property
    def outputs_available(self):
        &#34;&#34;&#34;
        Total available (coin) outputs.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return [co for co in self._outputs.values()
                if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]
        else:
            return list(self._outputs.values())

    @property
    def available(self):
        &#34;&#34;&#34;
        Total available coins.
        &#34;&#34;&#34;
        return sum([co.value for co in self.outputs_available]) or Currency()

    @property
    def locked(self):
        &#34;&#34;&#34;
        Total available coins that are locked.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return sum([co.value for co in self._outputs.values()
                if co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
        else:
            return Currency(value=0) # impossible to know for sure without a complete context

    @property
    def unconfirmed(self):
        &#34;&#34;&#34;
        Total unconfirmed coins, available for spending.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return sum([co.value for co in self._outputs_unconfirmed.values()
                if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
        else:
            return sum([co.value for co in self._outputs_unconfirmed.values()])

    @property
    def unconfirmed_locked(self):
        &#34;&#34;&#34;
        Total unconfirmed coins that are locked, and thus not available for spending.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return sum([co.value for co in self._outputs_unconfirmed.values()
                if co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
        else:
            return Currency(value=0) # impossible to know for sure without a complete context

    def output_add(self, output, confirmed=True, spent=False):
        &#34;&#34;&#34;
        Add an output to the Wallet&#39;s balance.
        &#34;&#34;&#34;
        if confirmed: # confirmed outputs
            if spent:
                self._outputs_spent[output.id] = output
                # delete from other output lists if prior registered
                self._outputs.pop(output.id, None)
                self._outputs_unconfirmed.pop(output.id, None)
                self._outputs_unconfirmed_spent.pop(output.id, None)
            elif output.id not in self._outputs_spent and output.id not in self._outputs_unconfirmed_spent:
                self._outputs[output.id] = output
                # delete from other output lists if prior registered
                self._outputs_unconfirmed.pop(output.id, None)
        elif output.id not in self._outputs_spent: # unconfirmed outputs
            if spent:
                self._outputs_unconfirmed_spent[output.id] = output
                # delete from other output lists if prior registered
                self._outputs_unconfirmed.pop(output.id, None)
                self._outputs.pop(output.id, None)
            elif output.id not in self._outputs_unconfirmed_spent:
                self._outputs_unconfirmed[output.id] = output
        self._addresses.add(str(output.condition.unlockhash))

    @property
    def _base(self):
        &#34;&#34;&#34;
        Private helper utility to return this class as a new and pure WalletBalance object
        &#34;&#34;&#34;
        b = WalletBalance()
        b._outputs = self._outputs
        b._outputs_spent = self._outputs_spent
        b._outputs_unconfirmed = self._outputs_unconfirmed
        b._outputs_unconfirmed_spent = self._outputs_unconfirmed_spent
        b._chain_blockid = self._chain_blockid
        b._chain_height = self._chain_height
        b._chain_time = self._chain_time
        b._addresses = self._addresses
        return b

    def balance_add(self, other):
        &#34;&#34;&#34;
        Merge the content of the other balance into this balance.
        If other is None, this call results in a no-op.

        Always assign the result, as it could other than self,
        should the class type be changed in order to add all content correctly.
        &#34;&#34;&#34;
        if other is None:
            return self
        if isinstance(other, (WalletsBalance, MultiSigWalletBalance)):
            return WalletsBalance().balance_add(self).balance_add(other)
        if not isinstance(other, WalletBalance):
            raise TypeError(&#34;other balance has to be of type wallet balance&#34;)
        # another balance is defined, create a new balance that will contain our merge
        # merge the chain info
        if self.chain_height &gt;= other.chain_height:
            if self.chain_time &lt; other.chain_time:
                raise ValueError(&#34;chain time and chain height of balances do not match&#34;)
        else:
            if self.chain_time &gt;= other.chain_time:
                raise ValueError(&#34;chain time and chain height of balances do not match&#34;)
            self.chain_time = other.chain_time
            self.chain_height = other.chain_height
            self.chain_blockid = other.chain_blockid
        # merge the outputs
        for attr in [&#39;_outputs&#39;, &#39;_outputs_spent&#39;, &#39;_outputs_unconfirmed&#39;, &#39;_outputs_unconfirmed_spent&#39;]:
            d = getattr(self, attr, {})
            for id, output in getattr(other, attr, {}).items():
                d[id] = output
        # merge the addresses
        self._addresses |= other._addresses
        # return the modified self
        return self

    def drain(self, recipient, miner_fee, unconfirmed=False, data=None, lock=None):
        &#34;&#34;&#34;
        add all available outputs into as many transactions as required,
        by default only confirmed outputs are used, if unconfirmed=True
        it will use unconfirmed available outputs as well.

        Result can be an empty list if no outputs were available.

        @param recipient: required recipient towards who the drained coins will be sent
        @param the miner fee to be added to all sent transactions
        @param unconfirmed: optionally drain unconfirmed (available) outputs as well
        @param data: optional data that can be attached ot the created transactions (str or bytes), with a max length of 83
        @param lock: optional lock that can be attached to the sent coin outputs
        &#34;&#34;&#34;
        # define recipient
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)

        # validate miner fee
        if not isinstance(miner_fee, Currency):
            raise TypeError(&#34;miner fee has to be a currency&#34;)
        if miner_fee == 0:
            raise ValueError(&#34;a non-zero miner fee has to be defined&#34;)

        # collect all transactions in one list
        transactions = []

        # collect all confirmed (available) outputs
        outputs = self.outputs_available
        if unconfirmed:
            # if also the unconfirmed_avaialble) outputs are desired, let&#39;s add them as well
            outputs += self.outputs_unconfirmed_available
        # drain all outputs
        while len(outputs) &gt; 0:
            txn = tftransactions.new()
            txn.data = data
            txn.miner_fee_add(miner_fee)
            # select maximum _MAX_RIVINE_TRANSACTION_INPUTS outputs
            n = min(len(outputs), _MAX_RIVINE_TRANSACTION_INPUTS)
            used_outputs = outputs[:n]
            outputs = outputs[n:] # and update our output list, so we do not double spend
            # compute amount, minus minimum fee and add our only output
            amount = sum([co.value for co in used_outputs]) - miner_fee
            txn.coin_output_add(condition=recipient, value=amount)
            # add the coin inputs
            txn.coin_inputs = [CoinInput.from_coin_output(co) for co in used_outputs]
            # append the transaction
            transactions.append(txn)

        # return all created transactions, if any
        return transactions

    def _human_readable_balance(self):
        # report confirmed coins
        result = &#34;{} available and {} locked&#34;.format(self.available.str(with_unit=True), self.locked.str(with_unit=True))
        # optionally report unconfirmed coins
        unconfirmed = self.unconfirmed
        unconfirmed_locked = self.unconfirmed_locked
        if unconfirmed &gt; 0 or unconfirmed_locked &gt; 0:
            result += &#34;\nUnconfirmed: {} available {} locked&#34;.format(unconfirmed.str(with_unit=True), unconfirmed_locked.str(with_unit=True))
        unconfirmed_spent = Currency(value=sum([co.value for co in self._outputs_unconfirmed_spent.values()]))
        if unconfirmed_spent &gt; 0:
            result += &#34;\nUnconfirmed Balance Deduction: -{}&#34;.format(unconfirmed_spent.str(with_unit=True))
        # return report
        return result

    def __repr__(self):
        # report chain context
        result = &#34;&#34;
        if self.chain_height &gt; 0 and self.chain_time &gt; 0:
            result += &#34;wallet balance on height {} at {}\n&#34;.format(self.chain_height, epoch2HRDateTime(self.chain_time))
        else:
            result += &#34;wallet balance at an unknown time\n&#34;
        # report context + balance
        return result + self._human_readable_balance()

from tfchain.types.ConditionTypes import ConditionMultiSignature

class MultiSigWalletBalance(WalletBalance):
    def __init__(self, owners, signature_count):
        &#34;&#34;&#34;
        Creates a personal multi signature wallet.
        &#34;&#34;&#34;
        if not isinstance(signature_count, int):
            raise TypeError(&#34;signature count of a MultiSigWallet is expected to be of type int, not {}&#34;.format(type(signature_count)))
        if signature_count &lt; 1:
            raise ValueError(&#34;signature count of a MultiSigWallet has to be at least 1, cannot be {}&#34;.format(signature_count))
        if len(owners) &lt; signature_count:
            raise ValueError(&#34;the amount of owners ({}) cannot be lower than the specified signature count ({})&#34;.format(len(owners), signature_count))
        self._owners = owners
        self._signature_count = signature_count
        super().__init__()

    @property
    def address(self):
        &#34;&#34;&#34;
        The address of this MultiSig Wallet
        &#34;&#34;&#34;
        return str(ConditionMultiSignature(unlockhashes=self._owners, min_nr_sig=self._signature_count).unlockhash)

    @property
    def owners(self):
        &#34;&#34;&#34;
        Owners of this MultiSignature Wallet
        &#34;&#34;&#34;
        return [str(owner) for owner in self._owners]

    @property
    def signature_count(self):
        &#34;&#34;&#34;
        Amount of signatures minimum required
        &#34;&#34;&#34;
        return self._signature_count

    def balance_add(self, other):
        &#34;&#34;&#34;
        Merge the content of the other balance into this balance.
        If other is None, this call results in a no-op.

        Always assign the result, as it could other than self,
        should the class type be changed in order to add all content correctly.
        &#34;&#34;&#34;
        if other is None:
            return self
        if not isinstance(other, MultiSigWalletBalance):
            if isinstance(other, (WalletBalance, WalletsBalance)):
                return WalletsBalance().balance_add(self).balance_add(self)
            # can only merge 2 multi-signature wallet balances
            raise TypeError(&#34;other balance has to be of type multi-signature wallet balance&#34;)
        if self.address != other.addres:
            raise ValueError(&#34;other balance is for a different MultiSignature Wallet, cannot be merged&#34;)
        # piggy-back on the super class for the actual merge logic
        return super().balance_add(other._base)

    def _human_readable_balance(self):
        result = &#34;MultiSignature ({}-of-{}) Wallet {}:\n&#34;.format(self.signature_count, len(self.owners), self.address)
        result += &#34;Owners: &#34; + &#34;, &#34;.join(self.owners) +&#34;\n&#34;
        result += super()._human_readable_balance()
        return result

class WalletsBalance(WalletBalance):
    def __init__(self):
        &#34;&#34;&#34;
        Creates a personal wallet, which also can have children wallets that are meant for
        all MultiSignature wallets that are related to one or more addresses of the personal wallet.
        &#34;&#34;&#34;
        self._wallets = {}
        super().__init__()

    @property
    def wallets(self):
        &#34;&#34;&#34;
        All multisig wallets linked to this wallet.
        &#34;&#34;&#34;
        return self._wallets

    @property
    def addresses_multisig(self):
        &#34;&#34;&#34;
        All (multisig wallet) addresses for which an output is tracked in this Balance.
        For each address you&#39;ll find a wallet in the `self.wallets` dict property.
        &#34;&#34;&#34;
        return list(self.wallets.keys())

    def multisig_output_add(self, address, output, confirmed=True, spent=False):
        &#34;&#34;&#34;
        Add an output to the MultiSignature Wallet&#39;s balance.
        &#34;&#34;&#34;
        oc = output.condition.unwrap()
        if not isinstance(oc, ConditionMultiSignature):
            raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
        if not address in self._wallets:
            self._wallets[address] = MultiSigWalletBalance(
                owners=output.condition.unlockhashes,
                signature_count=output.condition.required_signatures)
        self._wallets[address].output_add(output, confirmed=confirmed, spent=spent)

    def output_add(self, output, confirmed=True, spent=False):
        &#34;&#34;&#34;
        Add an output to the Wallet&#39;s balance.
        &#34;&#34;&#34;
        uh = output.condition.unlockhash
        if uh.type == UnlockHashType.MULTI_SIG:
            return self.multisig_output_add(address=str(uh), output=output, confirmed=confirmed, spent=spent)
        self._addresses.add(str(uh))
        return super().output_add(output=output, confirmed=confirmed, spent=spent)

    def balance_add(self, other):
        &#34;&#34;&#34;
        Merge the content of the other balance into this balance.
        If other is None, this call results in a no-op.

        Always assign the result, as it could other than self,
        should the class type be changed in order to add all content correctly.
        &#34;&#34;&#34;
        if other is None:
            return self
        if not isinstance(other, WalletBalance):
            raise TypeError(&#34;other balance has to be of type wallet balance&#34;)
        if isinstance(other, MultiSigWalletBalance):
            self._merge_multisig_wallet_balance(other.address, other)
            return self
        # piggy-back on the super class for the actual output merge logic
        b = super().balance_add(other._base)
        if b != self:
            raise Exception(&#34;BUG: instance shouldn&#39;t have changed, please fix or report&#34;)
        if not isinstance(other, WalletsBalance):
            return b # return as nothing else can be merged
        # merge all the multi-signature wallets
        for addr, balance in other._wallets.items():
            b._merge_multisig_wallet_balance(addr, balance)
        # return the merged balance
        return b

    def _merge_multisig_wallet_balance(self, address, balance):
        &#34;&#34;&#34;
        Assign or merge a multi-sig wallet balance
        &#34;&#34;&#34;
        if address not in self._wallets:
            self._wallets[address] = balance
            return
        self._wallets[address] = self._wallets[address].merge(balance)

    def __repr__(self):
        result = super().__repr__()
        for wallet in self.wallets.values():
            if wallet.active: # only display active wallets in the Human (shell) Representation
                result += &#34;\n\n&#34; + wallet._human_readable_balance()
        return result

    def fund(self, amount, source=None):
        &#34;&#34;&#34;
        Fund the specified amount with the available outputs of this wallet&#39;s balance.
        &#34;&#34;&#34;
        # collect addresses and multisig addresses
        addresses = set()
        ms_addresses = set()
        refund = None
        if source is None:
            for co in self.outputs_available:
                addresses.add(co.condition.unlockhash)
            for co in self.outputs_unconfirmed_available:
                addresses.add(co.condition.unlockhash)
        else:
            # if only one address is given, transform it into an acceptable list
            if not isinstance(source, list):
                if isinstance(source, str):
                    source = UnlockHash.from_json(source)
                elif not isinstance(source, UnlockHash):
                    raise TypeError(&#34;cannot add source address from type {}&#34;.format(type(source)))
                source = [source]
            # add one or multiple personal/multisig addresses
            for value in source:
                if isinstance(value, str):
                    value = UnlockHash.from_json(value)
                elif not isinstance(value, UnlockHash):
                    raise TypeError(&#34;cannot add source address from type {}&#34;.format(type(value)))
                if value.type == UnlockHashType.MULTI_SIG:
                    ms_addresses.add(value)
                elif value.type == UnlockHashType.PUBLIC_KEY:
                    addresses.add(value)
                else:
                    raise TypeError(&#34;cannot add source addres with unsupported UnlockHashType {}&#34;.format(value.type))
            if len(source) == 1:
                if source[0].type == UnlockHashType.PUBLIC_KEY:
                    refund = ConditionTypes.unlockhash_new(unlockhash=source[0])
                else:
                    addr = str(source[0])
                    if addr in self.wallets:
                        wallet = self.wallets[addr]
                        refund = ConditionTypes.multi_signature_new(min_nr_sig=wallet.signature_count, unlockhashes=wallet.owners)


        # ensure at least one address is defined
        if len(addresses) == 0 and len(ms_addresses) == 0:
            raise tfchain.errors.InsufficientFunds(&#34;insufficient funds in this wallet&#34;)

        # if personal addresses are given, try to use these first
        # as these are the easiest kind to deal with
        if len(addresses) == 0:
            outputs, collected = ([], Currency()) # start with nothing
        else:
            outputs, collected = self._fund_individual(amount, addresses)

        if collected &gt;= amount:
            # if we already have sufficient, we stop now
            return ([CoinInput.from_coin_output(co) for co in outputs], collected-amount, refund)

        if len(ms_addresses) == 0:
            # if no ms_addresses were defined,
            raise tfchain.errors.InsufficientFunds(&#34;not enough funds available in the individual wallet to fund the requested amount&#34;)
        # otherwise keep going for multisig addresses
        outputs, collected = self._fund_multisig(amount, ms_addresses, outputs=outputs, collected=collected)

        # if we still didn&#39;t manage to fund enough, there is nothing we can do
        if collected &lt; amount:
            raise tfchain.errors.InsufficientFunds(&#34;not enough funds available in the wallets to fund the requested amount&#34;)
        return ([CoinInput.from_coin_output(co) for co in outputs], collected-amount, refund)

    def _fund_individual(self, amount, addresses):
        outputs_available = [co for co in self.outputs_available if co.condition.unlockhash in addresses]
        outputs_available.sort(key=lambda co: co.value)
        collected = Currency(value=0)
        outputs = []
        # try to fund only with confirmed outputs, if possible
        for co in outputs_available:
            if co.value &gt;= amount:
                return [co], co.value
            collected += co.value
            outputs.append(co)
            if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                # to not reach the input limit
                collected -= outputs.pop(0).value
            if collected &gt;= amount:
                return outputs, collected

        if collected &gt;= amount:
            # if we already have sufficient, we stop now
            return outputs, collected

        # use unconfirmed balance, not ideal, but acceptable
        outputs_available = [co for co in self.outputs_unconfirmed_available if co.condition.unlockhash in addresses]
        outputs_available.sort(key=lambda co: co.value, reverse=True)
        for co in outputs_available:
            if co.value &gt;= amount:
                return [co], co.value
            collected += co.value
            outputs.append(co)
            if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                # to not reach the input limit
                collected -= outputs.pop(0).value
            if collected &gt;= amount:
                return outputs, collected

        # we return whatever we have collected, no matter if it is sufficient
        return outputs, collected

    def _fund_multisig(self, amount, addresses, outputs=None, collected=None):
        if outputs is None:
            outputs = []
        if collected is None:
            collected = Currency()
        for address, wallet in self.wallets.items():
            if UnlockHash.from_json(address) not in addresses:
                continue # nothing to do here

            outputs_available = wallet.outputs_available
            outputs_available.sort(key=lambda co: co.value)
            # try to fund only with confirmed outputs, if possible
            for co in outputs_available:
                if co.value &gt;= amount:
                    return [co], co.value

                collected += co.value
                outputs.append(co)
                if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                    # to not reach the input limit
                    collected -= outputs.pop(0).value
                if collected &gt;= amount:
                    return outputs, collected

            if collected &gt;= amount:
                # if we already have sufficient, we stop now
                return outputs, collected

            # use unconfirmed balance, not ideal, but acceptable
            outputs_available = wallet.outputs_unconfirmed_available
            outputs_available.sort(key=lambda co: co.value, reverse=True)
            for co in outputs_available:
                if co.value &gt;= amount:
                    return [co], co.value
                collected += co.value
                outputs.append(co)
                if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                    # to not reach the input limit
                    collected -= outputs.pop(0).value
                if collected &gt;= amount:
                    return outputs, collected
        # we return whatever we have collected, no matter if it is sufficient
        return outputs, collected

class CoinTransactionBuilder():
    def __init__(self, wallet):
        self._txn = tftransactions.new()
        self._wallet = wallet

    def output_add(self, recipient, amount, lock=None):
        &#34;&#34;&#34;
        Add an output to the transaction, returning the transaction
        itself to allow for chaining.

        The recipient is one of:
            - None: recipient is the Free-For-All wallet
            - str (or unlockhash): recipient is a personal wallet
            - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
            - an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        @param recipient: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
        &#34;&#34;&#34;
        if self._txn is None:
            raise RuntimeError(&#34;coin transaction builder is already consumed&#34;)

        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)
        self._txn.coin_output_add(value=amount, condition=recipient)
        return self

    def send(self, source=None, refund=None, data=None):
        txn = self._txn
        self._txn = None

        # fund amount
        amount = sum([co.value for co in txn.coin_outputs])
        balance = self._wallet.balance
        miner_fee = self._wallet.client.minimum_miner_fee
        inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

        # define the refund condition
        if refund is None: # automatically choose a refund condition if none is given
            if suggested_refund is None:
                refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
            else:
                refund = suggested_refund
        else:
            # use the given refund condition (defined as a recipient)
            refund = ConditionTypes.from_recipient(refund)

        # add refund coin output if needed
        if remainder &gt; 0:
            txn.coin_output_add(value=remainder, condition=refund)
        # add the miner fee
        txn.miner_fee_add(miner_fee)

        # add the coin inputs
        txn.coin_inputs = inputs

        # if there is data to be added, add it as well
        if data:
            txn.data = data

        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._wallet._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)
            # and return the created/submitted transaction for optional user consumption

        return TransactionSendResult(txn, submit)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tfchain.TFChainWallet.AtomicSwapInitiationResult"><code class="flex name class">
<span>class <span class="ident">AtomicSwapInitiationResult</span></span>
<span>(</span><span>contract, secret, transaction, submitted)</span>
</code></dt>
<dd>
<section class="desc"><p>AtomicSwapInitiationResult is a named tuple,
used as the result for an atomic swap initiation call.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class AtomicSwapInitiationResult():
    &#34;&#34;&#34;
    AtomicSwapInitiationResult is a named tuple,
    used as the result for an atomic swap initiation call.
    &#34;&#34;&#34;
    def __init__(self, contract, secret, transaction, submitted):
        self._contract = contract
        self._secret = secret
        self._transaction = transaction
        self._submitted = submitted

    @property
    def contract(self):
        return self._contract
    @property
    def secret(self):
        return self._secret
    @property
    def transaction(self):
        return self._transaction
    @property
    def submitted(self):
        return self._submitted</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.AtomicSwapInitiationResult.contract"><code class="name">var <span class="ident">contract</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def contract(self):
    return self._contract</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.AtomicSwapInitiationResult.secret"><code class="name">var <span class="ident">secret</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def secret(self):
    return self._secret</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.AtomicSwapInitiationResult.submitted"><code class="name">var <span class="ident">submitted</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def submitted(self):
    return self._submitted</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.AtomicSwapInitiationResult.transaction"><code class="name">var <span class="ident">transaction</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transaction(self):
    return self._transaction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.AtomicSwapParticipationResult"><code class="flex name class">
<span>class <span class="ident">AtomicSwapParticipationResult</span></span>
<span>(</span><span>contract, transaction, submitted)</span>
</code></dt>
<dd>
<section class="desc"><p>AtomicSwapParticipationResult is a named tuple,
used as the result for an atomic swap participation call.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class AtomicSwapParticipationResult():
    &#34;&#34;&#34;
    AtomicSwapParticipationResult is a named tuple,
    used as the result for an atomic swap participation call.
    &#34;&#34;&#34;
    def __init__(self, contract, transaction, submitted):
        self._contract = contract
        self._transaction = transaction
        self._submitted = submitted

    @property
    def contract(self):
        return self._contract
    @property
    def transaction(self):
        return self._transaction
    @property
    def submitted(self):
        return self._submitted</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.AtomicSwapParticipationResult.contract"><code class="name">var <span class="ident">contract</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def contract(self):
    return self._contract</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.AtomicSwapParticipationResult.submitted"><code class="name">var <span class="ident">submitted</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def submitted(self):
    return self._submitted</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.AtomicSwapParticipationResult.transaction"><code class="name">var <span class="ident">transaction</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transaction(self):
    return self._transaction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.CoinTransactionBuilder"><code class="flex name class">
<span>class <span class="ident">CoinTransactionBuilder</span></span>
<span>(</span><span>wallet)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CoinTransactionBuilder():
    def __init__(self, wallet):
        self._txn = tftransactions.new()
        self._wallet = wallet

    def output_add(self, recipient, amount, lock=None):
        &#34;&#34;&#34;
        Add an output to the transaction, returning the transaction
        itself to allow for chaining.

        The recipient is one of:
            - None: recipient is the Free-For-All wallet
            - str (or unlockhash): recipient is a personal wallet
            - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
            - an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        @param recipient: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
        &#34;&#34;&#34;
        if self._txn is None:
            raise RuntimeError(&#34;coin transaction builder is already consumed&#34;)

        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)
        self._txn.coin_output_add(value=amount, condition=recipient)
        return self

    def send(self, source=None, refund=None, data=None):
        txn = self._txn
        self._txn = None

        # fund amount
        amount = sum([co.value for co in txn.coin_outputs])
        balance = self._wallet.balance
        miner_fee = self._wallet.client.minimum_miner_fee
        inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

        # define the refund condition
        if refund is None: # automatically choose a refund condition if none is given
            if suggested_refund is None:
                refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
            else:
                refund = suggested_refund
        else:
            # use the given refund condition (defined as a recipient)
            refund = ConditionTypes.from_recipient(refund)

        # add refund coin output if needed
        if remainder &gt; 0:
            txn.coin_output_add(value=remainder, condition=refund)
        # add the miner fee
        txn.miner_fee_add(miner_fee)

        # add the coin inputs
        txn.coin_inputs = inputs

        # if there is data to be added, add it as well
        if data:
            txn.data = data

        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._wallet._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)
            # and return the created/submitted transaction for optional user consumption

        return TransactionSendResult(txn, submit)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.CoinTransactionBuilder.output_add"><code class="name flex">
<span>def <span class="ident">output_add</span></span>(<span>self, recipient, amount, lock=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add an output to the transaction, returning the transaction
itself to allow for chaining.</p>
<p>The recipient is one of:
- None: recipient is the Free-For-All wallet
- str (or unlockhash): recipient is a personal wallet
- list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
- tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
- an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address</p>
<p>The amount can be a str or an int:
- when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
- when defining as a str you can use the following space-stripped and case-insentive formats:
- '123456789': same as when defining the amount as an int
- '123.456': define the amount in TFT (that is '123.456' == 123.456 TFT == 123456000000)
- '123456 TFT': define the amount in TFT (that is '123456 TFT' == 123456 TFT == 123456000000000)
- '123.456 TFT': define the amount in TFT (that is '123.456 TFT' == 123.456 TFT == 123456000000)</p>
<p>@param recipient: see explanation above
@param amount: int or str that defines the amount of TFT to set, see explanation above
@param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def output_add(self, recipient, amount, lock=None):
    &#34;&#34;&#34;
    Add an output to the transaction, returning the transaction
    itself to allow for chaining.

    The recipient is one of:
        - None: recipient is the Free-For-All wallet
        - str (or unlockhash): recipient is a personal wallet
        - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
        - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
        - an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address

    The amount can be a str or an int:
        - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
        - when defining as a str you can use the following space-stripped and case-insentive formats:
            - &#39;123456789&#39;: same as when defining the amount as an int
            - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
            - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
            - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

    @param recipient: see explanation above
    @param amount: int or str that defines the amount of TFT to set, see explanation above
    @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
    &#34;&#34;&#34;
    if self._txn is None:
        raise RuntimeError(&#34;coin transaction builder is already consumed&#34;)

    amount = Currency(value=amount)
    if amount &lt;= 0:
        raise ValueError(&#34;no amount is defined to be sent&#34;)
    recipient = ConditionTypes.from_recipient(recipient, lock=lock)
    self._txn.coin_output_add(value=amount, condition=recipient)
    return self</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.CoinTransactionBuilder.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, source=None, refund=None, data=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send(self, source=None, refund=None, data=None):
    txn = self._txn
    self._txn = None

    # fund amount
    amount = sum([co.value for co in txn.coin_outputs])
    balance = self._wallet.balance
    miner_fee = self._wallet.client.minimum_miner_fee
    inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

    # define the refund condition
    if refund is None: # automatically choose a refund condition if none is given
        if suggested_refund is None:
            refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
        else:
            refund = suggested_refund
    else:
        # use the given refund condition (defined as a recipient)
        refund = ConditionTypes.from_recipient(refund)

    # add refund coin output if needed
    if remainder &gt; 0:
        txn.coin_output_add(value=remainder, condition=refund)
    # add the miner fee
    txn.miner_fee_add(miner_fee)

    # add the coin inputs
    txn.coin_inputs = inputs

    # if there is data to be added, add it as well
    if data:
        txn.data = data

    # generate the signature requests
    sig_requests = txn.signature_requests_new()
    if len(sig_requests) == 0:
        raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

    # fulfill the signature requests that we can fulfill
    for request in sig_requests:
        try:
            key_pair = self._wallet.key_pair_get(request.wallet_address)
            input_hash = request.input_hash_new(public_key=key_pair.public_key)
            signature = key_pair.sign(input_hash)
            request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
        except KeyError:
            pass # this is acceptable due to how we directly try the key_pair_get method

    # txn should be fulfilled now
    submit = txn.is_fulfilled()
    if submit:
        # submit the transaction
        txn.id = self._wallet._transaction_put(transaction=txn)

        # update balance
        for ci in txn.coin_inputs:
            balance.output_add(ci.parent_output, confirmed=False, spent=True)
        addresses = self._wallet.addresses + balance.addresses_multisig
        for idx, co in enumerate(txn.coin_outputs):
            if str(co.condition.unlockhash) in addresses:
                # add the id to the coin_output, so we can track it has been spent
                co.id = txn.coin_outputid_new(idx)
                balance.output_add(co, confirmed=False, spent=False)
        # and return the created/submitted transaction for optional user consumption

    return TransactionSendResult(txn, submit)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.MultiSigWalletBalance"><code class="flex name class">
<span>class <span class="ident">MultiSigWalletBalance</span></span>
<span>(</span><span>owners, signature_count)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a personal multi signature wallet.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MultiSigWalletBalance(WalletBalance):
    def __init__(self, owners, signature_count):
        &#34;&#34;&#34;
        Creates a personal multi signature wallet.
        &#34;&#34;&#34;
        if not isinstance(signature_count, int):
            raise TypeError(&#34;signature count of a MultiSigWallet is expected to be of type int, not {}&#34;.format(type(signature_count)))
        if signature_count &lt; 1:
            raise ValueError(&#34;signature count of a MultiSigWallet has to be at least 1, cannot be {}&#34;.format(signature_count))
        if len(owners) &lt; signature_count:
            raise ValueError(&#34;the amount of owners ({}) cannot be lower than the specified signature count ({})&#34;.format(len(owners), signature_count))
        self._owners = owners
        self._signature_count = signature_count
        super().__init__()

    @property
    def address(self):
        &#34;&#34;&#34;
        The address of this MultiSig Wallet
        &#34;&#34;&#34;
        return str(ConditionMultiSignature(unlockhashes=self._owners, min_nr_sig=self._signature_count).unlockhash)

    @property
    def owners(self):
        &#34;&#34;&#34;
        Owners of this MultiSignature Wallet
        &#34;&#34;&#34;
        return [str(owner) for owner in self._owners]

    @property
    def signature_count(self):
        &#34;&#34;&#34;
        Amount of signatures minimum required
        &#34;&#34;&#34;
        return self._signature_count

    def balance_add(self, other):
        &#34;&#34;&#34;
        Merge the content of the other balance into this balance.
        If other is None, this call results in a no-op.

        Always assign the result, as it could other than self,
        should the class type be changed in order to add all content correctly.
        &#34;&#34;&#34;
        if other is None:
            return self
        if not isinstance(other, MultiSigWalletBalance):
            if isinstance(other, (WalletBalance, WalletsBalance)):
                return WalletsBalance().balance_add(self).balance_add(self)
            # can only merge 2 multi-signature wallet balances
            raise TypeError(&#34;other balance has to be of type multi-signature wallet balance&#34;)
        if self.address != other.addres:
            raise ValueError(&#34;other balance is for a different MultiSignature Wallet, cannot be merged&#34;)
        # piggy-back on the super class for the actual merge logic
        return super().balance_add(other._base)

    def _human_readable_balance(self):
        result = &#34;MultiSignature ({}-of-{}) Wallet {}:\n&#34;.format(self.signature_count, len(self.owners), self.address)
        result += &#34;Owners: &#34; + &#34;, &#34;.join(self.owners) +&#34;\n&#34;
        result += super()._human_readable_balance()
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tfchain.TFChainWallet.WalletBalance" href="#tfchain.TFChainWallet.WalletBalance">WalletBalance</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.MultiSigWalletBalance.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"><p>The address of this MultiSig Wallet</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def address(self):
    &#34;&#34;&#34;
    The address of this MultiSig Wallet
    &#34;&#34;&#34;
    return str(ConditionMultiSignature(unlockhashes=self._owners, min_nr_sig=self._signature_count).unlockhash)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.MultiSigWalletBalance.owners"><code class="name">var <span class="ident">owners</span></code></dt>
<dd>
<section class="desc"><p>Owners of this MultiSignature Wallet</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def owners(self):
    &#34;&#34;&#34;
    Owners of this MultiSignature Wallet
    &#34;&#34;&#34;
    return [str(owner) for owner in self._owners]</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.MultiSigWalletBalance.signature_count"><code class="name">var <span class="ident">signature_count</span></code></dt>
<dd>
<section class="desc"><p>Amount of signatures minimum required</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def signature_count(self):
    &#34;&#34;&#34;
    Amount of signatures minimum required
    &#34;&#34;&#34;
    return self._signature_count</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tfchain.TFChainWallet.WalletBalance" href="#tfchain.TFChainWallet.WalletBalance">WalletBalance</a></b></code>:
<ul class="hlist">
<li><code><a title="tfchain.TFChainWallet.WalletBalance.active" href="#tfchain.TFChainWallet.WalletBalance.active">active</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.addresses" href="#tfchain.TFChainWallet.WalletBalance.addresses">addresses</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.available" href="#tfchain.TFChainWallet.WalletBalance.available">available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.balance_add" href="#tfchain.TFChainWallet.WalletBalance.balance_add">balance_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_blockid" href="#tfchain.TFChainWallet.WalletBalance.chain_blockid">chain_blockid</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_height" href="#tfchain.TFChainWallet.WalletBalance.chain_height">chain_height</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_time" href="#tfchain.TFChainWallet.WalletBalance.chain_time">chain_time</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.drain" href="#tfchain.TFChainWallet.WalletBalance.drain">drain</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.locked" href="#tfchain.TFChainWallet.WalletBalance.locked">locked</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.output_add" href="#tfchain.TFChainWallet.WalletBalance.output_add">output_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_available" href="#tfchain.TFChainWallet.WalletBalance.outputs_available">outputs_available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_spent" href="#tfchain.TFChainWallet.WalletBalance.outputs_spent">outputs_spent</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed">outputs_unconfirmed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available">outputs_unconfirmed_available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent">outputs_unconfirmed_spent</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.unconfirmed" href="#tfchain.TFChainWallet.WalletBalance.unconfirmed">unconfirmed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.unconfirmed_locked" href="#tfchain.TFChainWallet.WalletBalance.unconfirmed_locked">unconfirmed_locked</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tfchain.TFChainWallet.SpendableKey"><code class="flex name class">
<span>class <span class="ident">SpendableKey</span></span>
<span>(</span><span>public_key, private_key)</span>
</code></dt>
<dd>
<section class="desc"><p>SpendableKey defines a PublicPrivate key pair as useable
by a TFChain wallet.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SpendableKey():
    &#34;&#34;&#34;
    SpendableKey defines a PublicPrivate key pair as useable
    by a TFChain wallet.
    &#34;&#34;&#34;

    def __init__(self, public_key, private_key):
        if not isinstance(public_key, PublicKey):
            raise TypeError(&#34;public key cannot be of type {} (expected: PublicKey)&#34;.format(type(public_key)))
        self._public_key = public_key
        if not isinstance(private_key, SigningKey):
            raise TypeError(&#34;private key cannot be of type {} (expected: SigningKey)&#34;.format(type(private_key)))
        self._private_key = private_key

    @property
    def public_key(self):
        return self._public_key

    @property
    def private_key(self):
        return self._private_key

    @property
    def unlockhash(self):
        return self._public_key.unlockhash

    def sign(self, hash):
        &#34;&#34;&#34;
        Sign the given hash and return the signature.

        @param hash: hash to be signed
        &#34;&#34;&#34;
        if not isinstance(hash, Hash):
            hash = Hash(value=hash)
        hash = bytes(hash.value)
        return self._private_key.sign(hash)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.SpendableKey.private_key"><code class="name">var <span class="ident">private_key</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def private_key(self):
    return self._private_key</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.SpendableKey.public_key"><code class="name">var <span class="ident">public_key</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def public_key(self):
    return self._public_key</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.SpendableKey.unlockhash"><code class="name">var <span class="ident">unlockhash</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def unlockhash(self):
    return self._public_key.unlockhash</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.SpendableKey.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, hash)</span>
</code></dt>
<dd>
<section class="desc"><p>Sign the given hash and return the signature.</p>
<p>@param hash: hash to be signed</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sign(self, hash):
    &#34;&#34;&#34;
    Sign the given hash and return the signature.

    @param hash: hash to be signed
    &#34;&#34;&#34;
    if not isinstance(hash, Hash):
        hash = Hash(value=hash)
    hash = bytes(hash.value)
    return self._private_key.sign(hash)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TFChainAtomicSwap"><code class="flex name class">
<span>class <span class="ident">TFChainAtomicSwap</span></span>
<span>(</span><span>wallet)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainAtomicSwap contains all Atomic Swap logic.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainAtomicSwap():
    &#34;&#34;&#34;
    TFChainAtomicSwap contains all Atomic Swap logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def initiate(self, participator, amount, refund_time=&#39;+48h&#39;, source=None, refund=None, data=None, submit=True):
        &#34;&#34;&#34;
        Initiate an atomic swap contract, targeted at the specified address,
        with the given amount. By default a 48 hours duration (starting from last block time)
        is used as time until contract can be refunded, but this can be changed.

        The participator is one of:
            - None: participator is the Free-For-All wallet
            - str (or unlockhash): participator is a personal wallet
            - list: participator is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): participator is a sigcount-of-addresscount MultiSig wallet

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        Returns the AtomicSwapInitiationResult.

        @param participator: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param duration: the duration until the atomic swap contract becomes refundable
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        @param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)
        &#34;&#34;&#34;
        # create a random secret
        secret = AtomicSwapSecret.random()
        secret_hash = AtomicSwapSecretHash.from_secret(secret)

        # create the contract
        result = self._create_contract(
            recipient=participator, amount=amount, refund_time=refund_time,
            source=source, refund=refund, data=data, secret_hash=secret_hash,
            submit=submit)

        # return the contract, transaction, submission status as well as secret
        return AtomicSwapInitiationResult(
            AtomicSwapContract(coinoutput=result.transaction.coin_outputs[0], unspent=True,
                current_timestamp=self._chain_time),
            secret, result.transaction, result.submitted)

    def participate(self, initiator, amount, secret_hash, refund_time=&#39;+24h&#39;, source=None, refund=None, data=None, submit=True):
        &#34;&#34;&#34;
        Initiate an atomic swap contract, targeted at the specified address,
        with the given amount. By default a 24 hours duration (starting from last block time)
        is used as time until contract can be refunded, but this can be changed.

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        Returns the AtomicSwapParticipationResult.

        @param initiator: str (or unlockhash) of a personal wallet
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param secret_hash: the secret hash to be use, the same secret hash as used for the initiation contract
        @param duration: the duration until the atomic swap contract becomes refundable
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (can only be a personal wallet address)
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        @param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)
        &#34;&#34;&#34;
        # normalize secret hash
        secret_hash = AtomicSwapSecretHash(value=secret_hash)

        # create the contract and return the contract, transaction and submission status
        result = self._create_contract(
            recipient=initiator, amount=amount, refund_time=refund_time, source=source,
            refund=refund, data=data, secret_hash=secret_hash, submit=submit)
        return AtomicSwapParticipationResult(
            AtomicSwapContract(coinoutput=result.transaction.coin_outputs[0], unspent=True, current_timestamp=self._chain_time),
            result.transaction, result.submitted)

    def verify(self, outputid, amount=None, secret_hash=None, min_refund_time=None, sender=False, receiver=False, contract=None):
        &#34;&#34;&#34;
        Verify the status and content of the Atomic Swap Contract linked to the given outputid.
        An exception is returned if the contract does not exist, has already been spent
        or is not valid according to this validation

        Returns the verified contract.

        @param outputid: str or Hash that identifies the coin output to whuich this contract is linked
        @param amount: validate amount if defined, int or str that defines the amount of TFT to set, see explanation above
        @param secret_hash: validate secret hash if defined, str or BinaryData
        @param min_refund_time: validate contract&#39;s refund time if defined, 0 if expected to be refundable, else the minimun time expected until it becomes refundable
        @param sender: if True it is expected that this wallet is registered as the sender of this contract
        @param receiver: if True it is expected that this wallet is registered as the receiver of this contract
        @param contract: if contract fetched in a previous call already, one can verify it also by directly passing it to this method
        &#34;&#34;&#34;
        if contract is None:
            co = None
            spend_txn = None
            # try to fetch the contract
            try:
                # try to fetch the coin output that is expected to contain the secret
                co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
            except tfchain.errors.ExplorerNoContent as exc:
                raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
            # check if the contract hasn&#39;t been spent already
            if spend_txn is not None:
                # if a spend transaction exists,
                # it means the contract was already spend, and can therefore no longer be redeemed
                raise tfchain.errors.AtomicSwapContractSpent(contract=AtomicSwapContract(
                    coinoutput=co, unspent=False, current_timestamp=self._chain_time), transaction=spend_txn)

            # create the unspent contract
            contract = AtomicSwapContract(coinoutput=co, unspent=True, current_timestamp=self._chain_time)
        elif not isinstance(contract, AtomicSwapContract):
            raise TypeError(&#34;contract was expected to be an AtomicSwapContract, not to be of type {}&#34;.format(type(contract)))
        else:
            # verify the outputid is the same
            if contract.outputid != outputid:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;output identifier is expected to be {}, not {}&#34;.format(str(outputid), str(contract.outputid)),
                    contract=contract)

        # if amount is given verify it
        if amount is not None:
            amount = Currency(value=amount)
            if amount != contract.amount:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;amount is expected to be {}, not {}&#34;.format(amount.str(with_unit=True), contract.amount.str(with_unit=True)),
                    contract=contract)

        # if secret hash is given verify it
        if secret_hash is not None:
            # normalize secret hash
            secret_hash = AtomicSwapSecretHash(value=secret_hash)
            if secret_hash != contract.secret_hash:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;secret_hash is expected to be {}, not {}&#34;.format(str(secret_hash), str(contract.secret_hash)),
                    contract=contract)

        # if min_refund_time is given verify it
        if min_refund_time is not None:
            chain_time = self._chain_time
            if isinstance(min_refund_time, str):
                min_refund_time = OutputLock(value=min_refund_time, current_timestamp=chain_time).value
            elif not isinstance(min_refund_time, int):
                raise TypeError(&#34;expected minimum refund time to be an integer or string, not to be of type {}&#34;.format(type(min_refund_time)))
            min_duration = max(0, min_refund_time-chain_time)
            chain_time = self._chain_time
            if chain_time &gt;= contract.refund_timestamp:
                contract_duration = 0
            else:
                contract_duration = contract.refund_timestamp - chain_time
            if min_duration &lt;= 0:
                if contract_duration != 0:
                    raise tfchain.errors.AtomicSwapContractInvalid(
                        message=&#34;contract cannot be refunded yet while it was expected to be possible already&#34;,
                        contract=contract)
            elif contract_duration &lt; min_duration:
                if contract_duration == 0:
                    raise tfchain.errors.AtomicSwapContractInvalid(
                        message=&#34;contract was expected to be non-refundable for at least {} more, but it can be refunded already since {}&#34;.format(
                            duration.toString(min_duration), epoch2HRDateTime(contract.refund_timestamp)),
                        contract=contract)
                elif contract_duration &lt; min_duration:
                    raise tfchain.errors.AtomicSwapContractInvalid(
                        message=&#34;contract was expected to be available for redemption for at least {}, but it is only available for {}&#34;.format(
                            duration.toString(min_duration), duration.toString(contract_duration)),
                        contract=contract)

        # if expected to be authorized to be the sender, verify this
        if sender and contract.sender not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;wallet not registered as sender of this contract&#34;, contract=contract)

        # if expected to be authorized to be the receiver, verify this
        if receiver and contract.receiver not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;wallet not registered as receiver of this contract&#34;, contract=contract)

        # return the contract for further optional consumption,
        # according to our validations it is valid
        return contract

    def redeem(self, outputid, secret, data=None):
        &#34;&#34;&#34;
        Redeem an unspent Atomic Swap contract.

        Returns the sent transaction.

        @param outputid: the identifier of the coin output that contains the atomic swap contract
        @param secret: secret, matching the contract&#39;s secret hash, used to redeem the contract
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        co = None
        spend_txn = None
        # try to fetch the contract
        try:
            # try to fetch the coin output that is expected to contain the secret
            co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
        # generate the contract
        contract = AtomicSwapContract(coinoutput=co, unspent=False, current_timestamp=self._chain_time) # either it is spent already or we&#39;ll spend it
        # check if the contract hasn&#39;t been spent already
        if spend_txn is not None:
            # if a spend transaction exists,
            # it means the contract was already spend, and can therefore no longer be redeemed
            raise tfchain.errors.AtomicSwapContractSpent(contract=contract, transaction=spend_txn)
        # verify the defined secret
        if not contract.verify_secret(secret):
            raise tfchain.errors.AtomicSwapInvalidSecret(contract=contract)

        # ensure this wallet is authorized to be the receiver
        if contract.receiver not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapForbidden(message=&#34;unauthorized to redeem: wallet does not contain receiver address {}&#34;.format(contract.receiver), contract=contract)

        # create the fulfillment
        fulfillment = FulfillmentTypes.atomic_swap_new(secret=secret)

        # create, sign and submit the transaction
        return self._claim_contract(contract=contract, as_sender=False, fulfillment=fulfillment, data=data)

    def refund(self, outputid, data=None):
        &#34;&#34;&#34;
        Refund an unspent Atomic Swap contract.

        Returns the sent transaction.

        @param outputid: the identifier of the coin output that contains the atomic swap contract
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        co = None
        spend_txn = None
        # try to fetch the contract
        try:
            # try to fetch the coin output that is expected to contain the secret
            co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
        # generate the contract
        contract = AtomicSwapContract(coinoutput=co, unspent=False, current_timestamp=self._chain_time) # either it is spent already or we&#39;ll spend it
        # check if the contract hasn&#39;t been spent already
        if spend_txn is not None:
            # if a spend transaction exists,
            # it means the contract was already spend, and can therefore no longer be redeemed
            raise tfchain.errors.AtomicSwapContractSpent(contract=contract, transaction=spend_txn)
        # verify the contract can be refunded already
        time = self._chain_time
        if time &lt; contract.refund_timestamp:
            raise tfchain.errors.AtomicSwapForbidden(
                message=&#34;unauthorized to refund: contract can only be refunded since {}&#34;.format(epoch2HRDateTime(contract.refund_timestamp)),
                contract=contract)

        # ensure this wallet is authorized to be the sender (refunder)
        if contract.sender not in self._wallet.addresses:
            raise tfchain.errors.AtomicSwapForbidden(message=&#34;unauthorized to refund: wallet does not contain sender address {}&#34;.format(contract.sender), contract=contract)

        # create the fulfillment
        fulfillment = FulfillmentTypes.atomic_swap_new()

        # create, sign and submit the transaction
        return self._claim_contract(contract=contract, as_sender=True, fulfillment=fulfillment, data=data)


    def _create_contract(self, recipient, amount, refund_time, source, refund, data, secret_hash, submit):
        &#34;&#34;&#34;
        Create a new atomic swap contract,
        the logic for both the initiate as well as participate phase.
        &#34;&#34;&#34;
        # define the amount
        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be swapped&#34;)

        # define the miner fee
        miner_fee = self._minium_miner_fee

        # ensure the amount is bigger than the miner fee,
        # otherwise the contract cannot be redeemed/refunded
        if amount &lt;= miner_fee:
            raise tfchain.errors.AtomicSwapInsufficientAmountError(amount=amount, minimum_miner_fee=miner_fee)

        # define the coin inputs
        balance = self._wallet.balance
        inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

        # define the refund
        if refund is not None:
            refund = ConditionTypes.from_recipient(refund)
        elif suggested_refund is not None:
            refund = ConditionTypes.from_recipient(suggested_refund)
        else:
            refund = ConditionTypes.from_recipient(self._wallet.address)

        # define the sender
        if isinstance(refund, ConditionUnlockHash):
            sender = refund.unlockhash
        else:
            sender = self._wallet.address

        # create and populate the transaction
        txn = tftransactions.new()
        txn.coin_inputs = inputs
        txn.miner_fee_add(self._minium_miner_fee)
        txn.data = data

        # define refund time already, so we can use the chain time as the current time
        if isinstance(refund_time, str):
            chain_time = self._chain_time
            refund_time = OutputLock(value=refund_time, current_timestamp=chain_time).value
        elif not isinstance(refund_time, int):
            raise TypeError(&#34;expected refund time to be an integer or string, not to be of type {}&#34;.format(type(refund_time)))

        # define the atomic swap contract and add it as a coin output
        asc = ConditionTypes.atomic_swap_new(
            sender=sender, receiver=recipient, hashed_secret=secret_hash, lock_time=refund_time)
        txn.coin_output_add(condition=asc, value=amount)

        # optionally add a refund coin output
        if remainder &gt; 0:
            txn.coin_output_add(condition=refund, value=remainder)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # assign all coin output ID&#39;s for atomic swap contracts,
        # as we always care about the contract&#39;s output ID and
        # the refund coin output has to be our coin output
        for idx, co in enumerate(txn.coin_outputs):
            co.id = txn.coin_outputid_new(idx)

        # submit if possible
        submit = submit and txn.is_fulfilled()
        if submit:
            txn.id = self._transaction_put(transaction=txn)
            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    balance.output_add(co, confirmed=False, spent=False)

        # return the txn, as well as the submit status as a boolean
        return TransactionSendResult(txn, submit)

    def _claim_contract(self, contract, as_sender, fulfillment, data):
        &#34;&#34;&#34;
        claim an unspent atomic swap contract
        &#34;&#34;&#34;
        # create the contract and fill in the easy content
        txn = tftransactions.new()
        miner_fee = self._minium_miner_fee
        txn.miner_fee_add(miner_fee)
        txn.data = data
        # define the coin input
        txn.coin_input_add(parentid=contract.outputid, fulfillment=fulfillment, parent_output=contract.coin_output)
        # and the coin output
        txn.coin_output_add(
            condition=ConditionTypes.unlockhash_new(contract.sender if as_sender else contract.receiver),
            value=contract.amount-miner_fee)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # submit if possible
        submit = txn.is_fulfilled()
        if not submit:
            raise Exception(&#34;BUG: transaction should be fulfilled at ths point, please fix or report as an isuse&#34;)

        # assign transactionid
        txn.id = self._transaction_put(transaction=txn)
        # update balance
        balance = self._wallet.balance
        addresses = self._wallet.addresses
        for idx, co in enumerate(txn.coin_outputs):
            if str(co.condition.unlockhash) in addresses:
                co.id = txn.coin_outputid_new(idx)
                balance.output_add(co, confirmed=False, spent=False)

        # return the txn
        return txn

    @property
    def _chain_time(self):
        &#34;&#34;&#34;
        Returns the time according to the chain&#39;s network.
        &#34;&#34;&#34;
        info = self._wallet.client.blockchain_info_get()
        return info.timestamp

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _output_get(self, outputid):
        &#34;&#34;&#34;
        Get the transactions linked to the given outputID.

        @param: id of te
        &#34;&#34;&#34;
        return self._wallet.client.output_get(outputid)

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.TFChainAtomicSwap.initiate"><code class="name flex">
<span>def <span class="ident">initiate</span></span>(<span>self, participator, amount, refund_time='+48h', source=None, refund=None, data=None, submit=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Initiate an atomic swap contract, targeted at the specified address,
with the given amount. By default a 48 hours duration (starting from last block time)
is used as time until contract can be refunded, but this can be changed.</p>
<p>The participator is one of:
- None: participator is the Free-For-All wallet
- str (or unlockhash): participator is a personal wallet
- list: participator is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
- tuple (addresses, sigcount): participator is a sigcount-of-addresscount MultiSig wallet</p>
<p>The amount can be a str or an int:
- when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
- when defining as a str you can use the following space-stripped and case-insentive formats:
- '123456789': same as when defining the amount as an int
- '123.456': define the amount in TFT (that is '123.456' == 123.456 TFT == 123456000000)
- '123456 TFT': define the amount in TFT (that is '123456 TFT' == 123456 TFT == 123456000000000)
- '123.456 TFT': define the amount in TFT (that is '123.456 TFT' == 123.456 TFT == 123456000000)</p>
<p>Returns the AtomicSwapInitiationResult.</p>
<p>@param participator: see explanation above
@param amount: int or str that defines the amount of TFT to set, see explanation above
@param duration: the duration until the atomic swap contract becomes refundable
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
@param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def initiate(self, participator, amount, refund_time=&#39;+48h&#39;, source=None, refund=None, data=None, submit=True):
    &#34;&#34;&#34;
    Initiate an atomic swap contract, targeted at the specified address,
    with the given amount. By default a 48 hours duration (starting from last block time)
    is used as time until contract can be refunded, but this can be changed.

    The participator is one of:
        - None: participator is the Free-For-All wallet
        - str (or unlockhash): participator is a personal wallet
        - list: participator is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
        - tuple (addresses, sigcount): participator is a sigcount-of-addresscount MultiSig wallet

    The amount can be a str or an int:
        - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
        - when defining as a str you can use the following space-stripped and case-insentive formats:
            - &#39;123456789&#39;: same as when defining the amount as an int
            - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
            - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
            - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

    Returns the AtomicSwapInitiationResult.

    @param participator: see explanation above
    @param amount: int or str that defines the amount of TFT to set, see explanation above
    @param duration: the duration until the atomic swap contract becomes refundable
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    @param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)
    &#34;&#34;&#34;
    # create a random secret
    secret = AtomicSwapSecret.random()
    secret_hash = AtomicSwapSecretHash.from_secret(secret)

    # create the contract
    result = self._create_contract(
        recipient=participator, amount=amount, refund_time=refund_time,
        source=source, refund=refund, data=data, secret_hash=secret_hash,
        submit=submit)

    # return the contract, transaction, submission status as well as secret
    return AtomicSwapInitiationResult(
        AtomicSwapContract(coinoutput=result.transaction.coin_outputs[0], unspent=True,
            current_timestamp=self._chain_time),
        secret, result.transaction, result.submitted)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainAtomicSwap.participate"><code class="name flex">
<span>def <span class="ident">participate</span></span>(<span>self, initiator, amount, secret_hash, refund_time='+24h', source=None, refund=None, data=None, submit=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Initiate an atomic swap contract, targeted at the specified address,
with the given amount. By default a 24 hours duration (starting from last block time)
is used as time until contract can be refunded, but this can be changed.</p>
<p>The amount can be a str or an int:
- when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
- when defining as a str you can use the following space-stripped and case-insentive formats:
- '123456789': same as when defining the amount as an int
- '123.456': define the amount in TFT (that is '123.456' == 123.456 TFT == 123456000000)
- '123456 TFT': define the amount in TFT (that is '123456 TFT' == 123456 TFT == 123456000000000)
- '123.456 TFT': define the amount in TFT (that is '123.456 TFT' == 123.456 TFT == 123456000000)</p>
<p>Returns the AtomicSwapParticipationResult.</p>
<p>@param initiator: str (or unlockhash) of a personal wallet
@param amount: int or str that defines the amount of TFT to set, see explanation above
@param secret_hash: the secret hash to be use, the same secret hash as used for the initiation contract
@param duration: the duration until the atomic swap contract becomes refundable
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (can only be a personal wallet address)
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
@param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def participate(self, initiator, amount, secret_hash, refund_time=&#39;+24h&#39;, source=None, refund=None, data=None, submit=True):
    &#34;&#34;&#34;
    Initiate an atomic swap contract, targeted at the specified address,
    with the given amount. By default a 24 hours duration (starting from last block time)
    is used as time until contract can be refunded, but this can be changed.

    The amount can be a str or an int:
        - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
        - when defining as a str you can use the following space-stripped and case-insentive formats:
            - &#39;123456789&#39;: same as when defining the amount as an int
            - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
            - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
            - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

    Returns the AtomicSwapParticipationResult.

    @param initiator: str (or unlockhash) of a personal wallet
    @param amount: int or str that defines the amount of TFT to set, see explanation above
    @param secret_hash: the secret hash to be use, the same secret hash as used for the initiation contract
    @param duration: the duration until the atomic swap contract becomes refundable
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (can only be a personal wallet address)
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    @param submit: True by default, if False the transaction will not be sent even if possible (e.g. if you want to double check)
    &#34;&#34;&#34;
    # normalize secret hash
    secret_hash = AtomicSwapSecretHash(value=secret_hash)

    # create the contract and return the contract, transaction and submission status
    result = self._create_contract(
        recipient=initiator, amount=amount, refund_time=refund_time, source=source,
        refund=refund, data=data, secret_hash=secret_hash, submit=submit)
    return AtomicSwapParticipationResult(
        AtomicSwapContract(coinoutput=result.transaction.coin_outputs[0], unspent=True, current_timestamp=self._chain_time),
        result.transaction, result.submitted)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainAtomicSwap.redeem"><code class="name flex">
<span>def <span class="ident">redeem</span></span>(<span>self, outputid, secret, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Redeem an unspent Atomic Swap contract.</p>
<p>Returns the sent transaction.</p>
<p>@param outputid: the identifier of the coin output that contains the atomic swap contract
@param secret: secret, matching the contract's secret hash, used to redeem the contract
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redeem(self, outputid, secret, data=None):
    &#34;&#34;&#34;
    Redeem an unspent Atomic Swap contract.

    Returns the sent transaction.

    @param outputid: the identifier of the coin output that contains the atomic swap contract
    @param secret: secret, matching the contract&#39;s secret hash, used to redeem the contract
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    &#34;&#34;&#34;
    co = None
    spend_txn = None
    # try to fetch the contract
    try:
        # try to fetch the coin output that is expected to contain the secret
        co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
    except tfchain.errors.ExplorerNoContent as exc:
        raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
    # generate the contract
    contract = AtomicSwapContract(coinoutput=co, unspent=False, current_timestamp=self._chain_time) # either it is spent already or we&#39;ll spend it
    # check if the contract hasn&#39;t been spent already
    if spend_txn is not None:
        # if a spend transaction exists,
        # it means the contract was already spend, and can therefore no longer be redeemed
        raise tfchain.errors.AtomicSwapContractSpent(contract=contract, transaction=spend_txn)
    # verify the defined secret
    if not contract.verify_secret(secret):
        raise tfchain.errors.AtomicSwapInvalidSecret(contract=contract)

    # ensure this wallet is authorized to be the receiver
    if contract.receiver not in self._wallet.addresses:
        raise tfchain.errors.AtomicSwapForbidden(message=&#34;unauthorized to redeem: wallet does not contain receiver address {}&#34;.format(contract.receiver), contract=contract)

    # create the fulfillment
    fulfillment = FulfillmentTypes.atomic_swap_new(secret=secret)

    # create, sign and submit the transaction
    return self._claim_contract(contract=contract, as_sender=False, fulfillment=fulfillment, data=data)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainAtomicSwap.refund"><code class="name flex">
<span>def <span class="ident">refund</span></span>(<span>self, outputid, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Refund an unspent Atomic Swap contract.</p>
<p>Returns the sent transaction.</p>
<p>@param outputid: the identifier of the coin output that contains the atomic swap contract
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refund(self, outputid, data=None):
    &#34;&#34;&#34;
    Refund an unspent Atomic Swap contract.

    Returns the sent transaction.

    @param outputid: the identifier of the coin output that contains the atomic swap contract
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    &#34;&#34;&#34;
    co = None
    spend_txn = None
    # try to fetch the contract
    try:
        # try to fetch the coin output that is expected to contain the secret
        co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
    except tfchain.errors.ExplorerNoContent as exc:
        raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
    # generate the contract
    contract = AtomicSwapContract(coinoutput=co, unspent=False, current_timestamp=self._chain_time) # either it is spent already or we&#39;ll spend it
    # check if the contract hasn&#39;t been spent already
    if spend_txn is not None:
        # if a spend transaction exists,
        # it means the contract was already spend, and can therefore no longer be redeemed
        raise tfchain.errors.AtomicSwapContractSpent(contract=contract, transaction=spend_txn)
    # verify the contract can be refunded already
    time = self._chain_time
    if time &lt; contract.refund_timestamp:
        raise tfchain.errors.AtomicSwapForbidden(
            message=&#34;unauthorized to refund: contract can only be refunded since {}&#34;.format(epoch2HRDateTime(contract.refund_timestamp)),
            contract=contract)

    # ensure this wallet is authorized to be the sender (refunder)
    if contract.sender not in self._wallet.addresses:
        raise tfchain.errors.AtomicSwapForbidden(message=&#34;unauthorized to refund: wallet does not contain sender address {}&#34;.format(contract.sender), contract=contract)

    # create the fulfillment
    fulfillment = FulfillmentTypes.atomic_swap_new()

    # create, sign and submit the transaction
    return self._claim_contract(contract=contract, as_sender=True, fulfillment=fulfillment, data=data)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainAtomicSwap.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, outputid, amount=None, secret_hash=None, min_refund_time=None, sender=False, receiver=False, contract=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify the status and content of the Atomic Swap Contract linked to the given outputid.
An exception is returned if the contract does not exist, has already been spent
or is not valid according to this validation</p>
<p>Returns the verified contract.</p>
<p>@param outputid: str or Hash that identifies the coin output to whuich this contract is linked
@param amount: validate amount if defined, int or str that defines the amount of TFT to set, see explanation above
@param secret_hash: validate secret hash if defined, str or BinaryData
@param min_refund_time: validate contract's refund time if defined, 0 if expected to be refundable, else the minimun time expected until it becomes refundable
@param sender: if True it is expected that this wallet is registered as the sender of this contract
@param receiver: if True it is expected that this wallet is registered as the receiver of this contract
@param contract: if contract fetched in a previous call already, one can verify it also by directly passing it to this method</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def verify(self, outputid, amount=None, secret_hash=None, min_refund_time=None, sender=False, receiver=False, contract=None):
    &#34;&#34;&#34;
    Verify the status and content of the Atomic Swap Contract linked to the given outputid.
    An exception is returned if the contract does not exist, has already been spent
    or is not valid according to this validation

    Returns the verified contract.

    @param outputid: str or Hash that identifies the coin output to whuich this contract is linked
    @param amount: validate amount if defined, int or str that defines the amount of TFT to set, see explanation above
    @param secret_hash: validate secret hash if defined, str or BinaryData
    @param min_refund_time: validate contract&#39;s refund time if defined, 0 if expected to be refundable, else the minimun time expected until it becomes refundable
    @param sender: if True it is expected that this wallet is registered as the sender of this contract
    @param receiver: if True it is expected that this wallet is registered as the receiver of this contract
    @param contract: if contract fetched in a previous call already, one can verify it also by directly passing it to this method
    &#34;&#34;&#34;
    if contract is None:
        co = None
        spend_txn = None
        # try to fetch the contract
        try:
            # try to fetch the coin output that is expected to contain the secret
            co, _, spend_txn = self._wallet.client.coin_output_get(outputid)
        except tfchain.errors.ExplorerNoContent as exc:
            raise tfchain.errors.AtomicSwapContractNotFound(outputid=outputid) from exc
        # check if the contract hasn&#39;t been spent already
        if spend_txn is not None:
            # if a spend transaction exists,
            # it means the contract was already spend, and can therefore no longer be redeemed
            raise tfchain.errors.AtomicSwapContractSpent(contract=AtomicSwapContract(
                coinoutput=co, unspent=False, current_timestamp=self._chain_time), transaction=spend_txn)

        # create the unspent contract
        contract = AtomicSwapContract(coinoutput=co, unspent=True, current_timestamp=self._chain_time)
    elif not isinstance(contract, AtomicSwapContract):
        raise TypeError(&#34;contract was expected to be an AtomicSwapContract, not to be of type {}&#34;.format(type(contract)))
    else:
        # verify the outputid is the same
        if contract.outputid != outputid:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;output identifier is expected to be {}, not {}&#34;.format(str(outputid), str(contract.outputid)),
                contract=contract)

    # if amount is given verify it
    if amount is not None:
        amount = Currency(value=amount)
        if amount != contract.amount:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;amount is expected to be {}, not {}&#34;.format(amount.str(with_unit=True), contract.amount.str(with_unit=True)),
                contract=contract)

    # if secret hash is given verify it
    if secret_hash is not None:
        # normalize secret hash
        secret_hash = AtomicSwapSecretHash(value=secret_hash)
        if secret_hash != contract.secret_hash:
            raise tfchain.errors.AtomicSwapContractInvalid(
                message=&#34;secret_hash is expected to be {}, not {}&#34;.format(str(secret_hash), str(contract.secret_hash)),
                contract=contract)

    # if min_refund_time is given verify it
    if min_refund_time is not None:
        chain_time = self._chain_time
        if isinstance(min_refund_time, str):
            min_refund_time = OutputLock(value=min_refund_time, current_timestamp=chain_time).value
        elif not isinstance(min_refund_time, int):
            raise TypeError(&#34;expected minimum refund time to be an integer or string, not to be of type {}&#34;.format(type(min_refund_time)))
        min_duration = max(0, min_refund_time-chain_time)
        chain_time = self._chain_time
        if chain_time &gt;= contract.refund_timestamp:
            contract_duration = 0
        else:
            contract_duration = contract.refund_timestamp - chain_time
        if min_duration &lt;= 0:
            if contract_duration != 0:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;contract cannot be refunded yet while it was expected to be possible already&#34;,
                    contract=contract)
        elif contract_duration &lt; min_duration:
            if contract_duration == 0:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;contract was expected to be non-refundable for at least {} more, but it can be refunded already since {}&#34;.format(
                        duration.toString(min_duration), epoch2HRDateTime(contract.refund_timestamp)),
                    contract=contract)
            elif contract_duration &lt; min_duration:
                raise tfchain.errors.AtomicSwapContractInvalid(
                    message=&#34;contract was expected to be available for redemption for at least {}, but it is only available for {}&#34;.format(
                        duration.toString(min_duration), duration.toString(contract_duration)),
                    contract=contract)

    # if expected to be authorized to be the sender, verify this
    if sender and contract.sender not in self._wallet.addresses:
        raise tfchain.errors.AtomicSwapContractInvalid(
            message=&#34;wallet not registered as sender of this contract&#34;, contract=contract)

    # if expected to be authorized to be the receiver, verify this
    if receiver and contract.receiver not in self._wallet.addresses:
        raise tfchain.errors.AtomicSwapContractInvalid(
            message=&#34;wallet not registered as receiver of this contract&#34;, contract=contract)

    # return the contract for further optional consumption,
    # according to our validations it is valid
    return contract</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TFChainERC20"><code class="flex name class">
<span>class <span class="ident">TFChainERC20</span></span>
<span>(</span><span>wallet)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainERC20 contains all ERC20 (wallet) logic.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainERC20():
    &#34;&#34;&#34;
    TFChainERC20 contains all ERC20 (wallet) logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def coins_send(self, address, amount, source=None, refund=None):
        &#34;&#34;&#34;
        Send the specified amount of coins to the given ERC20 address.

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        Returns a TransactionSendResult.

        @param address: str or ERC20Address value to which the money is to be send
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)

        # create transaction
        txn = tftransactions.erc20_convert_new()
        # define the amount and recipient
        txn.address = ERC20Address(value=address)
        txn.value = amount

        # fund the transaction
        balance = self._fund_txn(txn, source, refund, txn.value)

        # sign, submit and return the transaction
        return self._sign_and_submit_txn(txn, balance)

    def address_register(self, value=None, source=None, refund=None):
        &#34;&#34;&#34;
        Register an existing TFT address of this wallet as an ERC20 Withdraw Address,
        either by specifying the address itself or by specifying the index of the address.
        If no value is defined a new key pair will be defined.

        Returns a TransactionSendResult.

        @param value: index of the TFT address or address itself, the address has to be owned by this wallet
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        if value is None:
            public_key = self._wallet.public_key_new()
        elif isinstance(value, (str, UnlockHash)):
            try:
                public_key = self._wallet.key_pair_get(unlockhash=value).public_key
            except KeyError as exc:
                if isinstance(value, str):
                    value = UnlockHash.from_json(value)
                raise tfchain.errors.ERC20RegistrationForbidden(address=value) from exc
        elif isinstance(value, int) and not isinstance(value, bool):
            addresses = self._wallet.addresses
            if value &lt; 0 or value &gt;= len(addresses):
                raise ValueError(&#34;address index {} is not a valid index for this wallet, has to be in the inclusive range of [0, {}]&#34;.format(
                    value, len(addresses)-1))
            public_key = self._wallet.key_pair_get(unlockhash=addresses[value]).public_key
        else:
            raise ValueError(&#34;value has to be a str, UnlockHash or int, cannot identify an address using value {} (type: {})&#34;.format(value, type(value)))

        # create transaction
        txn = tftransactions.erc20_address_registration_new()
        # define the public key
        txn.public_key = public_key

        # fund the transaction
        balance = self._fund_txn(txn, source, refund, txn.registration_fee)

        # sign, submit and return the transaction
        return self._sign_and_submit_txn(txn, balance)

    def address_get(self, value=None):
        &#34;&#34;&#34;
        Get the registration info of an existing TFT address of this wallet as an ERC20 Withdraw Address,
        either by specifying the address itself or by specifying the index of the address.
        If no value is defined the first wallet address will be used.

        Returns an ERC20AddressInfo named tuple.

        @param value: index of the TFT address or address itself, the address has to be owned by this wallet
        &#34;&#34;&#34;
        if value is None:
            public_key = self._wallet.key_pair_get(unlockhash=self._wallet.address).public_key
        elif isinstance(value, (str, UnlockHash)):
            try:
                public_key = self._wallet.key_pair_get(unlockhash=value).public_key
            except KeyError as exc:
                if isinstance(value, str):
                    value = UnlockHash.from_json(value)
                raise tfchain.errors.AddressNotInWallet(address=value) from exc
        elif isinstance(value, int) and not isinstance(value, bool):
            addresses = self._wallet.addresses
            if value &lt; 0 or value &gt;= len(addresses):
                raise ValueError(&#34;address index {} is not a valid index for this wallet, has to be in the inclusive range of [0, {}]&#34;.format(
                    value, len(addresses)-1))
            public_key = self._wallet.key_pair_get(unlockhash=addresses[value]).public_key
        else:
            raise ValueError(&#34;value has to be a str, UnlockHash or int, cannot identify an address using value {} (type: {})&#34;.format(value, type(value)))

        # look up the wallet address and return it
        return self._wallet.client.erc20.address_get(unlockhash=public_key.unlockhash)

    def addresses_get(self):
        &#34;&#34;&#34;
        Get the information for all registered ERC20 withdraw addresses.
        Can return a empty list if no addresses of this wallet were registered as an ERC20 withdraw address.

        Returns a list of ERC20AddressInfo named tuples.
        &#34;&#34;&#34;
        results = []
        # scan for some new keys first, to ensure we get all addresses
        self._wallet._key_scan()
        # get the ERC20 info for all addresses that are registered as ERC20 withdraw addresses, if any
        for address in self._wallet.addresses:
            try:
                info = self._wallet.client.erc20.address_get(address)
                results.append(info)
            except tfchain.errors.ExplorerNoContent:
                pass
        # return all found info, if anything
        return results

    def _fund_txn(self, txn, source, refund, amount):
        &#34;&#34;&#34;
        common fund/refund/inputs/fees logic for all ERC20 Transactions
        &#34;&#34;&#34;
        # get the fees, and fund the transaction
        miner_fee = self._minium_miner_fee
        balance = self._wallet.balance
        inputs, remainder, suggested_refund = balance.fund(miner_fee+amount, source=source)

        # add the coin inputs
        txn.coin_inputs = inputs

        # add refund coin output if needed
        if remainder &gt; 0:
            # define the refund condition
            if refund is None: # automatically choose a refund condition if none is given
                if suggested_refund is None:
                    refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
                else:
                    refund = suggested_refund
            else:
                # use the given refund condition (defined as a recipient)
                refund = ConditionTypes.from_recipient(refund)
            txn.refund_coin_output_set(value=remainder, condition=refund)

        # add the miner fee
        txn.transaction_fee = miner_fee

        # return balance object
        return balance

    def _sign_and_submit_txn(self, txn, balance):
        &#34;&#34;&#34;
        common sign and submit logic for all ERC20 Transactions
        &#34;&#34;&#34;
        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)

        # and return the created/submitted transaction for optional user consumption
        return TransactionSendResult(txn, submit)

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.TFChainERC20.address_get"><code class="name flex">
<span>def <span class="ident">address_get</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the registration info of an existing TFT address of this wallet as an ERC20 Withdraw Address,
either by specifying the address itself or by specifying the index of the address.
If no value is defined the first wallet address will be used.</p>
<p>Returns an ERC20AddressInfo named tuple.</p>
<p>@param value: index of the TFT address or address itself, the address has to be owned by this wallet</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def address_get(self, value=None):
    &#34;&#34;&#34;
    Get the registration info of an existing TFT address of this wallet as an ERC20 Withdraw Address,
    either by specifying the address itself or by specifying the index of the address.
    If no value is defined the first wallet address will be used.

    Returns an ERC20AddressInfo named tuple.

    @param value: index of the TFT address or address itself, the address has to be owned by this wallet
    &#34;&#34;&#34;
    if value is None:
        public_key = self._wallet.key_pair_get(unlockhash=self._wallet.address).public_key
    elif isinstance(value, (str, UnlockHash)):
        try:
            public_key = self._wallet.key_pair_get(unlockhash=value).public_key
        except KeyError as exc:
            if isinstance(value, str):
                value = UnlockHash.from_json(value)
            raise tfchain.errors.AddressNotInWallet(address=value) from exc
    elif isinstance(value, int) and not isinstance(value, bool):
        addresses = self._wallet.addresses
        if value &lt; 0 or value &gt;= len(addresses):
            raise ValueError(&#34;address index {} is not a valid index for this wallet, has to be in the inclusive range of [0, {}]&#34;.format(
                value, len(addresses)-1))
        public_key = self._wallet.key_pair_get(unlockhash=addresses[value]).public_key
    else:
        raise ValueError(&#34;value has to be a str, UnlockHash or int, cannot identify an address using value {} (type: {})&#34;.format(value, type(value)))

    # look up the wallet address and return it
    return self._wallet.client.erc20.address_get(unlockhash=public_key.unlockhash)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainERC20.address_register"><code class="name flex">
<span>def <span class="ident">address_register</span></span>(<span>self, value=None, source=None, refund=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Register an existing TFT address of this wallet as an ERC20 Withdraw Address,
either by specifying the address itself or by specifying the index of the address.
If no value is defined a new key pair will be defined.</p>
<p>Returns a TransactionSendResult.</p>
<p>@param value: index of the TFT address or address itself, the address has to be owned by this wallet
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def address_register(self, value=None, source=None, refund=None):
    &#34;&#34;&#34;
    Register an existing TFT address of this wallet as an ERC20 Withdraw Address,
    either by specifying the address itself or by specifying the index of the address.
    If no value is defined a new key pair will be defined.

    Returns a TransactionSendResult.

    @param value: index of the TFT address or address itself, the address has to be owned by this wallet
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    &#34;&#34;&#34;
    if value is None:
        public_key = self._wallet.public_key_new()
    elif isinstance(value, (str, UnlockHash)):
        try:
            public_key = self._wallet.key_pair_get(unlockhash=value).public_key
        except KeyError as exc:
            if isinstance(value, str):
                value = UnlockHash.from_json(value)
            raise tfchain.errors.ERC20RegistrationForbidden(address=value) from exc
    elif isinstance(value, int) and not isinstance(value, bool):
        addresses = self._wallet.addresses
        if value &lt; 0 or value &gt;= len(addresses):
            raise ValueError(&#34;address index {} is not a valid index for this wallet, has to be in the inclusive range of [0, {}]&#34;.format(
                value, len(addresses)-1))
        public_key = self._wallet.key_pair_get(unlockhash=addresses[value]).public_key
    else:
        raise ValueError(&#34;value has to be a str, UnlockHash or int, cannot identify an address using value {} (type: {})&#34;.format(value, type(value)))

    # create transaction
    txn = tftransactions.erc20_address_registration_new()
    # define the public key
    txn.public_key = public_key

    # fund the transaction
    balance = self._fund_txn(txn, source, refund, txn.registration_fee)

    # sign, submit and return the transaction
    return self._sign_and_submit_txn(txn, balance)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainERC20.addresses_get"><code class="name flex">
<span>def <span class="ident">addresses_get</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the information for all registered ERC20 withdraw addresses.
Can return a empty list if no addresses of this wallet were registered as an ERC20 withdraw address.</p>
<p>Returns a list of ERC20AddressInfo named tuples.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addresses_get(self):
    &#34;&#34;&#34;
    Get the information for all registered ERC20 withdraw addresses.
    Can return a empty list if no addresses of this wallet were registered as an ERC20 withdraw address.

    Returns a list of ERC20AddressInfo named tuples.
    &#34;&#34;&#34;
    results = []
    # scan for some new keys first, to ensure we get all addresses
    self._wallet._key_scan()
    # get the ERC20 info for all addresses that are registered as ERC20 withdraw addresses, if any
    for address in self._wallet.addresses:
        try:
            info = self._wallet.client.erc20.address_get(address)
            results.append(info)
        except tfchain.errors.ExplorerNoContent:
            pass
    # return all found info, if anything
    return results</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainERC20.coins_send"><code class="name flex">
<span>def <span class="ident">coins_send</span></span>(<span>self, address, amount, source=None, refund=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send the specified amount of coins to the given ERC20 address.</p>
<p>The amount can be a str or an int:
- when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
- when defining as a str you can use the following space-stripped and case-insentive formats:
- '123456789': same as when defining the amount as an int
- '123.456': define the amount in TFT (that is '123.456' == 123.456 TFT == 123456000000)
- '123456 TFT': define the amount in TFT (that is '123456 TFT' == 123456 TFT == 123456000000000)
- '123.456 TFT': define the amount in TFT (that is '123.456 TFT' == 123.456 TFT == 123456000000)</p>
<p>Returns a TransactionSendResult.</p>
<p>@param address: str or ERC20Address value to which the money is to be send
@param amount: int or str that defines the amount of TFT to set, see explanation above
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def coins_send(self, address, amount, source=None, refund=None):
    &#34;&#34;&#34;
    Send the specified amount of coins to the given ERC20 address.

    The amount can be a str or an int:
        - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
        - when defining as a str you can use the following space-stripped and case-insentive formats:
            - &#39;123456789&#39;: same as when defining the amount as an int
            - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
            - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
            - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

    Returns a TransactionSendResult.

    @param address: str or ERC20Address value to which the money is to be send
    @param amount: int or str that defines the amount of TFT to set, see explanation above
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    &#34;&#34;&#34;
    amount = Currency(value=amount)
    if amount &lt;= 0:
        raise ValueError(&#34;no amount is defined to be sent&#34;)

    # create transaction
    txn = tftransactions.erc20_convert_new()
    # define the amount and recipient
    txn.address = ERC20Address(value=address)
    txn.value = amount

    # fund the transaction
    balance = self._fund_txn(txn, source, refund, txn.value)

    # sign, submit and return the transaction
    return self._sign_and_submit_txn(txn, balance)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TFChainMinter"><code class="flex name class">
<span>class <span class="ident">TFChainMinter</span></span>
<span>(</span><span>wallet)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainMinter contains all Coin Minting logic.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainMinter():
    &#34;&#34;&#34;
    TFChainMinter contains all Coin Minting logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def definition_set(self, minter, data=None):
        &#34;&#34;&#34;
        Redefine the current minter definition.
        Arbitrary data can be attached as well if desired.

        The minter is one of:
            - str (or unlockhash): minter is a personal wallet
            - list: minter is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): minter is a sigcount-of-addresscount MultiSig wallet

        Returns a TransactionSendResult.

        @param minter: see explanation above
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        # create empty Mint Definition Txn, with a newly generated Nonce set already
        txn = tftransactions.mint_definition_new()

        # add the minimum miner fee
        txn.miner_fee_add(self._minium_miner_fee)

        # set the new mint condition
        txn.mint_condition = ConditionTypes.from_recipient(minter)
        # minter definition must be of unlock type 1 or 3
        ut = txn.mint_condition.unlockhash.type
        if ut not in (UnlockHashType.PUBLIC_KEY, UnlockHashType.MULTI_SIG):
            raise ValueError(&#34;{} is an invalid unlock hash type and cannot be used for a minter definition&#34;.format(ut))

        # optionally set the data
        if data is not None:
            txn.data = data

        # get and set the current mint condition
        txn.parent_mint_condition = self._current_mint_condition_get()
        # create a raw fulfillment based on the current mint condition
        txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        submit = txn.is_fulfilled()
        if submit:
            txn.id = self._transaction_put(transaction=txn)

        # return the txn, as well as the submit status as a boolean
        return TransactionSendResult(txn, submit)

    def coins_new(self, recipient, amount, lock=None, data=None):
        &#34;&#34;&#34;
        Create new (amount of) coins and give them to the defined recipient.
        Arbitrary data can be attached as well if desired.

        The recipient is one of:
            - None: recipient is the Free-For-All wallet
            - str (or unlockhash/bytes/bytearray): recipient is a personal wallet
            - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        The lock can be a str, or int:
            - when it is an int it represents either a block height or an epoch timestamp (in seconds)
            - when a str it can be a Jumpscale Datetime (e.g. &#39;12:00:10&#39;, &#39;31/10/2012 12:30&#39;, ...) or a Jumpscale Duration (e.g. &#39;+ 2h&#39;, &#39;+7d12h&#39;, ...)

        Returns a TransactionSendResult.

        @param recipient: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        # create empty Mint Definition Txn, with a newly generated Nonce set already
        txn = tftransactions.mint_coin_creation_new()

        # add the minimum miner fee
        txn.miner_fee_add(self._minium_miner_fee)

        balance = self._wallet.balance

        # parse the output
        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)

        # define recipient
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)
        # and add it is the output
        txn.coin_output_add(value=amount, condition=recipient)

        # optionally set the data
        if data is not None:
            txn.data = data

        # get and set the current mint condition
        txn.parent_mint_condition = self._current_mint_condition_get()
        # create a raw fulfillment based on the current mint condition
        txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

        # get all signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        submit = txn.is_fulfilled()
        if submit:
            txn.id = self._transaction_put(transaction=txn)
            # update balance of wallet
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)

        # return the txn, as well as the submit status as a boolean
        return TransactionSendResult(txn, submit)

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _current_mint_condition_get(self):
        &#34;&#34;&#34;
        Get the current mind condition from the parent TFChain client.
        &#34;&#34;&#34;
        return self._wallet.client.minter.condition_get()

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.TFChainMinter.coins_new"><code class="name flex">
<span>def <span class="ident">coins_new</span></span>(<span>self, recipient, amount, lock=None, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create new (amount of) coins and give them to the defined recipient.
Arbitrary data can be attached as well if desired.</p>
<p>The recipient is one of:
- None: recipient is the Free-For-All wallet
- str (or unlockhash/bytes/bytearray): recipient is a personal wallet
- list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
- tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet</p>
<p>The amount can be a str or an int:
- when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
- when defining as a str you can use the following space-stripped and case-insentive formats:
- '123456789': same as when defining the amount as an int
- '123.456': define the amount in TFT (that is '123.456' == 123.456 TFT == 123456000000)
- '123456 TFT': define the amount in TFT (that is '123456 TFT' == 123456 TFT == 123456000000000)
- '123.456 TFT': define the amount in TFT (that is '123.456 TFT' == 123.456 TFT == 123456000000)</p>
<p>The lock can be a str, or int:
- when it is an int it represents either a block height or an epoch timestamp (in seconds)
- when a str it can be a Jumpscale Datetime (e.g. '12:00:10', '31/10/2012 12:30', &hellip;) or a Jumpscale Duration (e.g. '+ 2h', '+7d12h', &hellip;)</p>
<p>Returns a TransactionSendResult.</p>
<p>@param recipient: see explanation above
@param amount: int or str that defines the amount of TFT to set, see explanation above
@param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def coins_new(self, recipient, amount, lock=None, data=None):
    &#34;&#34;&#34;
    Create new (amount of) coins and give them to the defined recipient.
    Arbitrary data can be attached as well if desired.

    The recipient is one of:
        - None: recipient is the Free-For-All wallet
        - str (or unlockhash/bytes/bytearray): recipient is a personal wallet
        - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
        - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet

    The amount can be a str or an int:
        - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
        - when defining as a str you can use the following space-stripped and case-insentive formats:
            - &#39;123456789&#39;: same as when defining the amount as an int
            - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
            - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
            - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

    The lock can be a str, or int:
        - when it is an int it represents either a block height or an epoch timestamp (in seconds)
        - when a str it can be a Jumpscale Datetime (e.g. &#39;12:00:10&#39;, &#39;31/10/2012 12:30&#39;, ...) or a Jumpscale Duration (e.g. &#39;+ 2h&#39;, &#39;+7d12h&#39;, ...)

    Returns a TransactionSendResult.

    @param recipient: see explanation above
    @param amount: int or str that defines the amount of TFT to set, see explanation above
    @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    &#34;&#34;&#34;
    # create empty Mint Definition Txn, with a newly generated Nonce set already
    txn = tftransactions.mint_coin_creation_new()

    # add the minimum miner fee
    txn.miner_fee_add(self._minium_miner_fee)

    balance = self._wallet.balance

    # parse the output
    amount = Currency(value=amount)
    if amount &lt;= 0:
        raise ValueError(&#34;no amount is defined to be sent&#34;)

    # define recipient
    recipient = ConditionTypes.from_recipient(recipient, lock=lock)
    # and add it is the output
    txn.coin_output_add(value=amount, condition=recipient)

    # optionally set the data
    if data is not None:
        txn.data = data

    # get and set the current mint condition
    txn.parent_mint_condition = self._current_mint_condition_get()
    # create a raw fulfillment based on the current mint condition
    txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

    # get all signature requests
    sig_requests = txn.signature_requests_new()
    if len(sig_requests) == 0:
        raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

    # fulfill the signature requests that we can fulfill
    for request in sig_requests:
        try:
            key_pair = self._wallet.key_pair_get(request.wallet_address)
            input_hash = request.input_hash_new(public_key=key_pair.public_key)
            signature = key_pair.sign(input_hash)
            request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
        except KeyError:
            pass # this is acceptable due to how we directly try the key_pair_get method

    submit = txn.is_fulfilled()
    if submit:
        txn.id = self._transaction_put(transaction=txn)
        # update balance of wallet
        addresses = self._wallet.addresses + balance.addresses_multisig
        for idx, co in enumerate(txn.coin_outputs):
            if str(co.condition.unlockhash) in addresses:
                # add the id to the coin_output, so we can track it has been spent
                co.id = txn.coin_outputid_new(idx)
                balance.output_add(co, confirmed=False, spent=False)

    # return the txn, as well as the submit status as a boolean
    return TransactionSendResult(txn, submit)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainMinter.definition_set"><code class="name flex">
<span>def <span class="ident">definition_set</span></span>(<span>self, minter, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Redefine the current minter definition.
Arbitrary data can be attached as well if desired.</p>
<p>The minter is one of:
- str (or unlockhash): minter is a personal wallet
- list: minter is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
- tuple (addresses, sigcount): minter is a sigcount-of-addresscount MultiSig wallet</p>
<p>Returns a TransactionSendResult.</p>
<p>@param minter: see explanation above
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def definition_set(self, minter, data=None):
    &#34;&#34;&#34;
    Redefine the current minter definition.
    Arbitrary data can be attached as well if desired.

    The minter is one of:
        - str (or unlockhash): minter is a personal wallet
        - list: minter is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
        - tuple (addresses, sigcount): minter is a sigcount-of-addresscount MultiSig wallet

    Returns a TransactionSendResult.

    @param minter: see explanation above
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    &#34;&#34;&#34;
    # create empty Mint Definition Txn, with a newly generated Nonce set already
    txn = tftransactions.mint_definition_new()

    # add the minimum miner fee
    txn.miner_fee_add(self._minium_miner_fee)

    # set the new mint condition
    txn.mint_condition = ConditionTypes.from_recipient(minter)
    # minter definition must be of unlock type 1 or 3
    ut = txn.mint_condition.unlockhash.type
    if ut not in (UnlockHashType.PUBLIC_KEY, UnlockHashType.MULTI_SIG):
        raise ValueError(&#34;{} is an invalid unlock hash type and cannot be used for a minter definition&#34;.format(ut))

    # optionally set the data
    if data is not None:
        txn.data = data

    # get and set the current mint condition
    txn.parent_mint_condition = self._current_mint_condition_get()
    # create a raw fulfillment based on the current mint condition
    txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

    # get all signature requests
    sig_requests = txn.signature_requests_new()
    if len(sig_requests) == 0:
        raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

    # fulfill the signature requests that we can fulfill
    for request in sig_requests:
        try:
            key_pair = self._wallet.key_pair_get(request.wallet_address)
            input_hash = request.input_hash_new(public_key=key_pair.public_key)
            signature = key_pair.sign(input_hash)
            request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
        except KeyError:
            pass # this is acceptable due to how we directly try the key_pair_get method

    submit = txn.is_fulfilled()
    if submit:
        txn.id = self._transaction_put(transaction=txn)

    # return the txn, as well as the submit status as a boolean
    return TransactionSendResult(txn, submit)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TFChainThreeBot"><code class="flex name class">
<span>class <span class="ident">TFChainThreeBot</span></span>
<span>(</span><span>wallet)</span>
</code></dt>
<dd>
<section class="desc"><p>TFChainThreeBot contains all ThreeBot logic.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainThreeBot():
    &#34;&#34;&#34;
    TFChainThreeBot contains all ThreeBot logic.
    &#34;&#34;&#34;

    def __init__(self, wallet):
        if not isinstance(wallet, TFChainWallet):
            raise TypeError(&#34;wallet is expected to be a TFChainWallet&#34;)
        self._wallet = wallet

    def record_new(self, months=1, names=None, addresses=None, key_index=None, source=None, refund=None):
        &#34;&#34;&#34;
        Create a new 3Bot by creating a new record on the BlockChain,
        by default 1 month rent is already paid for the 3Bot, but up to 24 months can immediately be pre-paid
        against a discount if desired.

        At least one name or one address is required, and up to 5 names and 10 addresses can
        exists for a single 3Bot.

        If no key_index is given a new key pair is generated for the wallet,
        otherwise the key pair on the given index of the wallet is used.

        Returns a TransactionSendResult.

        @param months: amount of months to be prepaid, at least 1 month is required, maximum 24 months is allowed
        @param names: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
        @param addresses: Network Addresses used to reach the 3Bot (minimum 0, maximum 10)
        @param key_index: if None is given a new key pair is generated, otherwise the key pair on the defined index is used.
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        # create the txn and fill the easiest properties already
        txn = tftransactions.threebot_registration_new()
        txn.number_of_months = months
        if names is None and addresses is None:
            raise ValueError(&#34;at least one name or one address is to be given, none is defined&#34;)
        txn.names = names
        txn.addresses = addresses

        # get the fees, and fund the transaction
        balance = self._fund_txn(txn, source, refund)

        # if the key_index is not defined, generate a new public key,
        # otherwise use the key_index given
        if key_index is None:
            txn.public_key = self._wallet.public_key_new()
        else:
            if not isinstance(key_index, int):
                raise TypeError(&#34;key index is to be of type int, not type {}&#34;.format(type(key_index)))
            addresses = self._wallet.addresses
            if key_index &lt; 0 or key_index &gt;= len(addresses):
                raise ValueError(&#34;key index {} is OOB, index cannot be negative, and can be maximum {}&#34;.format(key_index, len(addresses)-1))
            txn.public_key = self._wallet.key_pair_get(unlockhash=addresses[key_index]).public_key

        # sign, submit, update Balance and return result
        return self._sign_and_submit_txn(txn, balance)

    def record_update(self, identifier, months=0, names_to_add=None, names_to_remove=None, addresses_to_add=None, addresses_to_remove=None, source=None, refund=None):
        &#34;&#34;&#34;
        Update the record of an existing 3Bot, for which this Wallet is authorized to make such changes.
        Names and addresses can be added and removed. Removal of data is always for free, adding data costs money.
        Extra months can also be paid (up to 24 months in total), as to extend the expiration time further in the future.

        One of months, names_to_add, names_to_remove, addresses_to_add, addresses_to_remove has to be a value other than 0/None.

        Returns a TransactionSendResult.

        @param months: amount of months to be paid and added to the current months, if the 3Bot was inactive, the starting time will be now
        @param names_to_add: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
        @param names_to_remove: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
        @param addresses_to_add: Network Addresses to add and used to reach the 3Bot (minimum 0, maximum 10)
        @param addresses_to_remove: Network Addresses to remove and used to reach the 3Bot (minimum 0, maximum 10)
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        if months &lt; 1 and not reduce((lambda r, v: r or (v is not None)), [names_to_add, names_to_remove, addresses_to_add, addresses_to_remove], False):
            raise ValueError(&#34;extra months is to be given or one name/address is to be added/removed, none is defined&#34;)

        # create the txn and fill the easiest properties already
        txn = tftransactions.threebot_record_update_new()
        txn.botid = identifier
        txn.number_of_months = months
        txn.names_to_add = names_to_add
        txn.names_to_remove = names_to_remove
        txn.addresses_to_add = addresses_to_add
        txn.addresses_to_remove = addresses_to_remove

        # get the 3Bot Public Key
        record = self._wallet.client.threebot.record_get(identifier)
        # set the parent public key
        txn.parent_public_key = record.public_key

        # ensure the 3Bot is either active, or will be come active
        if record.expiration &lt;= self._chain_time and months == 0:
            raise tfchain.errors.ThreeBotInactive(identifier, record.expiration)

        # get the fees, and fund the transaction
        balance = self._fund_txn(txn, source, refund)

        # sign, submit, update Balance and return result
        return self._sign_and_submit_txn(txn, balance)

    def name_transfer(self, sender, receiver, names, source=None, refund=None):
        &#34;&#34;&#34;
        Transfer one or multiple 3Bot names from the sender 3Bot to the receiver 3Bot.
        Both the Sender and Receiver 3Bots have to be active at the time of transfer.

        Returns a TransactionSendResult.

        @param sender: identifier of the existing and active 3Bot sender bot
        @param receiver: identifier of the existing and active 3Bot receiver bot
        @param names: 3Bot Names to transfer (minumum 0, maximum 5)
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        &#34;&#34;&#34;
        # create the txn and fill the easiest properties already
        txn = tftransactions.threebot_name_transfer_new()
        txn.sender_botid = sender
        txn.receiver_botid = receiver
        txn.names = names
        if len(txn.names) == 0:
            raise ValueError(&#34;at least one (3Bot) name has to be transfered, but none were defined&#34;)

        # keep track of chain time
        chain_time = self._chain_time

        # get and assign the 3Bot&#39;s public key for the sender
        record = self._wallet.client.threebot.record_get(sender)
        txn.sender_parent_public_key = record.public_key
        # ensure sender bot is active
        if record.expiration &lt;= chain_time:
            raise tfchain.errors.ThreeBotInactive(sender, record.expiration)

        # get and assign the 3Bot&#39;s public key for the receiver
        record = self._wallet.client.threebot.record_get(receiver)
        txn.receiver_parent_public_key = record.public_key
        # ensure receiver bot is active
        if record.expiration &lt;= chain_time:
            raise tfchain.errors.ThreeBotInactive(receiver, record.expiration)

        # get the fees, and fund the transaction
        balance = self._fund_txn(txn, source, refund)

        # sign and update Balance and return result,
        # only if the 3Bot owns both public keys, the Txn will be already,
        # submitted as well
        return self._sign_and_submit_txn(txn, balance)


    def _fund_txn(self, txn, source, refund):
        &#34;&#34;&#34;
        common fund/refund/inputs/fees logic for all 3Bot Transactions
        &#34;&#34;&#34;
        # get the fees, and fund the transaction
        miner_fee = self._minium_miner_fee
        bot_fee = txn.required_bot_fees
        balance = self._wallet.balance
        inputs, remainder, suggested_refund = balance.fund(miner_fee+bot_fee, source=source)

        # add the coin inputs
        txn.coin_inputs = inputs

        # add refund coin output if needed
        if remainder &gt; 0:
            # define the refund condition
            if refund is None: # automatically choose a refund condition if none is given
                if suggested_refund is None:
                    refund = ConditionTypes.unlockhash_new(unlockhash=self._wallet.address)
                else:
                    refund = suggested_refund
            else:
                # use the given refund condition (defined as a recipient)
                refund = ConditionTypes.from_recipient(refund)
            txn.refund_coin_output_set(value=remainder, condition=refund)
        # add the miner fee
        txn.transaction_fee = miner_fee

        # return balance object
        return balance

    def _sign_and_submit_txn(self, txn, balance):
        &#34;&#34;&#34;
        common sign and submit logic for all 3Bot Transactions
        &#34;&#34;&#34;
        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self._wallet.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self._wallet.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)
        # and return the created/submitted transaction for optional user consumption
        return TransactionSendResult(txn, submit)

    @property
    def _minium_miner_fee(self):
        &#34;&#34;&#34;
        Returns the minimum miner fee
        &#34;&#34;&#34;
        return self._wallet.client.minimum_miner_fee

    def _transaction_put(self, transaction):
        &#34;&#34;&#34;
        Submit the transaction to the network using the parent&#39;s wallet client.

        Returns the transaction ID.
        &#34;&#34;&#34;
        return self._wallet.client.transaction_put(transaction=transaction)

    @property
    def _chain_time(self):
        &#34;&#34;&#34;
        Returns the time according to the chain&#39;s network.
        &#34;&#34;&#34;
        info = self._wallet.client.blockchain_info_get()
        return info.timestamp</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.TFChainThreeBot.name_transfer"><code class="name flex">
<span>def <span class="ident">name_transfer</span></span>(<span>self, sender, receiver, names, source=None, refund=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Transfer one or multiple 3Bot names from the sender 3Bot to the receiver 3Bot.
Both the Sender and Receiver 3Bots have to be active at the time of transfer.</p>
<p>Returns a TransactionSendResult.</p>
<p>@param sender: identifier of the existing and active 3Bot sender bot
@param receiver: identifier of the existing and active 3Bot receiver bot
@param names: 3Bot Names to transfer (minumum 0, maximum 5)
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def name_transfer(self, sender, receiver, names, source=None, refund=None):
    &#34;&#34;&#34;
    Transfer one or multiple 3Bot names from the sender 3Bot to the receiver 3Bot.
    Both the Sender and Receiver 3Bots have to be active at the time of transfer.

    Returns a TransactionSendResult.

    @param sender: identifier of the existing and active 3Bot sender bot
    @param receiver: identifier of the existing and active 3Bot receiver bot
    @param names: 3Bot Names to transfer (minumum 0, maximum 5)
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    &#34;&#34;&#34;
    # create the txn and fill the easiest properties already
    txn = tftransactions.threebot_name_transfer_new()
    txn.sender_botid = sender
    txn.receiver_botid = receiver
    txn.names = names
    if len(txn.names) == 0:
        raise ValueError(&#34;at least one (3Bot) name has to be transfered, but none were defined&#34;)

    # keep track of chain time
    chain_time = self._chain_time

    # get and assign the 3Bot&#39;s public key for the sender
    record = self._wallet.client.threebot.record_get(sender)
    txn.sender_parent_public_key = record.public_key
    # ensure sender bot is active
    if record.expiration &lt;= chain_time:
        raise tfchain.errors.ThreeBotInactive(sender, record.expiration)

    # get and assign the 3Bot&#39;s public key for the receiver
    record = self._wallet.client.threebot.record_get(receiver)
    txn.receiver_parent_public_key = record.public_key
    # ensure receiver bot is active
    if record.expiration &lt;= chain_time:
        raise tfchain.errors.ThreeBotInactive(receiver, record.expiration)

    # get the fees, and fund the transaction
    balance = self._fund_txn(txn, source, refund)

    # sign and update Balance and return result,
    # only if the 3Bot owns both public keys, the Txn will be already,
    # submitted as well
    return self._sign_and_submit_txn(txn, balance)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainThreeBot.record_new"><code class="name flex">
<span>def <span class="ident">record_new</span></span>(<span>self, months=1, names=None, addresses=None, key_index=None, source=None, refund=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a new 3Bot by creating a new record on the BlockChain,
by default 1 month rent is already paid for the 3Bot, but up to 24 months can immediately be pre-paid
against a discount if desired.</p>
<p>At least one name or one address is required, and up to 5 names and 10 addresses can
exists for a single 3Bot.</p>
<p>If no key_index is given a new key pair is generated for the wallet,
otherwise the key pair on the given index of the wallet is used.</p>
<p>Returns a TransactionSendResult.</p>
<p>@param months: amount of months to be prepaid, at least 1 month is required, maximum 24 months is allowed
@param names: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
@param addresses: Network Addresses used to reach the 3Bot (minimum 0, maximum 10)
@param key_index: if None is given a new key pair is generated, otherwise the key pair on the defined index is used.
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def record_new(self, months=1, names=None, addresses=None, key_index=None, source=None, refund=None):
    &#34;&#34;&#34;
    Create a new 3Bot by creating a new record on the BlockChain,
    by default 1 month rent is already paid for the 3Bot, but up to 24 months can immediately be pre-paid
    against a discount if desired.

    At least one name or one address is required, and up to 5 names and 10 addresses can
    exists for a single 3Bot.

    If no key_index is given a new key pair is generated for the wallet,
    otherwise the key pair on the given index of the wallet is used.

    Returns a TransactionSendResult.

    @param months: amount of months to be prepaid, at least 1 month is required, maximum 24 months is allowed
    @param names: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
    @param addresses: Network Addresses used to reach the 3Bot (minimum 0, maximum 10)
    @param key_index: if None is given a new key pair is generated, otherwise the key pair on the defined index is used.
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    &#34;&#34;&#34;
    # create the txn and fill the easiest properties already
    txn = tftransactions.threebot_registration_new()
    txn.number_of_months = months
    if names is None and addresses is None:
        raise ValueError(&#34;at least one name or one address is to be given, none is defined&#34;)
    txn.names = names
    txn.addresses = addresses

    # get the fees, and fund the transaction
    balance = self._fund_txn(txn, source, refund)

    # if the key_index is not defined, generate a new public key,
    # otherwise use the key_index given
    if key_index is None:
        txn.public_key = self._wallet.public_key_new()
    else:
        if not isinstance(key_index, int):
            raise TypeError(&#34;key index is to be of type int, not type {}&#34;.format(type(key_index)))
        addresses = self._wallet.addresses
        if key_index &lt; 0 or key_index &gt;= len(addresses):
            raise ValueError(&#34;key index {} is OOB, index cannot be negative, and can be maximum {}&#34;.format(key_index, len(addresses)-1))
        txn.public_key = self._wallet.key_pair_get(unlockhash=addresses[key_index]).public_key

    # sign, submit, update Balance and return result
    return self._sign_and_submit_txn(txn, balance)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainThreeBot.record_update"><code class="name flex">
<span>def <span class="ident">record_update</span></span>(<span>self, identifier, months=0, names_to_add=None, names_to_remove=None, addresses_to_add=None, addresses_to_remove=None, source=None, refund=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Update the record of an existing 3Bot, for which this Wallet is authorized to make such changes.
Names and addresses can be added and removed. Removal of data is always for free, adding data costs money.
Extra months can also be paid (up to 24 months in total), as to extend the expiration time further in the future.</p>
<p>One of months, names_to_add, names_to_remove, addresses_to_add, addresses_to_remove has to be a value other than 0/None.</p>
<p>Returns a TransactionSendResult.</p>
<p>@param months: amount of months to be paid and added to the current months, if the 3Bot was inactive, the starting time will be now
@param names_to_add: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
@param names_to_remove: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
@param addresses_to_add: Network Addresses to add and used to reach the 3Bot (minimum 0, maximum 10)
@param addresses_to_remove: Network Addresses to remove and used to reach the 3Bot (minimum 0, maximum 10)
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def record_update(self, identifier, months=0, names_to_add=None, names_to_remove=None, addresses_to_add=None, addresses_to_remove=None, source=None, refund=None):
    &#34;&#34;&#34;
    Update the record of an existing 3Bot, for which this Wallet is authorized to make such changes.
    Names and addresses can be added and removed. Removal of data is always for free, adding data costs money.
    Extra months can also be paid (up to 24 months in total), as to extend the expiration time further in the future.

    One of months, names_to_add, names_to_remove, addresses_to_add, addresses_to_remove has to be a value other than 0/None.

    Returns a TransactionSendResult.

    @param months: amount of months to be paid and added to the current months, if the 3Bot was inactive, the starting time will be now
    @param names_to_add: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
    @param names_to_remove: 3Bot Names to add to the 3Bot as aliases (minumum 0, maximum 5)
    @param addresses_to_add: Network Addresses to add and used to reach the 3Bot (minimum 0, maximum 10)
    @param addresses_to_remove: Network Addresses to remove and used to reach the 3Bot (minimum 0, maximum 10)
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    &#34;&#34;&#34;
    if months &lt; 1 and not reduce((lambda r, v: r or (v is not None)), [names_to_add, names_to_remove, addresses_to_add, addresses_to_remove], False):
        raise ValueError(&#34;extra months is to be given or one name/address is to be added/removed, none is defined&#34;)

    # create the txn and fill the easiest properties already
    txn = tftransactions.threebot_record_update_new()
    txn.botid = identifier
    txn.number_of_months = months
    txn.names_to_add = names_to_add
    txn.names_to_remove = names_to_remove
    txn.addresses_to_add = addresses_to_add
    txn.addresses_to_remove = addresses_to_remove

    # get the 3Bot Public Key
    record = self._wallet.client.threebot.record_get(identifier)
    # set the parent public key
    txn.parent_public_key = record.public_key

    # ensure the 3Bot is either active, or will be come active
    if record.expiration &lt;= self._chain_time and months == 0:
        raise tfchain.errors.ThreeBotInactive(identifier, record.expiration)

    # get the fees, and fund the transaction
    balance = self._fund_txn(txn, source, refund)

    # sign, submit, update Balance and return result
    return self._sign_and_submit_txn(txn, balance)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet"><code class="flex name class">
<span>class <span class="ident">TFChainWallet</span></span>
<span>(</span><span>seed=None, key_count=1, key_start_index=0, key_scan_count=-1, client=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Tfchain Wallet object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TFChainWallet:
    &#34;&#34;&#34;
    Tfchain Wallet object
    &#34;&#34;&#34;

    def __init__(self, seed=None, key_count=1, key_start_index=0, key_scan_count=-1, client=None):
        # create TFChainClient used as the portal to the outside world
        self._client = client
        if self._client is None:
            self._client = tfchain.TFChainClient.TFChainClient()
        elif not isinstance(self._client, tfchain.TFChainClient.TFChainClient):
            raise TypeError(&#34;client has to be None or of type TFChainClient, not be of type {}&#34;.format(type(self._client)))

        # stores all key pairs of this wallet in memory
        self._key_pairs = {}
        # the primary address is kept as a seperate property,
        # as we hint the user into using this primary address as much as possible,
        # to keep things simple
        self._primary_address = &#39;&#39;

        # when during scanning we find a used key,
        # it might happen that one or more keys prior the used keys are not used,
        # in this case we do want to increase the key_count,
        # but will keep the unused keys in a seperate bucket, so we
        # can use them first
        self._unused_key_pairs = []

        # add seed
        self._mnemonic_api = mnemonic.Mnemonic(&#34;english&#34;)
        self._seed = seed
        if self._seed is None:
            self._seed = self._mnemonic_api.to_entropy(self._mnemonic_api.generate(strength=256))
        elif isinstance(self._seed, str):
            self._seed = self._mnemonic_api.to_entropy(self._seed)
        elif not isinstance (self._seed, (bytearray, bytes)):
            raise TypeError(&#34;seed has to be a mnemonic or raw (bytes) seed, not be of type {}&#34;.format(type(self._seed)))

        # add key count and key_start_index
        self._key_count = max(1, key_count)
        self._key_next_index = max(0, key_start_index)

        # define key scan count
        self._key_scan_count = max(-1, key_scan_count)
        if self._key_scan_count == -1:
            self._key_scan_count = _DEFAULT_KEY_SCAN_COUNT

        # generate keys
        keys_to_generate = self._key_count
        self._key_count = 0
        # generate the primary address
        self._primary_address = str(self._key_pair_new().unlockhash)
        # generate the other addresses
        for _ in range(keys_to_generate-1):
            self._key_pair_new()

        # add sub-apis
        self._minter = TFChainMinter(wallet=self)
        self._atomicswap = TFChainAtomicSwap(wallet=self)
        self._threebot = TFChainThreeBot(wallet=self)
        self._erc20 = TFChainERC20(wallet=self)

        # scan already for keys once
        self._key_scan()

    @property
    def seed(self):
        return self._seed

    @property
    def mnemonic(self):
        return self._mnemonic_api.to_mnemonic(self.seed)

    @property
    def key_count(self):
        return self._key_count

    @property
    def key_scan_count(self):
        return self._key_scan_count

    @property
    def minter(self):
        &#34;&#34;&#34;
        Minter used to update the (Coin) Minter Definition
        as well as to mint new coins, only useable if this wallet
        has (co-)ownership over the current (coin) minter definition.
        &#34;&#34;&#34;
        return self._minter

    @property
    def atomicswap(self):
        &#34;&#34;&#34;
        Atomic Swap API used to create atomic swap contracts as initiator or participator,
        as well as to redeem and refund existing unredeemed atomic swap contrats.
        &#34;&#34;&#34;
        return self._atomicswap

    @property
    def threebot(self):
        &#34;&#34;&#34;
        ThreeBot API used to register new 3Bots and
        manage existing 3Bot records.
        &#34;&#34;&#34;
        return self._threebot

    @property
    def erc20(self):
        &#34;&#34;&#34;
        ERC20 API used to send coins to ERC20 Addresses,
        and register TFT addresses that can than be used as ERC20 Withdraw addresses.
        &#34;&#34;&#34;
        return self._erc20

    @property
    def client(self):
        &#34;&#34;&#34;
        Returns the TFChain Client that is used by this wallet,
        and through which this wallet communicates with Explorer nodes.
        &#34;&#34;&#34;
        return self._client

    @property
    def network_type(self):
        &#34;&#34;&#34;
        The network type, defined by the parent TFChain client,
        that this wallet is operating on.

        Changing the network type has to be done from the parent TFChain client.
        &#34;&#34;&#34;
        return self.client.network

    @property
    def addresses(self):
        &#34;&#34;&#34;
        The addresses owned and used by this wallet.
        &#34;&#34;&#34;
        # key scan first
        _ = self._key_scan()
        # than list all addresses
        return list(self._key_pairs.keys())

    @property
    def address(self):
        &#34;&#34;&#34;
        The primary address, the address generated with index 0.
        &#34;&#34;&#34;
        return self._primary_address

    @property
    def addresses_multisig(self):
        &#34;&#34;&#34;
        The multi signature wallet addresses co-owned and linked to this wallet,
        as reported by the internal balance reporter.
        &#34;&#34;&#34;
        balance = self.balance
        return balance.addresses_multisig

    @property
    def balance(self):
        &#34;&#34;&#34;
        The balance &#34;sheet&#34; of the wallet.
        &#34;&#34;&#34;
        # key scan first
        _ = self._key_scan()

        # first get chain info
        info = self.client.blockchain_info_get()

        addresses = self.addresses
        balance = WalletsBalance()
        # collect info for all personal addresses
        multisig_addresses = []
        for address in addresses:
            try:
                # collect the inputs/outputs linked to this address for all found transactions
                result = self._unlockhash_get(address)
                uh_balance = result.balance(info=info)
                balance = balance.balance_add(uh_balance)
                # collect all multisig addresses
                for address in result.multisig_addresses:
                    multisig_addresses.append(str(address))
            except tfchain.errors.ExplorerNoContent:
                 # ignore this exception as it simply means
                 # the address has no activity yet on the chain
                pass

        # collect info for all multisig addresses
        for address in multisig_addresses:
            try:
                # collect the inputs/outputs linked to this address for all found transactions
                result = self._unlockhash_get(address)
                uh_balance = result.balance(info=info)
                balance = balance.balance_add(uh_balance)
            except tfchain.errors.ExplorerNoContent:
                 # ignore this exception as it simply means
                 # the address has no activity yet on the chain
                pass
        # ensure info is defined for wallet, even if no content
        balance.chain_blockid = info.blockid
        balance.chain_time = info.timestamp
        balance.chain_height = info.height
        # return the balance
        return balance

    @property
    def transactions(self):
        &#34;&#34;&#34;
        Get all transactions linked to a personal wallet address.
        &#34;&#34;&#34;
        # key scan first
        self._key_scan()

        # for each address get all transactions
        transactions = set()
        for address in self.addresses:
            result = self._unlockhash_get(address)
            transactions.update(result.transactions)

        # sort all transactions
        transactions = sorted(transactions, key=(lambda txn: sys.maxsize if txn.height &lt; 0 else txn.height), reverse=True)

        # return all transactions
        return transactions

    def _key_scan(self):
        # try some extra key scanning, to see if other keys have been used
        # if we already have unsused keys, no scanning is done however
        if len(self._unused_key_pairs) != 0 or self.key_scan_count == 0:
            return False

        # use the defined count
        count = self.key_scan_count
        # key track of start key count, so we can easily check at the end,
        # if we indeed scanned for any new keys
        key_count_start = self.key_count
        # generate the key pairs, without integrating them already
        # loop, and do this until now more are found:
        while True:
            pairs = []
            used_pairs = []
            for offset in range(count):
                pairs.append(self._key_pair_new(integrate=False, offset=offset))
            for pair in pairs:
                address = str(pair.unlockhash)
                try:
                    self._unlockhash_get(address)
                    # register this pair as a known index
                    used_pairs.append(True)
                except tfchain.errors.ExplorerNoContent:
                    # ignore this exception as it simply means
                    # the address has no activity yet on the chain
                    used_pairs.append(False)
                    pass
            # check if any address was found
            if not reduce(lambda a, b: a or b, used_pairs):
                break

            last_index = 0
            for idx, pair in enumerate(pairs):
                if used_pairs[idx]:
                    last_index = idx
                    self._key_pair_add(pair, add_count=False)
                else:
                    self._unused_key_pairs.append(pair)
            # remove the unused pairs that came after the last known index
            self._unused_key_pairs = self._unused_key_pairs[:-count+last_index]
            # update the new key count
            self._key_count += last_index + 1

            # if the last pair is not used, we can stop scanning
            if not used_pairs[-1]:
                break
            # otherwise continue

        # return if we scanned new keys
        return self.key_count &gt; key_count_start

    def coins_send(self, recipient, amount, source=None, refund=None, lock=None, data=None):
        &#34;&#34;&#34;
        Send the specified amount of coins to the given recipient,
        optionally locked. Arbitrary data can be attached as well if desired.

        If the given recipient is a valid ERC20 address, than this will send
        the specified amount to that ERC20 address and no lock or data is allowed to be defined.

        The recipient is one of:
            - None: recipient is the Free-For-All wallet
            - str (or unlockhash): recipient is a personal wallet
            - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
            - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
            - an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address

        The amount can be a str or an int:
            - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
            - when defining as a str you can use the following space-stripped and case-insentive formats:
                - &#39;123456789&#39;: same as when defining the amount as an int
                - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
                - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
                - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

        The lock can be a str, or int:
            - when it is an int it represents either a block height or an epoch timestamp (in seconds)
            - when a str it can be a Jumpscale Datetime (e.g. &#39;12:00:10&#39;, &#39;31/10/2012 12:30&#39;, ...) or a Jumpscale Duration (e.g. &#39;+ 2h&#39;, &#39;+7d12h&#39;, ...)

        Returns a TransactionSendResult.

        @param recipient: see explanation above
        @param amount: int or str that defines the amount of TFT to set, see explanation above
        @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
        @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
        @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
        @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
        &#34;&#34;&#34;
        if ERC20Address.is_valid_value(recipient):
            if lock is not None:
                raise ValueError(&#34;a lock cannot be applied when sending coins to an ERC20 Address&#34;)
            if data is not None:
                raise ValueError(&#34;data cannot be added to the transaction when sending coins to an ERC20 Address&#34;)
            # all good, try to send to the ERC20 address
            return self.erc20.coins_send(address=recipient, amount=amount, source=source, refund=refund)

        amount = Currency(value=amount)
        if amount &lt;= 0:
            raise ValueError(&#34;no amount is defined to be sent&#34;)

        # define recipient
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)

        # fund amount
        balance = self.balance
        miner_fee = self.client.minimum_miner_fee
        inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

        # define the refund condition
        if refund is None: # automatically choose a refund condition if none is given
            if suggested_refund is None:
                refund = ConditionTypes.unlockhash_new(unlockhash=self.address)
            else:
                refund = suggested_refund
        else:
            # use the given refund condition (defined as a recipient)
            refund = ConditionTypes.from_recipient(refund)

        # create transaction
        txn = tftransactions.new()
        # add main coin output
        txn.coin_output_add(value=amount, condition=recipient)
        # add refund coin output if needed
        if remainder &gt; 0:
            txn.coin_output_add(value=remainder, condition=refund)
        # add the miner fee
        txn.miner_fee_add(miner_fee)

        # add the coin inputs
        txn.coin_inputs = inputs

        # if there is data to be added, add it as well
        if data:
            txn.data = data

        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

        # fulfill the signature requests that we can fulfill
        for request in sig_requests:
            try:
                key_pair = self.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # txn should be fulfilled now
        submit = txn.is_fulfilled()
        if submit:
            # submit the transaction
            txn.id = self._transaction_put(transaction=txn)

            # update balance
            for ci in txn.coin_inputs:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
            addresses = self.addresses + balance.addresses_multisig
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)
            # and return the created/submitted transaction for optional user consumption

        return TransactionSendResult(txn, submit)

    def coin_transaction_builder_new(self):
        &#34;&#34;&#34;
        Create a transaction builder that can be used to
        add multiple outputs, in a chained manner, and send them all at once.

        ERC20 coin outputs are not supported in the Coin Transaction Builder.
        &#34;&#34;&#34;
        return CoinTransactionBuilder(self)

    def transaction_sign(self, txn, submit=True):
        &#34;&#34;&#34;
        Sign in all places of the transaction where it is still possible,
        and on which the wallet has authority to do so.

        Returns a TransactionSignResult.

        @param txn: transaction to sign, a JSON-encoded txn or already loaded in-memory as a valid Transaction type
        &#34;&#34;&#34;
        # validate and/or normalize txn parameter
        if isinstance(txn, (str, dict)):
            txn = tftransactions.from_json(txn)
        elif not isinstance(txn, TransactionBaseClass):
            raise TypeError(&#34;txn value has invalid type {} and cannot be signed&#34;.format(type(txn)))

        balance = self.balance

        # check all parentids from the specified coin inputs,
        # and set the coin outputs for the ones this wallet knows about
        # and that are still unspent
        if len(txn.coin_inputs) &gt; 0:
            # collect all known outputs
            known_outputs = {}
            for co in balance.outputs_available:
                known_outputs[co.id] = co
            for co in balance.outputs_unconfirmed_available:
                known_outputs[co.id] = co
            for wallet in balance.wallets.values():
                for co in wallet.outputs_available:
                    known_outputs[co.id] = co
                for co in wallet.outputs_unconfirmed_available:
                    known_outputs[co.id] = co
            # mark the coin inputs that are known as available outputs by this wallet
            for ci in txn.coin_inputs:
                if ci.parentid in known_outputs:
                    ci.parent_output = known_outputs[ci.parentid]

        # check for specific transaction types, as to
        # be able to add whatever content we know we can add
        if isinstance(txn, (TransactionV128, TransactionV129)):
            # set the parent mint condition
            txn.parent_mint_condition = self.client.minter.condition_get()
            # define the current fulfillment if it is not defined
            if not txn.mint_fulfillment_defined():
                txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

        # generate the signature requests
        sig_requests = txn.signature_requests_new()
        if len(sig_requests) == 0:
            # possible if the wallet does not own any of the still required signatures,
            # or for example because the wallet does not know about the parent outputs of
            # the inputs still to be signed
            return TransactionSignResult(txn, False, False)

        # fulfill the signature requests that we can fulfill
        signature_count = 0
        for request in sig_requests:
            try:
                key_pair = self.key_pair_get(request.wallet_address)
                input_hash = request.input_hash_new(public_key=key_pair.public_key)
                signature = key_pair.sign(input_hash)
                request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
                signature_count += 1
            except KeyError:
                pass # this is acceptable due to how we directly try the key_pair_get method

        # check if fulfilled, and if so, we&#39;ll submit unless the callee does not want that
        is_fulfilled = txn.is_fulfilled()
        submit = (submit and is_fulfilled)
        if submit:
            txn.id = self._transaction_put(transaction=txn)
            addresses = self.addresses + balance.addresses_multisig
            # update balance
            for ci in txn.coin_inputs:
                if str(ci.parent_output.condition.unlockhash) in addresses:
                    balance.output_add(ci.parent_output, confirmed=False, spent=True)
            for idx, co in enumerate(txn.coin_outputs):
                if str(co.condition.unlockhash) in addresses:
                    # add the id to the coin_output, so we can track it has been spent
                    co.id = txn.coin_outputid_new(idx)
                    balance.output_add(co, confirmed=False, spent=False)

        # return up-to-date Txn, as well as if we signed and submitted
        return TransactionSignResult(txn, (signature_count&gt;0), submit)

    def address_new(self):
        &#34;&#34;&#34;
        Generate a new wallet address,
        using the wallet&#39;s seed and the current key index as input.

        An address, also known as unlock hash,
        is a blake2 hash of the public key that is linked to a private key.
        The public key is used for verification of signatures,
        that were created with the matching private key.
        &#34;&#34;&#34;
        return str(self._key_pair_new().unlockhash)

    def public_key_new(self):
        &#34;&#34;&#34;
        Generate a new wallet public key,
        using the wallet&#39;s seed and the current key index as input.
        &#34;&#34;&#34;
        return self._key_pair_new().public_key

    def key_pair_get(self, unlockhash):
        &#34;&#34;&#34;
        Get the private/public key pair for the given unlock hash.
        If the unlock has is not owned by this wallet a KeyError exception is raised.
        &#34;&#34;&#34;
        if not isinstance(unlockhash, (str, UnlockHash)):
            raise TypeError(&#34;unlockhash cannot be of type {}&#34;.format(type(unlockhash)))
        unlockhash = str(unlockhash)
        if unlockhash[:2] == &#39;00&#39;:
            key = self._key_pairs.get(self.address)
        else:
            key = self._key_pairs.get(unlockhash)
        if key is None:
            raise KeyError(&#34;wallet does not own unlock hash {}&#34;.format(unlockhash))
        return key

    def _unlockhash_get(self, address):
        return self.client.unlockhash_get(address)

    def _transaction_put(self, transaction):
        return self.client.transaction_put(transaction)

    def _key_pair_new(self, integrate=True, offset=0):
        &#34;&#34;&#34;
        Create a new key pair,
        and integrate it by default as well into the wallet&#39;s key pair dictionary.
        &#34;&#34;&#34;
        # if we have unused key pairs in-memory, use them first,
        # only used when integrating is True,
        # as we do not wish to use this feature when scanning
        if integrate and len(self._unused_key_pairs) &gt; 0:
            key_pair = self._unused_key_pairs.pop(0)
            self._key_pair_add(key_pair, add_count=False)
            return key_pair

        # otherwise create a new one
        e = encoder_sia_get()
        e.add_array(self.seed)
        e.add(self.key_count+offset)
        seed_hash = blake2(e.data)
        private_key = SigningKey(seed_hash)
        public_key = private_key.get_verifying_key()

        key_pair = SpendableKey(
            public_key = PublicKey(specifier=PublicKeySpecifier.ED25519, hash=public_key.to_bytes()),
            private_key = private_key)

        # if we wish to integrate (mostly when we&#39;re not scanning),
        # we also add it to our wallets known key pairs
        if integrate:
            self._key_pair_add(key_pair, add_count=True, offset=offset)

        return key_pair

    def _key_pair_add(self, key_pair, add_count=True, offset=0):
        &#34;&#34;&#34;
        A private utility function that is used by default
        by the _key_pair_new wallet method to integrate a newly created key pair
        into this wallet&#39;s key pair dictionary.

        This method is seperate as we also scan for other keys during the fetching
        of the balance of a wallet. When we do, we want to create new key pairs,
        but only integrate them, if indeed we found the key (or a key after it) was used.
        &#34;&#34;&#34;
        addr = str(key_pair.unlockhash)
        if addr in self._key_pairs:
            raise KeyError(&#34;wallet already contains a key pair for unlock hash {}&#34;.format(addr))
        self._key_pairs[addr] = key_pair
        if add_count:
            self._key_count += 1+offset</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.TFChainWallet.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"><p>The primary address, the address generated with index 0.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def address(self):
    &#34;&#34;&#34;
    The primary address, the address generated with index 0.
    &#34;&#34;&#34;
    return self._primary_address</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.addresses"><code class="name">var <span class="ident">addresses</span></code></dt>
<dd>
<section class="desc"><p>The addresses owned and used by this wallet.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def addresses(self):
    &#34;&#34;&#34;
    The addresses owned and used by this wallet.
    &#34;&#34;&#34;
    # key scan first
    _ = self._key_scan()
    # than list all addresses
    return list(self._key_pairs.keys())</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.addresses_multisig"><code class="name">var <span class="ident">addresses_multisig</span></code></dt>
<dd>
<section class="desc"><p>The multi signature wallet addresses co-owned and linked to this wallet,
as reported by the internal balance reporter.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def addresses_multisig(self):
    &#34;&#34;&#34;
    The multi signature wallet addresses co-owned and linked to this wallet,
    as reported by the internal balance reporter.
    &#34;&#34;&#34;
    balance = self.balance
    return balance.addresses_multisig</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.atomicswap"><code class="name">var <span class="ident">atomicswap</span></code></dt>
<dd>
<section class="desc"><p>Atomic Swap API used to create atomic swap contracts as initiator or participator,
as well as to redeem and refund existing unredeemed atomic swap contrats.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def atomicswap(self):
    &#34;&#34;&#34;
    Atomic Swap API used to create atomic swap contracts as initiator or participator,
    as well as to redeem and refund existing unredeemed atomic swap contrats.
    &#34;&#34;&#34;
    return self._atomicswap</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.balance"><code class="name">var <span class="ident">balance</span></code></dt>
<dd>
<section class="desc"><p>The balance "sheet" of the wallet.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def balance(self):
    &#34;&#34;&#34;
    The balance &#34;sheet&#34; of the wallet.
    &#34;&#34;&#34;
    # key scan first
    _ = self._key_scan()

    # first get chain info
    info = self.client.blockchain_info_get()

    addresses = self.addresses
    balance = WalletsBalance()
    # collect info for all personal addresses
    multisig_addresses = []
    for address in addresses:
        try:
            # collect the inputs/outputs linked to this address for all found transactions
            result = self._unlockhash_get(address)
            uh_balance = result.balance(info=info)
            balance = balance.balance_add(uh_balance)
            # collect all multisig addresses
            for address in result.multisig_addresses:
                multisig_addresses.append(str(address))
        except tfchain.errors.ExplorerNoContent:
             # ignore this exception as it simply means
             # the address has no activity yet on the chain
            pass

    # collect info for all multisig addresses
    for address in multisig_addresses:
        try:
            # collect the inputs/outputs linked to this address for all found transactions
            result = self._unlockhash_get(address)
            uh_balance = result.balance(info=info)
            balance = balance.balance_add(uh_balance)
        except tfchain.errors.ExplorerNoContent:
             # ignore this exception as it simply means
             # the address has no activity yet on the chain
            pass
    # ensure info is defined for wallet, even if no content
    balance.chain_blockid = info.blockid
    balance.chain_time = info.timestamp
    balance.chain_height = info.height
    # return the balance
    return balance</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.client"><code class="name">var <span class="ident">client</span></code></dt>
<dd>
<section class="desc"><p>Returns the TFChain Client that is used by this wallet,
and through which this wallet communicates with Explorer nodes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def client(self):
    &#34;&#34;&#34;
    Returns the TFChain Client that is used by this wallet,
    and through which this wallet communicates with Explorer nodes.
    &#34;&#34;&#34;
    return self._client</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.erc20"><code class="name">var <span class="ident">erc20</span></code></dt>
<dd>
<section class="desc"><p>ERC20 API used to send coins to ERC20 Addresses,
and register TFT addresses that can than be used as ERC20 Withdraw addresses.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def erc20(self):
    &#34;&#34;&#34;
    ERC20 API used to send coins to ERC20 Addresses,
    and register TFT addresses that can than be used as ERC20 Withdraw addresses.
    &#34;&#34;&#34;
    return self._erc20</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.key_count"><code class="name">var <span class="ident">key_count</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def key_count(self):
    return self._key_count</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.key_scan_count"><code class="name">var <span class="ident">key_scan_count</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def key_scan_count(self):
    return self._key_scan_count</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.minter"><code class="name">var <span class="ident">minter</span></code></dt>
<dd>
<section class="desc"><p>Minter used to update the (Coin) Minter Definition
as well as to mint new coins, only useable if this wallet
has (co-)ownership over the current (coin) minter definition.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def minter(self):
    &#34;&#34;&#34;
    Minter used to update the (Coin) Minter Definition
    as well as to mint new coins, only useable if this wallet
    has (co-)ownership over the current (coin) minter definition.
    &#34;&#34;&#34;
    return self._minter</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.mnemonic"><code class="name">var <span class="ident">mnemonic</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def mnemonic(self):
    return self._mnemonic_api.to_mnemonic(self.seed)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.network_type"><code class="name">var <span class="ident">network_type</span></code></dt>
<dd>
<section class="desc"><p>The network type, defined by the parent TFChain client,
that this wallet is operating on.</p>
<p>Changing the network type has to be done from the parent TFChain client.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def network_type(self):
    &#34;&#34;&#34;
    The network type, defined by the parent TFChain client,
    that this wallet is operating on.

    Changing the network type has to be done from the parent TFChain client.
    &#34;&#34;&#34;
    return self.client.network</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.seed"><code class="name">var <span class="ident">seed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def seed(self):
    return self._seed</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.threebot"><code class="name">var <span class="ident">threebot</span></code></dt>
<dd>
<section class="desc"><p>ThreeBot API used to register new 3Bots and
manage existing 3Bot records.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def threebot(self):
    &#34;&#34;&#34;
    ThreeBot API used to register new 3Bots and
    manage existing 3Bot records.
    &#34;&#34;&#34;
    return self._threebot</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.transactions"><code class="name">var <span class="ident">transactions</span></code></dt>
<dd>
<section class="desc"><p>Get all transactions linked to a personal wallet address.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transactions(self):
    &#34;&#34;&#34;
    Get all transactions linked to a personal wallet address.
    &#34;&#34;&#34;
    # key scan first
    self._key_scan()

    # for each address get all transactions
    transactions = set()
    for address in self.addresses:
        result = self._unlockhash_get(address)
        transactions.update(result.transactions)

    # sort all transactions
    transactions = sorted(transactions, key=(lambda txn: sys.maxsize if txn.height &lt; 0 else txn.height), reverse=True)

    # return all transactions
    return transactions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.TFChainWallet.address_new"><code class="name flex">
<span>def <span class="ident">address_new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate a new wallet address,
using the wallet's seed and the current key index as input.</p>
<p>An address, also known as unlock hash,
is a blake2 hash of the public key that is linked to a private key.
The public key is used for verification of signatures,
that were created with the matching private key.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def address_new(self):
    &#34;&#34;&#34;
    Generate a new wallet address,
    using the wallet&#39;s seed and the current key index as input.

    An address, also known as unlock hash,
    is a blake2 hash of the public key that is linked to a private key.
    The public key is used for verification of signatures,
    that were created with the matching private key.
    &#34;&#34;&#34;
    return str(self._key_pair_new().unlockhash)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.coin_transaction_builder_new"><code class="name flex">
<span>def <span class="ident">coin_transaction_builder_new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a transaction builder that can be used to
add multiple outputs, in a chained manner, and send them all at once.</p>
<p>ERC20 coin outputs are not supported in the Coin Transaction Builder.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def coin_transaction_builder_new(self):
    &#34;&#34;&#34;
    Create a transaction builder that can be used to
    add multiple outputs, in a chained manner, and send them all at once.

    ERC20 coin outputs are not supported in the Coin Transaction Builder.
    &#34;&#34;&#34;
    return CoinTransactionBuilder(self)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.coins_send"><code class="name flex">
<span>def <span class="ident">coins_send</span></span>(<span>self, recipient, amount, source=None, refund=None, lock=None, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send the specified amount of coins to the given recipient,
optionally locked. Arbitrary data can be attached as well if desired.</p>
<p>If the given recipient is a valid ERC20 address, than this will send
the specified amount to that ERC20 address and no lock or data is allowed to be defined.</p>
<p>The recipient is one of:
- None: recipient is the Free-For-All wallet
- str (or unlockhash): recipient is a personal wallet
- list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
- tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
- an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address</p>
<p>The amount can be a str or an int:
- when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
- when defining as a str you can use the following space-stripped and case-insentive formats:
- '123456789': same as when defining the amount as an int
- '123.456': define the amount in TFT (that is '123.456' == 123.456 TFT == 123456000000)
- '123456 TFT': define the amount in TFT (that is '123456 TFT' == 123456 TFT == 123456000000000)
- '123.456 TFT': define the amount in TFT (that is '123.456 TFT' == 123.456 TFT == 123456000000)</p>
<p>The lock can be a str, or int:
- when it is an int it represents either a block height or an epoch timestamp (in seconds)
- when a str it can be a Jumpscale Datetime (e.g. '12:00:10', '31/10/2012 12:30', &hellip;) or a Jumpscale Duration (e.g. '+ 2h', '+7d12h', &hellip;)</p>
<p>Returns a TransactionSendResult.</p>
<p>@param recipient: see explanation above
@param amount: int or str that defines the amount of TFT to set, see explanation above
@param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
@param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
@param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
@param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def coins_send(self, recipient, amount, source=None, refund=None, lock=None, data=None):
    &#34;&#34;&#34;
    Send the specified amount of coins to the given recipient,
    optionally locked. Arbitrary data can be attached as well if desired.

    If the given recipient is a valid ERC20 address, than this will send
    the specified amount to that ERC20 address and no lock or data is allowed to be defined.

    The recipient is one of:
        - None: recipient is the Free-For-All wallet
        - str (or unlockhash): recipient is a personal wallet
        - list: recipient is a MultiSig wallet where all owners (specified as a list of addresses) have to sign
        - tuple (addresses, sigcount): recipient is a sigcount-of-addresscount MultiSig wallet
        - an ERC20 address (str/ERC20Address), amount will be send to this ERC20 address

    The amount can be a str or an int:
        - when it is an int, you are defining the amount in the smallest unit (that is 1 == 0.000000001 TFT)
        - when defining as a str you can use the following space-stripped and case-insentive formats:
            - &#39;123456789&#39;: same as when defining the amount as an int
            - &#39;123.456&#39;: define the amount in TFT (that is &#39;123.456&#39; == 123.456 TFT == 123456000000)
            - &#39;123456 TFT&#39;: define the amount in TFT (that is &#39;123456 TFT&#39; == 123456 TFT == 123456000000000)
            - &#39;123.456 TFT&#39;: define the amount in TFT (that is &#39;123.456 TFT&#39; == 123.456 TFT == 123456000000)

    The lock can be a str, or int:
        - when it is an int it represents either a block height or an epoch timestamp (in seconds)
        - when a str it can be a Jumpscale Datetime (e.g. &#39;12:00:10&#39;, &#39;31/10/2012 12:30&#39;, ...) or a Jumpscale Duration (e.g. &#39;+ 2h&#39;, &#39;+7d12h&#39;, ...)

    Returns a TransactionSendResult.

    @param recipient: see explanation above
    @param amount: int or str that defines the amount of TFT to set, see explanation above
    @param source: one or multiple addresses/unlockhashes from which to fund this coin send transaction, by default all personal wallet addresses are used, only known addresses can be used
    @param refund: optional refund address, by default is uses the source if it specifies a single address otherwise it uses the default wallet address (recipient type, with None being the exception in its interpretation)
    @param lock: optional lock that can be used to lock the sent amount to a specific time or block height, see explation above
    @param data: optional data that can be attached ot the sent transaction (str or bytes), with a max length of 83
    &#34;&#34;&#34;
    if ERC20Address.is_valid_value(recipient):
        if lock is not None:
            raise ValueError(&#34;a lock cannot be applied when sending coins to an ERC20 Address&#34;)
        if data is not None:
            raise ValueError(&#34;data cannot be added to the transaction when sending coins to an ERC20 Address&#34;)
        # all good, try to send to the ERC20 address
        return self.erc20.coins_send(address=recipient, amount=amount, source=source, refund=refund)

    amount = Currency(value=amount)
    if amount &lt;= 0:
        raise ValueError(&#34;no amount is defined to be sent&#34;)

    # define recipient
    recipient = ConditionTypes.from_recipient(recipient, lock=lock)

    # fund amount
    balance = self.balance
    miner_fee = self.client.minimum_miner_fee
    inputs, remainder, suggested_refund = balance.fund(amount+miner_fee, source=source)

    # define the refund condition
    if refund is None: # automatically choose a refund condition if none is given
        if suggested_refund is None:
            refund = ConditionTypes.unlockhash_new(unlockhash=self.address)
        else:
            refund = suggested_refund
    else:
        # use the given refund condition (defined as a recipient)
        refund = ConditionTypes.from_recipient(refund)

    # create transaction
    txn = tftransactions.new()
    # add main coin output
    txn.coin_output_add(value=amount, condition=recipient)
    # add refund coin output if needed
    if remainder &gt; 0:
        txn.coin_output_add(value=remainder, condition=refund)
    # add the miner fee
    txn.miner_fee_add(miner_fee)

    # add the coin inputs
    txn.coin_inputs = inputs

    # if there is data to be added, add it as well
    if data:
        txn.data = data

    # generate the signature requests
    sig_requests = txn.signature_requests_new()
    if len(sig_requests) == 0:
        raise Exception(&#34;BUG: sig requests should not be empty at this point, please fix or report as an issue&#34;)

    # fulfill the signature requests that we can fulfill
    for request in sig_requests:
        try:
            key_pair = self.key_pair_get(request.wallet_address)
            input_hash = request.input_hash_new(public_key=key_pair.public_key)
            signature = key_pair.sign(input_hash)
            request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
        except KeyError:
            pass # this is acceptable due to how we directly try the key_pair_get method

    # txn should be fulfilled now
    submit = txn.is_fulfilled()
    if submit:
        # submit the transaction
        txn.id = self._transaction_put(transaction=txn)

        # update balance
        for ci in txn.coin_inputs:
            balance.output_add(ci.parent_output, confirmed=False, spent=True)
        addresses = self.addresses + balance.addresses_multisig
        for idx, co in enumerate(txn.coin_outputs):
            if str(co.condition.unlockhash) in addresses:
                # add the id to the coin_output, so we can track it has been spent
                co.id = txn.coin_outputid_new(idx)
                balance.output_add(co, confirmed=False, spent=False)
        # and return the created/submitted transaction for optional user consumption

    return TransactionSendResult(txn, submit)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.key_pair_get"><code class="name flex">
<span>def <span class="ident">key_pair_get</span></span>(<span>self, unlockhash)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the private/public key pair for the given unlock hash.
If the unlock has is not owned by this wallet a KeyError exception is raised.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def key_pair_get(self, unlockhash):
    &#34;&#34;&#34;
    Get the private/public key pair for the given unlock hash.
    If the unlock has is not owned by this wallet a KeyError exception is raised.
    &#34;&#34;&#34;
    if not isinstance(unlockhash, (str, UnlockHash)):
        raise TypeError(&#34;unlockhash cannot be of type {}&#34;.format(type(unlockhash)))
    unlockhash = str(unlockhash)
    if unlockhash[:2] == &#39;00&#39;:
        key = self._key_pairs.get(self.address)
    else:
        key = self._key_pairs.get(unlockhash)
    if key is None:
        raise KeyError(&#34;wallet does not own unlock hash {}&#34;.format(unlockhash))
    return key</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.public_key_new"><code class="name flex">
<span>def <span class="ident">public_key_new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate a new wallet public key,
using the wallet's seed and the current key index as input.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def public_key_new(self):
    &#34;&#34;&#34;
    Generate a new wallet public key,
    using the wallet&#39;s seed and the current key index as input.
    &#34;&#34;&#34;
    return self._key_pair_new().public_key</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TFChainWallet.transaction_sign"><code class="name flex">
<span>def <span class="ident">transaction_sign</span></span>(<span>self, txn, submit=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Sign in all places of the transaction where it is still possible,
and on which the wallet has authority to do so.</p>
<p>Returns a TransactionSignResult.</p>
<p>@param txn: transaction to sign, a JSON-encoded txn or already loaded in-memory as a valid Transaction type</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def transaction_sign(self, txn, submit=True):
    &#34;&#34;&#34;
    Sign in all places of the transaction where it is still possible,
    and on which the wallet has authority to do so.

    Returns a TransactionSignResult.

    @param txn: transaction to sign, a JSON-encoded txn or already loaded in-memory as a valid Transaction type
    &#34;&#34;&#34;
    # validate and/or normalize txn parameter
    if isinstance(txn, (str, dict)):
        txn = tftransactions.from_json(txn)
    elif not isinstance(txn, TransactionBaseClass):
        raise TypeError(&#34;txn value has invalid type {} and cannot be signed&#34;.format(type(txn)))

    balance = self.balance

    # check all parentids from the specified coin inputs,
    # and set the coin outputs for the ones this wallet knows about
    # and that are still unspent
    if len(txn.coin_inputs) &gt; 0:
        # collect all known outputs
        known_outputs = {}
        for co in balance.outputs_available:
            known_outputs[co.id] = co
        for co in balance.outputs_unconfirmed_available:
            known_outputs[co.id] = co
        for wallet in balance.wallets.values():
            for co in wallet.outputs_available:
                known_outputs[co.id] = co
            for co in wallet.outputs_unconfirmed_available:
                known_outputs[co.id] = co
        # mark the coin inputs that are known as available outputs by this wallet
        for ci in txn.coin_inputs:
            if ci.parentid in known_outputs:
                ci.parent_output = known_outputs[ci.parentid]

    # check for specific transaction types, as to
    # be able to add whatever content we know we can add
    if isinstance(txn, (TransactionV128, TransactionV129)):
        # set the parent mint condition
        txn.parent_mint_condition = self.client.minter.condition_get()
        # define the current fulfillment if it is not defined
        if not txn.mint_fulfillment_defined():
            txn.mint_fulfillment = FulfillmentTypes.from_condition(txn.parent_mint_condition)

    # generate the signature requests
    sig_requests = txn.signature_requests_new()
    if len(sig_requests) == 0:
        # possible if the wallet does not own any of the still required signatures,
        # or for example because the wallet does not know about the parent outputs of
        # the inputs still to be signed
        return TransactionSignResult(txn, False, False)

    # fulfill the signature requests that we can fulfill
    signature_count = 0
    for request in sig_requests:
        try:
            key_pair = self.key_pair_get(request.wallet_address)
            input_hash = request.input_hash_new(public_key=key_pair.public_key)
            signature = key_pair.sign(input_hash)
            request.signature_fulfill(public_key=key_pair.public_key, signature=signature)
            signature_count += 1
        except KeyError:
            pass # this is acceptable due to how we directly try the key_pair_get method

    # check if fulfilled, and if so, we&#39;ll submit unless the callee does not want that
    is_fulfilled = txn.is_fulfilled()
    submit = (submit and is_fulfilled)
    if submit:
        txn.id = self._transaction_put(transaction=txn)
        addresses = self.addresses + balance.addresses_multisig
        # update balance
        for ci in txn.coin_inputs:
            if str(ci.parent_output.condition.unlockhash) in addresses:
                balance.output_add(ci.parent_output, confirmed=False, spent=True)
        for idx, co in enumerate(txn.coin_outputs):
            if str(co.condition.unlockhash) in addresses:
                # add the id to the coin_output, so we can track it has been spent
                co.id = txn.coin_outputid_new(idx)
                balance.output_add(co, confirmed=False, spent=False)

    # return up-to-date Txn, as well as if we signed and submitted
    return TransactionSignResult(txn, (signature_count&gt;0), submit)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TransactionSendResult"><code class="flex name class">
<span>class <span class="ident">TransactionSendResult</span></span>
<span>(</span><span>transaction, submitted)</span>
</code></dt>
<dd>
<section class="desc"><p>TransactionSendResult is a named tuple,
used as the result for a generic transaction send call.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TransactionSendResult():
    &#34;&#34;&#34;
    TransactionSendResult is a named tuple,
    used as the result for a generic transaction send call.
    &#34;&#34;&#34;
    def __init__(self, transaction, submitted):
        self._transaction = transaction
        self._submitted = submitted

    @property
    def transaction(self):
        return self._transaction
    @property
    def submitted(self):
        return self._submitted</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.TransactionSendResult.submitted"><code class="name">var <span class="ident">submitted</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def submitted(self):
    return self._submitted</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TransactionSendResult.transaction"><code class="name">var <span class="ident">transaction</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transaction(self):
    return self._transaction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.TransactionSignResult"><code class="flex name class">
<span>class <span class="ident">TransactionSignResult</span></span>
<span>(</span><span>transaction, signed, submitted)</span>
</code></dt>
<dd>
<section class="desc"><p>TransactionSignResult is a named tuple,
used as the result for a transaction sign call.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TransactionSignResult():
    &#34;&#34;&#34;
    TransactionSignResult is a named tuple,
    used as the result for a transaction sign call.
    &#34;&#34;&#34;
    def __init__(self, transaction, signed, submitted):
        self._transaction = transaction
        self._signed = signed
        self._submitted = submitted

    @property
    def transaction(self):
        return self._transaction
    @property
    def signed(self):
        return self._signed
    @property
    def submitted(self):
        return self._submitted</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.TransactionSignResult.signed"><code class="name">var <span class="ident">signed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def signed(self):
    return self._signed</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TransactionSignResult.submitted"><code class="name">var <span class="ident">submitted</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def submitted(self):
    return self._submitted</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.TransactionSignResult.transaction"><code class="name">var <span class="ident">transaction</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def transaction(self):
    return self._transaction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance"><code class="flex name class">
<span>class <span class="ident">WalletBalance</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class WalletBalance(object):
    def __init__(self):
        # personal wallet outputs
        self._outputs = {}
        self._outputs_spent = {}
        self._outputs_unconfirmed = {}
        self._outputs_unconfirmed_spent = {}
        # balance chain context
        self._chain_time = 0
        self._chain_height = 0
        self._chain_blockid = Hash()
        # all wallet addresses tracked in this wallet
        self._addresses = set()

    @property
    def addresses(self):
        &#34;&#34;&#34;
        All (personal wallet) addresses for which an output is tracked in this Balance.
        &#34;&#34;&#34;
        return list(self._addresses)

    @property
    def chain_blockid(self):
        &#34;&#34;&#34;
        Blockchain block ID, as defined by the last known block.
        &#34;&#34;&#34;
        return self._chain_blockid
    @chain_blockid.setter
    def chain_blockid(self, value):
        &#34;&#34;&#34;
        Set the blockchain block ID, such that applications that which to cache this
        balance object could ensure that the last block is still the same as the
        last known block known by this balance instance.
        &#34;&#34;&#34;
        if not value:
            self._chain_blockid = Hash()
            return
        if isinstance(value, Hash):
            self._chain_blockid.value = value.value
        else:
            self._chain_blockid.value = value

    @property
    def chain_time(self):
        &#34;&#34;&#34;
        Blockchain time, as defined by the last known block.
        &#34;&#34;&#34;
        return self._chain_time
    @chain_time.setter
    def chain_time(self, value):
        &#34;&#34;&#34;
        Set the blockchain time, such that the balance object can report
        locked/unlocked outputs correctly for outputs that are locked by time.
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise TypeError(&#34;WalletBalance&#39;s chain time cannot be of type {} (expected: int)&#34;.format(type(value)))
        self._chain_time = int(value)

    @property
    def chain_height(self):
        &#34;&#34;&#34;
        Blockchain height, as defined by the last known block.
        &#34;&#34;&#34;
        return self._chain_height
    @chain_height.setter
    def chain_height(self, value):
        &#34;&#34;&#34;
        Set the blockchain height, such that the balance object can report
        locked/unlocked outputs correctly for outputs that are locked by height.
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise TypeError(&#34;WalletBalance&#39;s chain height cannot be of type {} (expected: int)&#34;.format(type(value)))
        self._chain_height = int(value)

    @property
    def active(self):
        &#34;&#34;&#34;
        Returns if this balance is active,
        meaning it has available outputs to spend (confirmed or not).
        &#34;&#34;&#34;
        return len(self._outputs) &gt; 0 or len(self._outputs_unconfirmed) &gt; 0

    @property
    def outputs_spent(self):
        &#34;&#34;&#34;
        Spent (coin) outputs.
        &#34;&#34;&#34;
        return self._outputs_spent
    @property
    def outputs_unconfirmed(self):
        &#34;&#34;&#34;
        Unconfirmed (coin) outputs, available for spending or locked.
        &#34;&#34;&#34;
        return self._outputs_unconfirmed
    @property
    def outputs_unconfirmed_available(self):
        &#34;&#34;&#34;
        Unconfirmed (coin) outputs, available for spending.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return [co for co in self._outputs_unconfirmed.values()
                if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]
        else:
            return list(self._outputs_unconfirmed.values())
    @property
    def outputs_unconfirmed_spent(self):
        &#34;&#34;&#34;
        Unconfirmed (coin) outputs that have already been spent.
        &#34;&#34;&#34;
        return self._outputs_unconfirmed_spent

    @property
    def outputs_available(self):
        &#34;&#34;&#34;
        Total available (coin) outputs.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return [co for co in self._outputs.values()
                if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]
        else:
            return list(self._outputs.values())

    @property
    def available(self):
        &#34;&#34;&#34;
        Total available coins.
        &#34;&#34;&#34;
        return sum([co.value for co in self.outputs_available]) or Currency()

    @property
    def locked(self):
        &#34;&#34;&#34;
        Total available coins that are locked.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return sum([co.value for co in self._outputs.values()
                if co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
        else:
            return Currency(value=0) # impossible to know for sure without a complete context

    @property
    def unconfirmed(self):
        &#34;&#34;&#34;
        Total unconfirmed coins, available for spending.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return sum([co.value for co in self._outputs_unconfirmed.values()
                if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
        else:
            return sum([co.value for co in self._outputs_unconfirmed.values()])

    @property
    def unconfirmed_locked(self):
        &#34;&#34;&#34;
        Total unconfirmed coins that are locked, and thus not available for spending.
        &#34;&#34;&#34;
        if self.chain_time &gt; 0 and self.chain_height &gt; 0:
            return sum([co.value for co in self._outputs_unconfirmed.values()
                if co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
        else:
            return Currency(value=0) # impossible to know for sure without a complete context

    def output_add(self, output, confirmed=True, spent=False):
        &#34;&#34;&#34;
        Add an output to the Wallet&#39;s balance.
        &#34;&#34;&#34;
        if confirmed: # confirmed outputs
            if spent:
                self._outputs_spent[output.id] = output
                # delete from other output lists if prior registered
                self._outputs.pop(output.id, None)
                self._outputs_unconfirmed.pop(output.id, None)
                self._outputs_unconfirmed_spent.pop(output.id, None)
            elif output.id not in self._outputs_spent and output.id not in self._outputs_unconfirmed_spent:
                self._outputs[output.id] = output
                # delete from other output lists if prior registered
                self._outputs_unconfirmed.pop(output.id, None)
        elif output.id not in self._outputs_spent: # unconfirmed outputs
            if spent:
                self._outputs_unconfirmed_spent[output.id] = output
                # delete from other output lists if prior registered
                self._outputs_unconfirmed.pop(output.id, None)
                self._outputs.pop(output.id, None)
            elif output.id not in self._outputs_unconfirmed_spent:
                self._outputs_unconfirmed[output.id] = output
        self._addresses.add(str(output.condition.unlockhash))

    @property
    def _base(self):
        &#34;&#34;&#34;
        Private helper utility to return this class as a new and pure WalletBalance object
        &#34;&#34;&#34;
        b = WalletBalance()
        b._outputs = self._outputs
        b._outputs_spent = self._outputs_spent
        b._outputs_unconfirmed = self._outputs_unconfirmed
        b._outputs_unconfirmed_spent = self._outputs_unconfirmed_spent
        b._chain_blockid = self._chain_blockid
        b._chain_height = self._chain_height
        b._chain_time = self._chain_time
        b._addresses = self._addresses
        return b

    def balance_add(self, other):
        &#34;&#34;&#34;
        Merge the content of the other balance into this balance.
        If other is None, this call results in a no-op.

        Always assign the result, as it could other than self,
        should the class type be changed in order to add all content correctly.
        &#34;&#34;&#34;
        if other is None:
            return self
        if isinstance(other, (WalletsBalance, MultiSigWalletBalance)):
            return WalletsBalance().balance_add(self).balance_add(other)
        if not isinstance(other, WalletBalance):
            raise TypeError(&#34;other balance has to be of type wallet balance&#34;)
        # another balance is defined, create a new balance that will contain our merge
        # merge the chain info
        if self.chain_height &gt;= other.chain_height:
            if self.chain_time &lt; other.chain_time:
                raise ValueError(&#34;chain time and chain height of balances do not match&#34;)
        else:
            if self.chain_time &gt;= other.chain_time:
                raise ValueError(&#34;chain time and chain height of balances do not match&#34;)
            self.chain_time = other.chain_time
            self.chain_height = other.chain_height
            self.chain_blockid = other.chain_blockid
        # merge the outputs
        for attr in [&#39;_outputs&#39;, &#39;_outputs_spent&#39;, &#39;_outputs_unconfirmed&#39;, &#39;_outputs_unconfirmed_spent&#39;]:
            d = getattr(self, attr, {})
            for id, output in getattr(other, attr, {}).items():
                d[id] = output
        # merge the addresses
        self._addresses |= other._addresses
        # return the modified self
        return self

    def drain(self, recipient, miner_fee, unconfirmed=False, data=None, lock=None):
        &#34;&#34;&#34;
        add all available outputs into as many transactions as required,
        by default only confirmed outputs are used, if unconfirmed=True
        it will use unconfirmed available outputs as well.

        Result can be an empty list if no outputs were available.

        @param recipient: required recipient towards who the drained coins will be sent
        @param the miner fee to be added to all sent transactions
        @param unconfirmed: optionally drain unconfirmed (available) outputs as well
        @param data: optional data that can be attached ot the created transactions (str or bytes), with a max length of 83
        @param lock: optional lock that can be attached to the sent coin outputs
        &#34;&#34;&#34;
        # define recipient
        recipient = ConditionTypes.from_recipient(recipient, lock=lock)

        # validate miner fee
        if not isinstance(miner_fee, Currency):
            raise TypeError(&#34;miner fee has to be a currency&#34;)
        if miner_fee == 0:
            raise ValueError(&#34;a non-zero miner fee has to be defined&#34;)

        # collect all transactions in one list
        transactions = []

        # collect all confirmed (available) outputs
        outputs = self.outputs_available
        if unconfirmed:
            # if also the unconfirmed_avaialble) outputs are desired, let&#39;s add them as well
            outputs += self.outputs_unconfirmed_available
        # drain all outputs
        while len(outputs) &gt; 0:
            txn = tftransactions.new()
            txn.data = data
            txn.miner_fee_add(miner_fee)
            # select maximum _MAX_RIVINE_TRANSACTION_INPUTS outputs
            n = min(len(outputs), _MAX_RIVINE_TRANSACTION_INPUTS)
            used_outputs = outputs[:n]
            outputs = outputs[n:] # and update our output list, so we do not double spend
            # compute amount, minus minimum fee and add our only output
            amount = sum([co.value for co in used_outputs]) - miner_fee
            txn.coin_output_add(condition=recipient, value=amount)
            # add the coin inputs
            txn.coin_inputs = [CoinInput.from_coin_output(co) for co in used_outputs]
            # append the transaction
            transactions.append(txn)

        # return all created transactions, if any
        return transactions

    def _human_readable_balance(self):
        # report confirmed coins
        result = &#34;{} available and {} locked&#34;.format(self.available.str(with_unit=True), self.locked.str(with_unit=True))
        # optionally report unconfirmed coins
        unconfirmed = self.unconfirmed
        unconfirmed_locked = self.unconfirmed_locked
        if unconfirmed &gt; 0 or unconfirmed_locked &gt; 0:
            result += &#34;\nUnconfirmed: {} available {} locked&#34;.format(unconfirmed.str(with_unit=True), unconfirmed_locked.str(with_unit=True))
        unconfirmed_spent = Currency(value=sum([co.value for co in self._outputs_unconfirmed_spent.values()]))
        if unconfirmed_spent &gt; 0:
            result += &#34;\nUnconfirmed Balance Deduction: -{}&#34;.format(unconfirmed_spent.str(with_unit=True))
        # return report
        return result

    def __repr__(self):
        # report chain context
        result = &#34;&#34;
        if self.chain_height &gt; 0 and self.chain_time &gt; 0:
            result += &#34;wallet balance on height {} at {}\n&#34;.format(self.chain_height, epoch2HRDateTime(self.chain_time))
        else:
            result += &#34;wallet balance at an unknown time\n&#34;
        # report context + balance
        return result + self._human_readable_balance()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tfchain.TFChainWallet.MultiSigWalletBalance" href="#tfchain.TFChainWallet.MultiSigWalletBalance">MultiSigWalletBalance</a></li>
<li><a title="tfchain.TFChainWallet.WalletsBalance" href="#tfchain.TFChainWallet.WalletsBalance">WalletsBalance</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.WalletBalance.active"><code class="name">var <span class="ident">active</span></code></dt>
<dd>
<section class="desc"><p>Returns if this balance is active,
meaning it has available outputs to spend (confirmed or not).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def active(self):
    &#34;&#34;&#34;
    Returns if this balance is active,
    meaning it has available outputs to spend (confirmed or not).
    &#34;&#34;&#34;
    return len(self._outputs) &gt; 0 or len(self._outputs_unconfirmed) &gt; 0</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.addresses"><code class="name">var <span class="ident">addresses</span></code></dt>
<dd>
<section class="desc"><p>All (personal wallet) addresses for which an output is tracked in this Balance.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def addresses(self):
    &#34;&#34;&#34;
    All (personal wallet) addresses for which an output is tracked in this Balance.
    &#34;&#34;&#34;
    return list(self._addresses)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.available"><code class="name">var <span class="ident">available</span></code></dt>
<dd>
<section class="desc"><p>Total available coins.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def available(self):
    &#34;&#34;&#34;
    Total available coins.
    &#34;&#34;&#34;
    return sum([co.value for co in self.outputs_available]) or Currency()</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.chain_blockid"><code class="name">var <span class="ident">chain_blockid</span></code></dt>
<dd>
<section class="desc"><p>Blockchain block ID, as defined by the last known block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def chain_blockid(self):
    &#34;&#34;&#34;
    Blockchain block ID, as defined by the last known block.
    &#34;&#34;&#34;
    return self._chain_blockid</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.chain_height"><code class="name">var <span class="ident">chain_height</span></code></dt>
<dd>
<section class="desc"><p>Blockchain height, as defined by the last known block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def chain_height(self):
    &#34;&#34;&#34;
    Blockchain height, as defined by the last known block.
    &#34;&#34;&#34;
    return self._chain_height</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.chain_time"><code class="name">var <span class="ident">chain_time</span></code></dt>
<dd>
<section class="desc"><p>Blockchain time, as defined by the last known block.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def chain_time(self):
    &#34;&#34;&#34;
    Blockchain time, as defined by the last known block.
    &#34;&#34;&#34;
    return self._chain_time</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.locked"><code class="name">var <span class="ident">locked</span></code></dt>
<dd>
<section class="desc"><p>Total available coins that are locked.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def locked(self):
    &#34;&#34;&#34;
    Total available coins that are locked.
    &#34;&#34;&#34;
    if self.chain_time &gt; 0 and self.chain_height &gt; 0:
        return sum([co.value for co in self._outputs.values()
            if co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
    else:
        return Currency(value=0) # impossible to know for sure without a complete context</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.outputs_available"><code class="name">var <span class="ident">outputs_available</span></code></dt>
<dd>
<section class="desc"><p>Total available (coin) outputs.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def outputs_available(self):
    &#34;&#34;&#34;
    Total available (coin) outputs.
    &#34;&#34;&#34;
    if self.chain_time &gt; 0 and self.chain_height &gt; 0:
        return [co for co in self._outputs.values()
            if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]
    else:
        return list(self._outputs.values())</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.outputs_spent"><code class="name">var <span class="ident">outputs_spent</span></code></dt>
<dd>
<section class="desc"><p>Spent (coin) outputs.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def outputs_spent(self):
    &#34;&#34;&#34;
    Spent (coin) outputs.
    &#34;&#34;&#34;
    return self._outputs_spent</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed"><code class="name">var <span class="ident">outputs_unconfirmed</span></code></dt>
<dd>
<section class="desc"><p>Unconfirmed (coin) outputs, available for spending or locked.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def outputs_unconfirmed(self):
    &#34;&#34;&#34;
    Unconfirmed (coin) outputs, available for spending or locked.
    &#34;&#34;&#34;
    return self._outputs_unconfirmed</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available"><code class="name">var <span class="ident">outputs_unconfirmed_available</span></code></dt>
<dd>
<section class="desc"><p>Unconfirmed (coin) outputs, available for spending.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def outputs_unconfirmed_available(self):
    &#34;&#34;&#34;
    Unconfirmed (coin) outputs, available for spending.
    &#34;&#34;&#34;
    if self.chain_time &gt; 0 and self.chain_height &gt; 0:
        return [co for co in self._outputs_unconfirmed.values()
            if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]
    else:
        return list(self._outputs_unconfirmed.values())</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent"><code class="name">var <span class="ident">outputs_unconfirmed_spent</span></code></dt>
<dd>
<section class="desc"><p>Unconfirmed (coin) outputs that have already been spent.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def outputs_unconfirmed_spent(self):
    &#34;&#34;&#34;
    Unconfirmed (coin) outputs that have already been spent.
    &#34;&#34;&#34;
    return self._outputs_unconfirmed_spent</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.unconfirmed"><code class="name">var <span class="ident">unconfirmed</span></code></dt>
<dd>
<section class="desc"><p>Total unconfirmed coins, available for spending.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def unconfirmed(self):
    &#34;&#34;&#34;
    Total unconfirmed coins, available for spending.
    &#34;&#34;&#34;
    if self.chain_time &gt; 0 and self.chain_height &gt; 0:
        return sum([co.value for co in self._outputs_unconfirmed.values()
            if not co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
    else:
        return sum([co.value for co in self._outputs_unconfirmed.values()])</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.unconfirmed_locked"><code class="name">var <span class="ident">unconfirmed_locked</span></code></dt>
<dd>
<section class="desc"><p>Total unconfirmed coins that are locked, and thus not available for spending.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def unconfirmed_locked(self):
    &#34;&#34;&#34;
    Total unconfirmed coins that are locked, and thus not available for spending.
    &#34;&#34;&#34;
    if self.chain_time &gt; 0 and self.chain_height &gt; 0:
        return sum([co.value for co in self._outputs_unconfirmed.values()
            if co.condition.lock.locked_check(time=self.chain_time, height=self.chain_height)]) or Currency()
    else:
        return Currency(value=0) # impossible to know for sure without a complete context</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.WalletBalance.balance_add"><code class="name flex">
<span>def <span class="ident">balance_add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge the content of the other balance into this balance.
If other is None, this call results in a no-op.</p>
<p>Always assign the result, as it could other than self,
should the class type be changed in order to add all content correctly.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def balance_add(self, other):
    &#34;&#34;&#34;
    Merge the content of the other balance into this balance.
    If other is None, this call results in a no-op.

    Always assign the result, as it could other than self,
    should the class type be changed in order to add all content correctly.
    &#34;&#34;&#34;
    if other is None:
        return self
    if isinstance(other, (WalletsBalance, MultiSigWalletBalance)):
        return WalletsBalance().balance_add(self).balance_add(other)
    if not isinstance(other, WalletBalance):
        raise TypeError(&#34;other balance has to be of type wallet balance&#34;)
    # another balance is defined, create a new balance that will contain our merge
    # merge the chain info
    if self.chain_height &gt;= other.chain_height:
        if self.chain_time &lt; other.chain_time:
            raise ValueError(&#34;chain time and chain height of balances do not match&#34;)
    else:
        if self.chain_time &gt;= other.chain_time:
            raise ValueError(&#34;chain time and chain height of balances do not match&#34;)
        self.chain_time = other.chain_time
        self.chain_height = other.chain_height
        self.chain_blockid = other.chain_blockid
    # merge the outputs
    for attr in [&#39;_outputs&#39;, &#39;_outputs_spent&#39;, &#39;_outputs_unconfirmed&#39;, &#39;_outputs_unconfirmed_spent&#39;]:
        d = getattr(self, attr, {})
        for id, output in getattr(other, attr, {}).items():
            d[id] = output
    # merge the addresses
    self._addresses |= other._addresses
    # return the modified self
    return self</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.drain"><code class="name flex">
<span>def <span class="ident">drain</span></span>(<span>self, recipient, miner_fee, unconfirmed=False, data=None, lock=None)</span>
</code></dt>
<dd>
<section class="desc"><p>add all available outputs into as many transactions as required,
by default only confirmed outputs are used, if unconfirmed=True
it will use unconfirmed available outputs as well.</p>
<p>Result can be an empty list if no outputs were available.</p>
<p>@param recipient: required recipient towards who the drained coins will be sent
@param the miner fee to be added to all sent transactions
@param unconfirmed: optionally drain unconfirmed (available) outputs as well
@param data: optional data that can be attached ot the created transactions (str or bytes), with a max length of 83
@param lock: optional lock that can be attached to the sent coin outputs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drain(self, recipient, miner_fee, unconfirmed=False, data=None, lock=None):
    &#34;&#34;&#34;
    add all available outputs into as many transactions as required,
    by default only confirmed outputs are used, if unconfirmed=True
    it will use unconfirmed available outputs as well.

    Result can be an empty list if no outputs were available.

    @param recipient: required recipient towards who the drained coins will be sent
    @param the miner fee to be added to all sent transactions
    @param unconfirmed: optionally drain unconfirmed (available) outputs as well
    @param data: optional data that can be attached ot the created transactions (str or bytes), with a max length of 83
    @param lock: optional lock that can be attached to the sent coin outputs
    &#34;&#34;&#34;
    # define recipient
    recipient = ConditionTypes.from_recipient(recipient, lock=lock)

    # validate miner fee
    if not isinstance(miner_fee, Currency):
        raise TypeError(&#34;miner fee has to be a currency&#34;)
    if miner_fee == 0:
        raise ValueError(&#34;a non-zero miner fee has to be defined&#34;)

    # collect all transactions in one list
    transactions = []

    # collect all confirmed (available) outputs
    outputs = self.outputs_available
    if unconfirmed:
        # if also the unconfirmed_avaialble) outputs are desired, let&#39;s add them as well
        outputs += self.outputs_unconfirmed_available
    # drain all outputs
    while len(outputs) &gt; 0:
        txn = tftransactions.new()
        txn.data = data
        txn.miner_fee_add(miner_fee)
        # select maximum _MAX_RIVINE_TRANSACTION_INPUTS outputs
        n = min(len(outputs), _MAX_RIVINE_TRANSACTION_INPUTS)
        used_outputs = outputs[:n]
        outputs = outputs[n:] # and update our output list, so we do not double spend
        # compute amount, minus minimum fee and add our only output
        amount = sum([co.value for co in used_outputs]) - miner_fee
        txn.coin_output_add(condition=recipient, value=amount)
        # add the coin inputs
        txn.coin_inputs = [CoinInput.from_coin_output(co) for co in used_outputs]
        # append the transaction
        transactions.append(txn)

    # return all created transactions, if any
    return transactions</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletBalance.output_add"><code class="name flex">
<span>def <span class="ident">output_add</span></span>(<span>self, output, confirmed=True, spent=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Add an output to the Wallet's balance.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def output_add(self, output, confirmed=True, spent=False):
    &#34;&#34;&#34;
    Add an output to the Wallet&#39;s balance.
    &#34;&#34;&#34;
    if confirmed: # confirmed outputs
        if spent:
            self._outputs_spent[output.id] = output
            # delete from other output lists if prior registered
            self._outputs.pop(output.id, None)
            self._outputs_unconfirmed.pop(output.id, None)
            self._outputs_unconfirmed_spent.pop(output.id, None)
        elif output.id not in self._outputs_spent and output.id not in self._outputs_unconfirmed_spent:
            self._outputs[output.id] = output
            # delete from other output lists if prior registered
            self._outputs_unconfirmed.pop(output.id, None)
    elif output.id not in self._outputs_spent: # unconfirmed outputs
        if spent:
            self._outputs_unconfirmed_spent[output.id] = output
            # delete from other output lists if prior registered
            self._outputs_unconfirmed.pop(output.id, None)
            self._outputs.pop(output.id, None)
        elif output.id not in self._outputs_unconfirmed_spent:
            self._outputs_unconfirmed[output.id] = output
    self._addresses.add(str(output.condition.unlockhash))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tfchain.TFChainWallet.WalletsBalance"><code class="flex name class">
<span>class <span class="ident">WalletsBalance</span></span>
</code></dt>
<dd>
<section class="desc"><p>Creates a personal wallet, which also can have children wallets that are meant for
all MultiSignature wallets that are related to one or more addresses of the personal wallet.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class WalletsBalance(WalletBalance):
    def __init__(self):
        &#34;&#34;&#34;
        Creates a personal wallet, which also can have children wallets that are meant for
        all MultiSignature wallets that are related to one or more addresses of the personal wallet.
        &#34;&#34;&#34;
        self._wallets = {}
        super().__init__()

    @property
    def wallets(self):
        &#34;&#34;&#34;
        All multisig wallets linked to this wallet.
        &#34;&#34;&#34;
        return self._wallets

    @property
    def addresses_multisig(self):
        &#34;&#34;&#34;
        All (multisig wallet) addresses for which an output is tracked in this Balance.
        For each address you&#39;ll find a wallet in the `self.wallets` dict property.
        &#34;&#34;&#34;
        return list(self.wallets.keys())

    def multisig_output_add(self, address, output, confirmed=True, spent=False):
        &#34;&#34;&#34;
        Add an output to the MultiSignature Wallet&#39;s balance.
        &#34;&#34;&#34;
        oc = output.condition.unwrap()
        if not isinstance(oc, ConditionMultiSignature):
            raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
        if not address in self._wallets:
            self._wallets[address] = MultiSigWalletBalance(
                owners=output.condition.unlockhashes,
                signature_count=output.condition.required_signatures)
        self._wallets[address].output_add(output, confirmed=confirmed, spent=spent)

    def output_add(self, output, confirmed=True, spent=False):
        &#34;&#34;&#34;
        Add an output to the Wallet&#39;s balance.
        &#34;&#34;&#34;
        uh = output.condition.unlockhash
        if uh.type == UnlockHashType.MULTI_SIG:
            return self.multisig_output_add(address=str(uh), output=output, confirmed=confirmed, spent=spent)
        self._addresses.add(str(uh))
        return super().output_add(output=output, confirmed=confirmed, spent=spent)

    def balance_add(self, other):
        &#34;&#34;&#34;
        Merge the content of the other balance into this balance.
        If other is None, this call results in a no-op.

        Always assign the result, as it could other than self,
        should the class type be changed in order to add all content correctly.
        &#34;&#34;&#34;
        if other is None:
            return self
        if not isinstance(other, WalletBalance):
            raise TypeError(&#34;other balance has to be of type wallet balance&#34;)
        if isinstance(other, MultiSigWalletBalance):
            self._merge_multisig_wallet_balance(other.address, other)
            return self
        # piggy-back on the super class for the actual output merge logic
        b = super().balance_add(other._base)
        if b != self:
            raise Exception(&#34;BUG: instance shouldn&#39;t have changed, please fix or report&#34;)
        if not isinstance(other, WalletsBalance):
            return b # return as nothing else can be merged
        # merge all the multi-signature wallets
        for addr, balance in other._wallets.items():
            b._merge_multisig_wallet_balance(addr, balance)
        # return the merged balance
        return b

    def _merge_multisig_wallet_balance(self, address, balance):
        &#34;&#34;&#34;
        Assign or merge a multi-sig wallet balance
        &#34;&#34;&#34;
        if address not in self._wallets:
            self._wallets[address] = balance
            return
        self._wallets[address] = self._wallets[address].merge(balance)

    def __repr__(self):
        result = super().__repr__()
        for wallet in self.wallets.values():
            if wallet.active: # only display active wallets in the Human (shell) Representation
                result += &#34;\n\n&#34; + wallet._human_readable_balance()
        return result

    def fund(self, amount, source=None):
        &#34;&#34;&#34;
        Fund the specified amount with the available outputs of this wallet&#39;s balance.
        &#34;&#34;&#34;
        # collect addresses and multisig addresses
        addresses = set()
        ms_addresses = set()
        refund = None
        if source is None:
            for co in self.outputs_available:
                addresses.add(co.condition.unlockhash)
            for co in self.outputs_unconfirmed_available:
                addresses.add(co.condition.unlockhash)
        else:
            # if only one address is given, transform it into an acceptable list
            if not isinstance(source, list):
                if isinstance(source, str):
                    source = UnlockHash.from_json(source)
                elif not isinstance(source, UnlockHash):
                    raise TypeError(&#34;cannot add source address from type {}&#34;.format(type(source)))
                source = [source]
            # add one or multiple personal/multisig addresses
            for value in source:
                if isinstance(value, str):
                    value = UnlockHash.from_json(value)
                elif not isinstance(value, UnlockHash):
                    raise TypeError(&#34;cannot add source address from type {}&#34;.format(type(value)))
                if value.type == UnlockHashType.MULTI_SIG:
                    ms_addresses.add(value)
                elif value.type == UnlockHashType.PUBLIC_KEY:
                    addresses.add(value)
                else:
                    raise TypeError(&#34;cannot add source addres with unsupported UnlockHashType {}&#34;.format(value.type))
            if len(source) == 1:
                if source[0].type == UnlockHashType.PUBLIC_KEY:
                    refund = ConditionTypes.unlockhash_new(unlockhash=source[0])
                else:
                    addr = str(source[0])
                    if addr in self.wallets:
                        wallet = self.wallets[addr]
                        refund = ConditionTypes.multi_signature_new(min_nr_sig=wallet.signature_count, unlockhashes=wallet.owners)


        # ensure at least one address is defined
        if len(addresses) == 0 and len(ms_addresses) == 0:
            raise tfchain.errors.InsufficientFunds(&#34;insufficient funds in this wallet&#34;)

        # if personal addresses are given, try to use these first
        # as these are the easiest kind to deal with
        if len(addresses) == 0:
            outputs, collected = ([], Currency()) # start with nothing
        else:
            outputs, collected = self._fund_individual(amount, addresses)

        if collected &gt;= amount:
            # if we already have sufficient, we stop now
            return ([CoinInput.from_coin_output(co) for co in outputs], collected-amount, refund)

        if len(ms_addresses) == 0:
            # if no ms_addresses were defined,
            raise tfchain.errors.InsufficientFunds(&#34;not enough funds available in the individual wallet to fund the requested amount&#34;)
        # otherwise keep going for multisig addresses
        outputs, collected = self._fund_multisig(amount, ms_addresses, outputs=outputs, collected=collected)

        # if we still didn&#39;t manage to fund enough, there is nothing we can do
        if collected &lt; amount:
            raise tfchain.errors.InsufficientFunds(&#34;not enough funds available in the wallets to fund the requested amount&#34;)
        return ([CoinInput.from_coin_output(co) for co in outputs], collected-amount, refund)

    def _fund_individual(self, amount, addresses):
        outputs_available = [co for co in self.outputs_available if co.condition.unlockhash in addresses]
        outputs_available.sort(key=lambda co: co.value)
        collected = Currency(value=0)
        outputs = []
        # try to fund only with confirmed outputs, if possible
        for co in outputs_available:
            if co.value &gt;= amount:
                return [co], co.value
            collected += co.value
            outputs.append(co)
            if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                # to not reach the input limit
                collected -= outputs.pop(0).value
            if collected &gt;= amount:
                return outputs, collected

        if collected &gt;= amount:
            # if we already have sufficient, we stop now
            return outputs, collected

        # use unconfirmed balance, not ideal, but acceptable
        outputs_available = [co for co in self.outputs_unconfirmed_available if co.condition.unlockhash in addresses]
        outputs_available.sort(key=lambda co: co.value, reverse=True)
        for co in outputs_available:
            if co.value &gt;= amount:
                return [co], co.value
            collected += co.value
            outputs.append(co)
            if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                # to not reach the input limit
                collected -= outputs.pop(0).value
            if collected &gt;= amount:
                return outputs, collected

        # we return whatever we have collected, no matter if it is sufficient
        return outputs, collected

    def _fund_multisig(self, amount, addresses, outputs=None, collected=None):
        if outputs is None:
            outputs = []
        if collected is None:
            collected = Currency()
        for address, wallet in self.wallets.items():
            if UnlockHash.from_json(address) not in addresses:
                continue # nothing to do here

            outputs_available = wallet.outputs_available
            outputs_available.sort(key=lambda co: co.value)
            # try to fund only with confirmed outputs, if possible
            for co in outputs_available:
                if co.value &gt;= amount:
                    return [co], co.value

                collected += co.value
                outputs.append(co)
                if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                    # to not reach the input limit
                    collected -= outputs.pop(0).value
                if collected &gt;= amount:
                    return outputs, collected

            if collected &gt;= amount:
                # if we already have sufficient, we stop now
                return outputs, collected

            # use unconfirmed balance, not ideal, but acceptable
            outputs_available = wallet.outputs_unconfirmed_available
            outputs_available.sort(key=lambda co: co.value, reverse=True)
            for co in outputs_available:
                if co.value &gt;= amount:
                    return [co], co.value
                collected += co.value
                outputs.append(co)
                if len(outputs) &gt; _MAX_RIVINE_TRANSACTION_INPUTS:
                    # to not reach the input limit
                    collected -= outputs.pop(0).value
                if collected &gt;= amount:
                    return outputs, collected
        # we return whatever we have collected, no matter if it is sufficient
        return outputs, collected</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tfchain.TFChainWallet.WalletBalance" href="#tfchain.TFChainWallet.WalletBalance">WalletBalance</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tfchain.TFChainWallet.WalletsBalance.addresses_multisig"><code class="name">var <span class="ident">addresses_multisig</span></code></dt>
<dd>
<section class="desc"><p>All (multisig wallet) addresses for which an output is tracked in this Balance.
For each address you'll find a wallet in the <code>self.wallets</code> dict property.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def addresses_multisig(self):
    &#34;&#34;&#34;
    All (multisig wallet) addresses for which an output is tracked in this Balance.
    For each address you&#39;ll find a wallet in the `self.wallets` dict property.
    &#34;&#34;&#34;
    return list(self.wallets.keys())</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletsBalance.wallets"><code class="name">var <span class="ident">wallets</span></code></dt>
<dd>
<section class="desc"><p>All multisig wallets linked to this wallet.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def wallets(self):
    &#34;&#34;&#34;
    All multisig wallets linked to this wallet.
    &#34;&#34;&#34;
    return self._wallets</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tfchain.TFChainWallet.WalletsBalance.fund"><code class="name flex">
<span>def <span class="ident">fund</span></span>(<span>self, amount, source=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Fund the specified amount with the available outputs of this wallet's balance.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fund(self, amount, source=None):
    &#34;&#34;&#34;
    Fund the specified amount with the available outputs of this wallet&#39;s balance.
    &#34;&#34;&#34;
    # collect addresses and multisig addresses
    addresses = set()
    ms_addresses = set()
    refund = None
    if source is None:
        for co in self.outputs_available:
            addresses.add(co.condition.unlockhash)
        for co in self.outputs_unconfirmed_available:
            addresses.add(co.condition.unlockhash)
    else:
        # if only one address is given, transform it into an acceptable list
        if not isinstance(source, list):
            if isinstance(source, str):
                source = UnlockHash.from_json(source)
            elif not isinstance(source, UnlockHash):
                raise TypeError(&#34;cannot add source address from type {}&#34;.format(type(source)))
            source = [source]
        # add one or multiple personal/multisig addresses
        for value in source:
            if isinstance(value, str):
                value = UnlockHash.from_json(value)
            elif not isinstance(value, UnlockHash):
                raise TypeError(&#34;cannot add source address from type {}&#34;.format(type(value)))
            if value.type == UnlockHashType.MULTI_SIG:
                ms_addresses.add(value)
            elif value.type == UnlockHashType.PUBLIC_KEY:
                addresses.add(value)
            else:
                raise TypeError(&#34;cannot add source addres with unsupported UnlockHashType {}&#34;.format(value.type))
        if len(source) == 1:
            if source[0].type == UnlockHashType.PUBLIC_KEY:
                refund = ConditionTypes.unlockhash_new(unlockhash=source[0])
            else:
                addr = str(source[0])
                if addr in self.wallets:
                    wallet = self.wallets[addr]
                    refund = ConditionTypes.multi_signature_new(min_nr_sig=wallet.signature_count, unlockhashes=wallet.owners)


    # ensure at least one address is defined
    if len(addresses) == 0 and len(ms_addresses) == 0:
        raise tfchain.errors.InsufficientFunds(&#34;insufficient funds in this wallet&#34;)

    # if personal addresses are given, try to use these first
    # as these are the easiest kind to deal with
    if len(addresses) == 0:
        outputs, collected = ([], Currency()) # start with nothing
    else:
        outputs, collected = self._fund_individual(amount, addresses)

    if collected &gt;= amount:
        # if we already have sufficient, we stop now
        return ([CoinInput.from_coin_output(co) for co in outputs], collected-amount, refund)

    if len(ms_addresses) == 0:
        # if no ms_addresses were defined,
        raise tfchain.errors.InsufficientFunds(&#34;not enough funds available in the individual wallet to fund the requested amount&#34;)
    # otherwise keep going for multisig addresses
    outputs, collected = self._fund_multisig(amount, ms_addresses, outputs=outputs, collected=collected)

    # if we still didn&#39;t manage to fund enough, there is nothing we can do
    if collected &lt; amount:
        raise tfchain.errors.InsufficientFunds(&#34;not enough funds available in the wallets to fund the requested amount&#34;)
    return ([CoinInput.from_coin_output(co) for co in outputs], collected-amount, refund)</code></pre>
</details>
</dd>
<dt id="tfchain.TFChainWallet.WalletsBalance.multisig_output_add"><code class="name flex">
<span>def <span class="ident">multisig_output_add</span></span>(<span>self, address, output, confirmed=True, spent=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Add an output to the MultiSignature Wallet's balance.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def multisig_output_add(self, address, output, confirmed=True, spent=False):
    &#34;&#34;&#34;
    Add an output to the MultiSignature Wallet&#39;s balance.
    &#34;&#34;&#34;
    oc = output.condition.unwrap()
    if not isinstance(oc, ConditionMultiSignature):
        raise TypeError(&#34;multi signature&#39;s output condition cannot be of type {} (expected: ConditionMultiSignature)&#34;.format(type(oc)))
    if not address in self._wallets:
        self._wallets[address] = MultiSigWalletBalance(
            owners=output.condition.unlockhashes,
            signature_count=output.condition.required_signatures)
    self._wallets[address].output_add(output, confirmed=confirmed, spent=spent)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tfchain.TFChainWallet.WalletBalance" href="#tfchain.TFChainWallet.WalletBalance">WalletBalance</a></b></code>:
<ul class="hlist">
<li><code><a title="tfchain.TFChainWallet.WalletBalance.active" href="#tfchain.TFChainWallet.WalletBalance.active">active</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.addresses" href="#tfchain.TFChainWallet.WalletBalance.addresses">addresses</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.available" href="#tfchain.TFChainWallet.WalletBalance.available">available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.balance_add" href="#tfchain.TFChainWallet.WalletBalance.balance_add">balance_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_blockid" href="#tfchain.TFChainWallet.WalletBalance.chain_blockid">chain_blockid</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_height" href="#tfchain.TFChainWallet.WalletBalance.chain_height">chain_height</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_time" href="#tfchain.TFChainWallet.WalletBalance.chain_time">chain_time</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.drain" href="#tfchain.TFChainWallet.WalletBalance.drain">drain</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.locked" href="#tfchain.TFChainWallet.WalletBalance.locked">locked</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.output_add" href="#tfchain.TFChainWallet.WalletBalance.output_add">output_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_available" href="#tfchain.TFChainWallet.WalletBalance.outputs_available">outputs_available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_spent" href="#tfchain.TFChainWallet.WalletBalance.outputs_spent">outputs_spent</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed">outputs_unconfirmed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available">outputs_unconfirmed_available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent">outputs_unconfirmed_spent</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.unconfirmed" href="#tfchain.TFChainWallet.WalletBalance.unconfirmed">unconfirmed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.unconfirmed_locked" href="#tfchain.TFChainWallet.WalletBalance.unconfirmed_locked">unconfirmed_locked</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tfchain" href="index.html">tfchain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tfchain.TFChainWallet.AtomicSwapInitiationResult" href="#tfchain.TFChainWallet.AtomicSwapInitiationResult">AtomicSwapInitiationResult</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.AtomicSwapInitiationResult.contract" href="#tfchain.TFChainWallet.AtomicSwapInitiationResult.contract">contract</a></code></li>
<li><code><a title="tfchain.TFChainWallet.AtomicSwapInitiationResult.secret" href="#tfchain.TFChainWallet.AtomicSwapInitiationResult.secret">secret</a></code></li>
<li><code><a title="tfchain.TFChainWallet.AtomicSwapInitiationResult.submitted" href="#tfchain.TFChainWallet.AtomicSwapInitiationResult.submitted">submitted</a></code></li>
<li><code><a title="tfchain.TFChainWallet.AtomicSwapInitiationResult.transaction" href="#tfchain.TFChainWallet.AtomicSwapInitiationResult.transaction">transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.AtomicSwapParticipationResult" href="#tfchain.TFChainWallet.AtomicSwapParticipationResult">AtomicSwapParticipationResult</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.AtomicSwapParticipationResult.contract" href="#tfchain.TFChainWallet.AtomicSwapParticipationResult.contract">contract</a></code></li>
<li><code><a title="tfchain.TFChainWallet.AtomicSwapParticipationResult.submitted" href="#tfchain.TFChainWallet.AtomicSwapParticipationResult.submitted">submitted</a></code></li>
<li><code><a title="tfchain.TFChainWallet.AtomicSwapParticipationResult.transaction" href="#tfchain.TFChainWallet.AtomicSwapParticipationResult.transaction">transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.CoinTransactionBuilder" href="#tfchain.TFChainWallet.CoinTransactionBuilder">CoinTransactionBuilder</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.CoinTransactionBuilder.output_add" href="#tfchain.TFChainWallet.CoinTransactionBuilder.output_add">output_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.CoinTransactionBuilder.send" href="#tfchain.TFChainWallet.CoinTransactionBuilder.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.MultiSigWalletBalance" href="#tfchain.TFChainWallet.MultiSigWalletBalance">MultiSigWalletBalance</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.MultiSigWalletBalance.address" href="#tfchain.TFChainWallet.MultiSigWalletBalance.address">address</a></code></li>
<li><code><a title="tfchain.TFChainWallet.MultiSigWalletBalance.owners" href="#tfchain.TFChainWallet.MultiSigWalletBalance.owners">owners</a></code></li>
<li><code><a title="tfchain.TFChainWallet.MultiSigWalletBalance.signature_count" href="#tfchain.TFChainWallet.MultiSigWalletBalance.signature_count">signature_count</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.SpendableKey" href="#tfchain.TFChainWallet.SpendableKey">SpendableKey</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.SpendableKey.private_key" href="#tfchain.TFChainWallet.SpendableKey.private_key">private_key</a></code></li>
<li><code><a title="tfchain.TFChainWallet.SpendableKey.public_key" href="#tfchain.TFChainWallet.SpendableKey.public_key">public_key</a></code></li>
<li><code><a title="tfchain.TFChainWallet.SpendableKey.sign" href="#tfchain.TFChainWallet.SpendableKey.sign">sign</a></code></li>
<li><code><a title="tfchain.TFChainWallet.SpendableKey.unlockhash" href="#tfchain.TFChainWallet.SpendableKey.unlockhash">unlockhash</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TFChainAtomicSwap" href="#tfchain.TFChainWallet.TFChainAtomicSwap">TFChainAtomicSwap</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TFChainAtomicSwap.initiate" href="#tfchain.TFChainWallet.TFChainAtomicSwap.initiate">initiate</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainAtomicSwap.participate" href="#tfchain.TFChainWallet.TFChainAtomicSwap.participate">participate</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainAtomicSwap.redeem" href="#tfchain.TFChainWallet.TFChainAtomicSwap.redeem">redeem</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainAtomicSwap.refund" href="#tfchain.TFChainWallet.TFChainAtomicSwap.refund">refund</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainAtomicSwap.verify" href="#tfchain.TFChainWallet.TFChainAtomicSwap.verify">verify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TFChainERC20" href="#tfchain.TFChainWallet.TFChainERC20">TFChainERC20</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TFChainERC20.address_get" href="#tfchain.TFChainWallet.TFChainERC20.address_get">address_get</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainERC20.address_register" href="#tfchain.TFChainWallet.TFChainERC20.address_register">address_register</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainERC20.addresses_get" href="#tfchain.TFChainWallet.TFChainERC20.addresses_get">addresses_get</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainERC20.coins_send" href="#tfchain.TFChainWallet.TFChainERC20.coins_send">coins_send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TFChainMinter" href="#tfchain.TFChainWallet.TFChainMinter">TFChainMinter</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TFChainMinter.coins_new" href="#tfchain.TFChainWallet.TFChainMinter.coins_new">coins_new</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainMinter.definition_set" href="#tfchain.TFChainWallet.TFChainMinter.definition_set">definition_set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TFChainThreeBot" href="#tfchain.TFChainWallet.TFChainThreeBot">TFChainThreeBot</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TFChainThreeBot.name_transfer" href="#tfchain.TFChainWallet.TFChainThreeBot.name_transfer">name_transfer</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainThreeBot.record_new" href="#tfchain.TFChainWallet.TFChainThreeBot.record_new">record_new</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainThreeBot.record_update" href="#tfchain.TFChainWallet.TFChainThreeBot.record_update">record_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TFChainWallet" href="#tfchain.TFChainWallet.TFChainWallet">TFChainWallet</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.address" href="#tfchain.TFChainWallet.TFChainWallet.address">address</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.address_new" href="#tfchain.TFChainWallet.TFChainWallet.address_new">address_new</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.addresses" href="#tfchain.TFChainWallet.TFChainWallet.addresses">addresses</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.addresses_multisig" href="#tfchain.TFChainWallet.TFChainWallet.addresses_multisig">addresses_multisig</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.atomicswap" href="#tfchain.TFChainWallet.TFChainWallet.atomicswap">atomicswap</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.balance" href="#tfchain.TFChainWallet.TFChainWallet.balance">balance</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.client" href="#tfchain.TFChainWallet.TFChainWallet.client">client</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.coin_transaction_builder_new" href="#tfchain.TFChainWallet.TFChainWallet.coin_transaction_builder_new">coin_transaction_builder_new</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.coins_send" href="#tfchain.TFChainWallet.TFChainWallet.coins_send">coins_send</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.erc20" href="#tfchain.TFChainWallet.TFChainWallet.erc20">erc20</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.key_count" href="#tfchain.TFChainWallet.TFChainWallet.key_count">key_count</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.key_pair_get" href="#tfchain.TFChainWallet.TFChainWallet.key_pair_get">key_pair_get</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.key_scan_count" href="#tfchain.TFChainWallet.TFChainWallet.key_scan_count">key_scan_count</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.minter" href="#tfchain.TFChainWallet.TFChainWallet.minter">minter</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.mnemonic" href="#tfchain.TFChainWallet.TFChainWallet.mnemonic">mnemonic</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.network_type" href="#tfchain.TFChainWallet.TFChainWallet.network_type">network_type</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.public_key_new" href="#tfchain.TFChainWallet.TFChainWallet.public_key_new">public_key_new</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.seed" href="#tfchain.TFChainWallet.TFChainWallet.seed">seed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.threebot" href="#tfchain.TFChainWallet.TFChainWallet.threebot">threebot</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.transaction_sign" href="#tfchain.TFChainWallet.TFChainWallet.transaction_sign">transaction_sign</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TFChainWallet.transactions" href="#tfchain.TFChainWallet.TFChainWallet.transactions">transactions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TransactionSendResult" href="#tfchain.TFChainWallet.TransactionSendResult">TransactionSendResult</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TransactionSendResult.submitted" href="#tfchain.TFChainWallet.TransactionSendResult.submitted">submitted</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TransactionSendResult.transaction" href="#tfchain.TFChainWallet.TransactionSendResult.transaction">transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.TransactionSignResult" href="#tfchain.TFChainWallet.TransactionSignResult">TransactionSignResult</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.TransactionSignResult.signed" href="#tfchain.TFChainWallet.TransactionSignResult.signed">signed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TransactionSignResult.submitted" href="#tfchain.TFChainWallet.TransactionSignResult.submitted">submitted</a></code></li>
<li><code><a title="tfchain.TFChainWallet.TransactionSignResult.transaction" href="#tfchain.TFChainWallet.TransactionSignResult.transaction">transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.WalletBalance" href="#tfchain.TFChainWallet.WalletBalance">WalletBalance</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.WalletBalance.active" href="#tfchain.TFChainWallet.WalletBalance.active">active</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.addresses" href="#tfchain.TFChainWallet.WalletBalance.addresses">addresses</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.available" href="#tfchain.TFChainWallet.WalletBalance.available">available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.balance_add" href="#tfchain.TFChainWallet.WalletBalance.balance_add">balance_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_blockid" href="#tfchain.TFChainWallet.WalletBalance.chain_blockid">chain_blockid</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_height" href="#tfchain.TFChainWallet.WalletBalance.chain_height">chain_height</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.chain_time" href="#tfchain.TFChainWallet.WalletBalance.chain_time">chain_time</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.drain" href="#tfchain.TFChainWallet.WalletBalance.drain">drain</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.locked" href="#tfchain.TFChainWallet.WalletBalance.locked">locked</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.output_add" href="#tfchain.TFChainWallet.WalletBalance.output_add">output_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_available" href="#tfchain.TFChainWallet.WalletBalance.outputs_available">outputs_available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_spent" href="#tfchain.TFChainWallet.WalletBalance.outputs_spent">outputs_spent</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed">outputs_unconfirmed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_available">outputs_unconfirmed_available</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent" href="#tfchain.TFChainWallet.WalletBalance.outputs_unconfirmed_spent">outputs_unconfirmed_spent</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.unconfirmed" href="#tfchain.TFChainWallet.WalletBalance.unconfirmed">unconfirmed</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletBalance.unconfirmed_locked" href="#tfchain.TFChainWallet.WalletBalance.unconfirmed_locked">unconfirmed_locked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tfchain.TFChainWallet.WalletsBalance" href="#tfchain.TFChainWallet.WalletsBalance">WalletsBalance</a></code></h4>
<ul class="">
<li><code><a title="tfchain.TFChainWallet.WalletsBalance.addresses_multisig" href="#tfchain.TFChainWallet.WalletsBalance.addresses_multisig">addresses_multisig</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletsBalance.fund" href="#tfchain.TFChainWallet.WalletsBalance.fund">fund</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletsBalance.multisig_output_add" href="#tfchain.TFChainWallet.WalletsBalance.multisig_output_add">multisig_output_add</a></code></li>
<li><code><a title="tfchain.TFChainWallet.WalletsBalance.wallets" href="#tfchain.TFChainWallet.WalletsBalance.wallets">wallets</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>